<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Iamsleepingnow 世界</title>
  
  <subtitle>-P&amp;Y&amp;W-</subtitle>
  <link href="http://iamsleepingnow.github.io/atom.xml" rel="self"/>
  
  <link href="http://iamsleepingnow.github.io/"/>
  <updated>2023-06-30T13:04:58.820Z</updated>
  <id>http://iamsleepingnow.github.io/</id>
  
  <author>
    <name>彭҈̢̛艺҉͜͝伟҈̧̕</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PARTY AFTER PARTY，什么是PARTY？</title>
    <link href="http://iamsleepingnow.github.io/2023/06/30/Arts/PARTY%20AFTER%20PARTY%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AFPARTY%EF%BC%9F/"/>
    <id>http://iamsleepingnow.github.io/2023/06/30/Arts/PARTY%20AFTER%20PARTY%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AFPARTY%EF%BC%9F/</id>
    <published>2023-06-30T13:05:21.000Z</published>
    <updated>2023-06-30T13:04:58.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PARTY-AFTER-PARTY，什么是PARTY？"><a href="#PARTY-AFTER-PARTY，什么是PARTY？" class="headerlink" title="PARTY AFTER PARTY，什么是PARTY？"></a>PARTY AFTER PARTY，什么是PARTY？</h1><p>​        在工作时，我比较在意人们对于一些抽象事物的实际感受。它从何处来？又到哪里去？它的使命是什么？</p><p>​        我在我曾经制作的三维影像中对于这些问题有过一些回应。</p><p>​        我在2019年创作的《工人_博物馆》里谈论的是关于“时间”和“历史”的生产。在其世界观中，历史由一个抽象的工厂生产，并由其中的“工人”监督而制成，经由一些生产与消费的繁琐过程之后，在一个虚无的“博物馆”中被彻底遗弃。</p><p><img src="https://s2.loli.net/2023/06/30/gyxYm1wOt9QGPFZ.jpg" alt="Post_factory_002.jpg"></p><p>​        但实际上这是我对于历史本身的一些见解：它从何处来？从生产车间而来。又到哪里去？经过一番折腾后被埋藏和遗忘。它的使命是什么？有幸者将被重新解释（改写），然后进入记忆的档案；不幸者将没有资格被后人记录。</p><p>​        我在解读这些作品时，会让人感觉像是走进了一个较为意识流的境界中。说有人看过这一则作品解读，认为其不知所云。但实际上，我并不想专门去写作品的介绍。我经常在影像作品中将一些对于某种事物的突发情感通过强叙事性的渲染来表达出来，其多半原因应该来源于这个《工人_博物馆》，因为它是第一个使用这种叙事方式的作品。我的所谓“强叙事”，实际上只是在用理性的方式来解释感性认识，而且是使用流水账的方式进行的。</p><p><img src="https://s2.loli.net/2023/06/30/ux1B6jFXRbKiTmY.jpg" alt="Post_factory_009.jpg"></p><p>​        我在去年11月与徐健的双个展（XP，但是番茄花园版 eXPerienced and cracked）中，展出过一件文本作品《小石潭新记》，这就是一种用极端理性的思维来解释感性认识的一种新的尝试，尤其是使用一些公认权威的创作者的作品为范本来改写，但是改写的形式是我独有的风格。在以前的学生时代，老师只让学生们去理解诗文中的文学含义。但当时我眼中的诗文不仅有文学含义，还有其背后的形式逻辑。《小石潭新记》中，我着重将这些拔出，作为诗文的骨架，文学却只是骨架上的皮肉。算不上买椟还珠，只是使用一种新的看世界的方式罢了。</p><p><img src="https://s2.loli.net/2023/06/30/Ak8MxIVDwFyXQdz.png" alt="XiaoShiTanJi_001.png"></p><p>​        我比较喜欢三维动画这种媒介。“动画”对于我来说属于美术媒介范畴，我曾经制作过手绘逐帧动画和定格动画。“圈”里人说，只有画得多了，就知道节奏和关键帧该怎么走了。我认为这种技术比较吃熟练性，与理科不同，如此学问应当是不可教授的。这种东西门槛不高，但要做得好却非常困难，且“好”的评价标准并不唯一。可能受到前人逐帧动画的画面影响，我的创作风格还是会往某种亚文化方向靠，例如“core”和“rhg”，画面偏阴冷但节奏较慢、人物大头但肢体末端较粗等等，但是并不影响整体风格编排。三维动画的创作门槛较高，但正是由于其出效果快、输出极为稳定的特征，做得像模像样其实也不算困难。</p><p><img src="https://s2.loli.net/2023/06/30/5QLNHpMCUlfZ8Wk.jpg" alt="the_Meta-Universe_Poetry_004.jpg"></p><p>​        在大学期间，我感觉自己走上了一条不归路，开始学习编程与游戏制作。这种东西感觉与我的专业之间稍微有一定的联系，但其中的方法论却天差地别。三维美术与机制实现是一种极端逻辑化的演绎，你需要学会如何与计算机打交道。计算机就是控制论的化身，操作人员与计算机本身共同构成了一个控制系统，人体则是这个系统中最慢的交互单元。抛开这个控制系统不谈，其内部的所有机制构成是数据与逻辑。程序就是指令，是你写给计算机的一封信，计算机会死板地完全依照此信的程式工作。此类技术有一种将想象力化为现实的能力，并且带给了我新的工作习惯：分门别类与将工作转为流程。</p><p>​        我有几个游戏作品，拿2021年的《阈限志》来说，其制作方法论为：第一步，试错。这一步是最好玩的一步，发挥软件的极限，玩起来，就连软件故障都是创作的来由。第二步，流程。绘制策划图表，分门别类，步骤极为严苛。第三步，制作。也叫实现，基于策划案，使用最有效率的方式来编码。第四步，包装。也叫落地，根据整体调性来进行微调，保证整体完整性与质量。这四步构成的方法论非常适合大型创作，正是由于这样的极端演绎，使得作品一般情况下完整度非常之高。</p><p><img src="https://s2.loli.net/2023/06/30/pXEPYfSW7iyrlTs.jpg" alt="the_Record_of_Limen_007.jpg"></p><p>​        试错行为是非常有意义的。克劳斯·皮亚斯说过，“黑客”在更大程度上表示一种从设备本身的功能中所能获得的乐趣……可以被解释为一种情景滥用(misuse)。我的很多灵感其实都来自于这种情景滥用：我曾经在三维软件中“滥用”过着色器，将着色器的数值限制打开了，把某一个材质模版中的金属度和粗糙度改成了极端数字，在渲染管线的交互下，它不再是“泡泡”，而更像是“黑洞”，靠近“黑洞”的物体都改变了画风。我还滥用过三维摄像机，将视场角篡改为负值，一切事物都变成了近小远大的逆透视。这些都是媒介本身的故障，既然它能够被实现，那么就更有理由被存在。</p><p>​        我做三维动画擅长于使用程序辅助，因为做动画时经常会出现一些传统三维动画很难完成的需求。比如说，某种生成式艺术、随机性以及超文本性质。虽说不需要观众去交互，但是适当的程序介入会让动画更有有机性。复制是程序最擅长的行为，成百上千个动画实体同台演义，这是在程序语言里再正常不过的事情了。程序只需要定义实体们的行为规范与规则阈限，剩下的交给计算机就行。</p><p>​        这次展出的是动画《心机接口》。由于前几年的元宇宙大爆炸与其快速湮灭的特性，我决定要做一个作品来记录这次“闪击”。元宇宙体系将现实中的能源转化为虚拟中的价值，并在虚拟中使用抽象的形式“打印”出来，这实质上是一种对于现实资源的再现。为了衬托这次叙事，我虚构了一个被称为“元宇宙之心”的仪式场所（庙宇）。场地中心放置了一台三维打印机，仪式过程就是将另一个世界的现实能源运输到庙里面来打印成所谓虚拟价值。仪式参与者与祭司在“NFT的海洋”中的殿台上操控者仪式的进行，但没有人知道仪式最后成功与否。</p><p><img src="https://s2.loli.net/2023/06/30/B1iJjmDP2kxOqEe.jpg" alt="the_Meta-Universe_Poetry_005.jpg"></p><p>​        这套流程与我之前制作的NFT作品很像，我基于1987年的第四套人民币的形式制作过一套冥币，其人像依照货币规格替换为了道家六御。我认为，传统意识里的祭祖需要烧纸钱，纸钱就是现实中的实体价值，与烧煤石油天然气并无二致。纸钱在焚烧之后化为了青烟，青烟会顺着时空裂隙运输到虚拟世界中，然后转化为虚拟中的价值。实际上我是无神论的，如此处理只是为了调侃。</p><p><img src="https://s2.loli.net/2023/06/30/lQfcuaLtmXxFivd.jpg" alt="TianDiBank_001.jpg"></p><p>​        这些煤石油天然气的“青烟”在运输到虚拟世界了之后，化为了三维打印用的耗材，比如说PLA或者ABS什么的。在影像中，这些耗材被打印为了一些有价值的物体，如城市楼阁和心脏。“心脏”实际上有两层含义，其一就是价值本身，其二代表了此地为元宇宙的中心。何为元宇宙中的价值？我并不想给出一个确定的答案来映射，因为对于不同地域不同时间不同利益而言，意义差距分明。一说心脏代表一个庞大系统的中心，似乎有些牵强，一般情况下大脑才应当是计算系统之中心的正确隐喻。作品名称出自于“脑机接口”，但在我看来，心脏是人体中最有价值的器官，与其说大脑是一个计算设备，类似于中央处理器和显示适配器；那么心脏就是血泵，类似于电源。没有电源，计算机连主板灯都不会亮。</p><p>​        这些关系只是我对于元宇宙运行模式的直观想象，并不想涉及更深层次的经济理论研究讨论，我描述的宇宙与经济无关。作品的英文名为the Meta-Universe Poetry，正确的元宇宙写法是metaverse，错写也不是为了避讳，只是我更想将其解释为“宇宙而上”罢了，元宇宙讲究的宇宙是独立且客观的，并褒奖为了一个绝对真理。这个系统构造处处合理且无懈可击，这是非常有意思的。Poetry是诗，在这里特指叙事诗，动画一直在用隐蔽的方式来尝试解释这个系统的生产与归宿，这就构成了诗。</p><p><img src="https://s2.loli.net/2023/06/30/VwDC5r7IPigzQHo.jpg" alt="CuraPrinterHeart.jpg"></p><p>​        从制作上来说，在软件中模拟三维打印的过程比较繁琐。扫描软件会将三维模型的体积转化为一圈圈盘绕的机械文本指令（参考FDM熔融沉积技术），这种形式就比较像小学时候捏的陶泥罐子，只不过是一个复杂一点的版本罢了。我将其中的数据指令文件的文本使用正则提取的方式转换成了excel表格，自己编写代码让unity引擎去读取表格文件，转为路径指令，最后实时渲染出来。这种技术也就仅仅是数据的转换而已，但这种数据转换跟数据可视化不同。在我看来，后者只能服务于工业生产，前者却蒙上了一层诗性。它从何处来？又到哪里去？它的使命是什么？</p><p>​        为了完善这整个作品宇宙的控制体系，我自发性地研究了可视化编程的逻辑。我不反对使用可视化编程的方式来编码，因为它确实为美术与策划带来了许多便利。但是难以维护、结构复杂时不直观、效率不高的问题仍然存在。我在作品中使用了各种各样的计算节点来表现整个元宇宙世界的运行法则，这种东西相当于一个又一个的代码区块，将一个输出端口拉出一条连线接入一个输入端口，在一定程度上模拟了TCP协议的逻辑（但有些节点是一对多传输），数据块在其中被传送、被计算、被引用。我在这里有一些对于“链”的媒介隐喻，但究其技术逻辑又不完全是。</p><p><img src="https://s2.loli.net/2023/06/30/TlznD6ZcueaRk1I.jpg" alt="the_Meta-Universe_Poetry_002.jpg"></p><p>​        从写作上来说，我仍然沿袭了之前的流水账小学生叙事，但跟之前不同的是，我使用了多个章节来叙述。每一个章节单独拎出来就是一幕幕的短篇影像，但是要把这些章节看为一个整体还是需要一点想象力的。而且每一章节的细节都是如此之多，这是我故意而为之，把琐碎的技术细节无限制地放大，这正是体现了先前创作方法论中的“试错”步骤，先基于技术媒介来玩耍，要的就是酷炫，之后根据叙事意义来编排哪里需要酷炫，为何酷炫，有多酷炫。但这种繁复的细节会导致一个后果，即让人不太容易抓住重点。我在展场与观众交流时，发现他们每个人都有每个人的“心机接口”，形态各异，但是又在某种朦胧的方面出奇地一致。</p><p><img src="https://s2.loli.net/2023/06/30/bxKvrYsqZpB2ozO.jpg" alt="the_Meta-Universe_Poetry_006.jpg"></p><p>​        我在其中的某一章节使用了从头到尾的长镜头。这是一整个超文本段落，我设计了一套完整的文本单元，其剧本单元（脚本单元）本该是由观众来自行构造的，但作为视频影像还是使用了线性叙事的方式来进行播报。超文本遍历文学是一个有几十年历史的文本媒介，阅读者在文本阅读中可以使用交互的方式选择自己的“世界线”，这个技巧在我的许多游戏作品中都能找到实例。在视频中，鼠标操控着文本单元的跳转，实际上是在进行元宇宙的打印仪式，角色背后的打印机会根据文本进度来打印元宇宙价值。</p><p><img src="https://s2.loli.net/2023/06/30/pf2j6WKXGkn3VEd.png" alt="UnityMetaverse.png"></p><p>​        也曾经协调过作品的语言，也就是“调性”。我暂时不太想钻研这个作品它是否致敬了某位大师、调戏了某个社会事件或者文化圈，亦或是要求观众必须了解整个迷因的来龙去脉才能对作品有共同话语的研究性创作，我只是想把我学过的一切全部忘掉，基于个人感情来创作，使用自己独有的风格与见解，用个人的方式去解释周遭，让更多人能够关注到周遭事物的生产与归宿：它从何处来？又到哪里去？它的使命是什么？</p><p>​        借着这次展览机会，我很乐意把我对于作品中的一些琐碎的想法分享出来，我也不叨叨了，我就说一下我自己对于这个展的理解。这次展览的主题是PARTY AFTER PARTY，两个party的意思并不相同，我有一种将party解释为仪式的冲动。仪式就是我谈论的这些“物”、它们从哪里来到哪里去的过程的载体。仪式的阈前阶段是从哪里来，阈后阶段是到哪里去。阈限阶段则可以被解释为“演绎”过程，整个作品就是如此演绎的记录。第一个party是作品的记录的演绎，第二个party是这场大爆炸的余烬的光辉。</p><p><img src="https://s2.loli.net/2023/06/30/Ih2DKYTJiHE5avC.jpg" alt="the_Meta-Universe_Poetry_011.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PARTY-AFTER-PARTY，什么是PARTY？&quot;&gt;&lt;a href=&quot;#PARTY-AFTER-PARTY，什么是PARTY？&quot; class=&quot;headerlink&quot; title=&quot;PARTY AFTER PARTY，什么是PARTY？&quot;&gt;&lt;/a&gt;PARTY</summary>
      
    
    
    
    <category term="艺术" scheme="http://iamsleepingnow.github.io/categories/%E8%89%BA%E6%9C%AF/"/>
    
    
    <category term="艺术" scheme="http://iamsleepingnow.github.io/tags/%E8%89%BA%E6%9C%AF/"/>
    
    <category term="展览" scheme="http://iamsleepingnow.github.io/tags/%E5%B1%95%E8%A7%88/"/>
    
  </entry>
  
  <entry>
    <title>链式编程与UniRX的基础使用</title>
    <link href="http://iamsleepingnow.github.io/2023/04/20/Unity/%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8EUniRX%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <id>http://iamsleepingnow.github.io/2023/04/20/Unity/%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8EUniRX%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</id>
    <published>2023-04-19T17:54:42.000Z</published>
    <updated>2023-04-22T09:20:03.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链式编程与UniRX的基础使用"><a href="#链式编程与UniRX的基础使用" class="headerlink" title="链式编程与UniRX的基础使用"></a>链式编程与UniRX的基础使用</h1><h1 id="第一部分：链式编程"><a href="#第一部分：链式编程" class="headerlink" title="第一部分：链式编程"></a><font color = #ff4444>第一部分：链式编程</font></h1><blockquote><p>链式方法在C#中为拥有返回值的扩展静态方法</p></blockquote><ul><li>C#里面可以写一种特殊的工具方法，专门用来扩展某个类型的使用，任意此类型都可以直接呼出此方法，这种方法称作为扩展方法。</li><li>扩展方法必须放在一个非泛型静态类中，一般设置一个工具类来存放即可。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">UtilityExtension</span><span class="comment">//这是一个非泛型静态类，static就是静态修饰符</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//扩展方法定义示范</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ExtensionTest</span>(<span class="params"><span class="keyword">this</span> GameObject obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//参数中必须有this修饰符来修饰被扩展类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//扩展方法使用示范</span></span><br><span class="line">    gameObject.ExtensionTest();<span class="comment">//扩展方法可以直接呼出，特别方便</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>好了，已经知道了扩展类怎么使用了，那么什么样才是链式编程哪？</li><li>很简单，扩展类携带返回值即可。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">UtilityExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里为了方便解释什么是链式的传参，将这两个方法写成了一个循环</span></span><br><span class="line">    <span class="comment">//前者从GameObject呼出，返回其Transform组件</span></span><br><span class="line">    <span class="comment">//后者从Transform呼出，返回其GameObject组件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transform <span class="title">GetTransform</span>(<span class="params"><span class="keyword">this</span> GameObject obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.transform;<span class="comment">//设置返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GameObject <span class="title">GetGameObject</span>(<span class="params"><span class="keyword">this</span> Transform trans</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> trans.gameObject;<span class="comment">//设置返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//扩展方法使用示范</span></span><br><span class="line">    GameObject go = <span class="keyword">this</span>.gameObject</span><br><span class="line">        .GetTransform()<span class="comment">//由上游输入GameObject类型，向下游返回Transform类型</span></span><br><span class="line">    .GetGameObject()<span class="comment">//由上游输入Transform类型，向下游返回GameObject类型</span></span><br><span class="line">        .GetTransform()<span class="comment">//同上</span></span><br><span class="line">    .GetGameObject();<span class="comment">//同上</span></span><br><span class="line">    print(go.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这些方法能像链条一样一个接一个地写下去，与节点式编程的逻辑很像。</li><li>它们都有一些相同的特征：<ul><li>链式方法会从一种数据类型呼出，类似节点的输入。</li><li>链式方法会从一种数据类型返回，类似节点的输出。</li></ul></li><li>下面还有一个例子，是关于加减法的，可能更好理解。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">UtilityExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义了三个数学计算方法</span></span><br><span class="line">    <span class="comment">//此处扩展方法返回值与被拓展类型一致，意味着能够互相调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">AddInt</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">int</span> self, <span class="built_in">int</span> fact</span>)<span class="comment">//加法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> self + fact;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">SubInt</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">int</span> self, <span class="built_in">int</span> fact</span>)<span class="comment">//减法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> self - fact;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">AbsInt</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">int</span> self</span>)<span class="comment">//绝对值</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Mathf.Abs(self);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> myInt = <span class="number">10</span>;<span class="comment">//定义一个数值类型</span></span><br><span class="line">    <span class="comment">//链式编程的特征是能在一句代码里加数个扩展方法</span></span><br><span class="line">    myInt = myInt<span class="comment">//多换行可能有助于阅读</span></span><br><span class="line">        .AddInt(<span class="number">20</span>)<span class="comment">//加上20</span></span><br><span class="line">        .SubInt(<span class="number">35</span>)<span class="comment">//减去35</span></span><br><span class="line">        .AbsInt()<span class="comment">//绝对值</span></span><br><span class="line">        .SubInt(<span class="number">5</span>);<span class="comment">//减去5</span></span><br><span class="line">    <span class="comment">//|10 + 20 - 35| - 5 = 0</span></span><br><span class="line">    print(<span class="string">$&quot;答案为：<span class="subst">&#123;myInt&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为了对比与传统方法的区别，我特地附注了传统方法示例：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">UtilityExtension</span><span class="comment">//此处没有静态类的限制，图方便就这么写了</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义了三个数学计算方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">AddInt</span>(<span class="params"><span class="built_in">int</span> self, <span class="built_in">int</span> fact</span>)<span class="comment">//加法（传统版）</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> self + fact;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">SubInt</span>(<span class="params"><span class="built_in">int</span> self, <span class="built_in">int</span> fact</span>)<span class="comment">//减法（传统版）</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> self - fact;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">AbsInt</span>(<span class="params"><span class="built_in">int</span> self</span>)<span class="comment">//绝对值（传统版）</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Mathf.Abs(self);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> myInt2 = <span class="number">10</span>;<span class="comment">//定义一个数值类型</span></span><br><span class="line">    <span class="comment">//传统方法似乎有点不太可读</span></span><br><span class="line">    myInt2 = SubInt(AbsInt(SubInt(AddInt(myInt2, <span class="number">20</span>), <span class="number">35</span>)), <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//|10 + 20 - 35| - 5 = 0</span></span><br><span class="line">    print(<span class="string">$&quot;答案为：<span class="subst">&#123;myInt2&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第二部分：UniRX的基础使用"><a href="#第二部分：UniRX的基础使用" class="headerlink" title="第二部分：UniRX的基础使用"></a><font color = #ff4444>第二部分：UniRX的基础使用</font></h1><ul><li>最近终于有时间来了解这个代码集了，因为只自学了两天，所以可能有些条目存在理解问题。</li><li>UniRX是什么我不会去介绍，因为我不知道这么去给它（Unity的响应式编程）下定义。但是它能实现一些很强的功能，这些功能的使用方式是基于链式编程的。</li><li>我将一些基础方法做了分类，先介绍基础使用，再介绍这些单独的方法。</li></ul><h3 id="怎么获取UniRX"><a href="#怎么获取UniRX" class="headerlink" title="怎么获取UniRX"></a>怎么获取UniRX</h3><ul><li><a href="https://assetstore.unity.com/packages/tools/integration/unirx-reactive-extensions-for-unity-17276">去Unity的资源商店里安装</a></li></ul><h3 id="〇：一些基础前置知识（可跳过）"><a href="#〇：一些基础前置知识（可跳过）" class="headerlink" title="〇：一些基础前置知识（可跳过）"></a>〇：一些基础前置知识（可跳过）</h3><h4 id="前置知识-C-Lambda表达式（匿名方法）"><a href="#前置知识-C-Lambda表达式（匿名方法）" class="headerlink" title="[前置知识]C# Lambda表达式（匿名方法）"></a>[前置知识]C# Lambda表达式（匿名方法）</h4><ul><li>用途：用作一个匿名的方法，如果你不想在脚本底下再定义一个额外的方法的话。</li><li>Lambda表达式一般写作：<code>()=&gt;&#123;&#125;</code></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.Events;<span class="comment">//引入命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> UnityEvent ev;<span class="comment">//这是一个事件委托</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//为事件委托注册普通方法：</span></span><br><span class="line">    ev.AddListener(TestFunction);</span><br><span class="line">    <span class="comment">//为事件委托注册匿名方法：（不换行也是可以的）</span></span><br><span class="line">    <span class="comment">//()内为匿名函数的传参，无传参就写一个()，=&gt;指向一个&#123;&#125;，&#123;&#125;里是方法体</span></span><br><span class="line">    ev.AddListener(() =&gt;</span><br><span class="line">    &#123; </span><br><span class="line">        Debug.Log(<span class="string">&quot;匿名方法&quot;</span>); </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//事件播报：</span></span><br><span class="line">    ev.Invoke();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFunction</span>()<span class="comment">//这是普通方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(<span class="string">&quot;普通方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有时候匿名方法里需要传参。</li><li>当需要传参时，写作：<code>(int i)=&gt;&#123;&#125;</code>或<code>(i)=&gt;&#123;&#125;</code>或<code>i=&gt;&#123;&#125;</code></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.Events;<span class="comment">//引入命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> UnityEvent&lt;<span class="built_in">float</span>&gt; ev;<span class="comment">//这是一个事件委托，携带一个浮点参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//为事件委托注册普通方法：</span></span><br><span class="line">    ev.AddListener(TestFunction);</span><br><span class="line">    <span class="comment">//为事件委托注册匿名方法：（不换行也是可以的）</span></span><br><span class="line">    <span class="comment">//只有一个传参的情况下，()可以不用写，如下这种情况也可以写成(float f)</span></span><br><span class="line">    ev.AddListener(f =&gt;</span><br><span class="line">    &#123; </span><br><span class="line">        Debug.Log(<span class="string">$&quot;匿名方法 <span class="subst">&#123;f&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//事件播报：</span></span><br><span class="line">    ev.Invoke();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFunction</span>(<span class="params"><span class="built_in">float</span> f</span>)<span class="comment">//这是普通方法，需要传入一个浮点参数</span></span></span><br><span class="line">&#123;</span><br><span class="line">Debug.Log(<span class="string">$&quot;普通方法 <span class="subst">&#123;f&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="壹：最简单的UniRX结构"><a href="#壹：最简单的UniRX结构" class="headerlink" title="壹：最简单的UniRX结构"></a>壹：最简单的UniRX结构</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这些是可能需要的命名空间引入</span></span><br><span class="line"><span class="keyword">using</span> UniRx;</span><br><span class="line"><span class="keyword">using</span> UniRx.Triggers;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Observable.EveryUpdate()<span class="comment">//从Mono生命周期生成观察器</span></span><br><span class="line">    .Subscribe(_ =&gt;<span class="comment">//观察器订阅执行事件</span></span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;TODO&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);<span class="comment">//绑定本物体的生命周期</span></span><br><span class="line">    <span class="comment">//*注：如果没有绑定任何物体的生命周期，那么这则响应将会一直嵌入内存中，直到Unity编辑器的关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一行“<code>Observable.EveryUpdate()</code>”构成了一个观察器，此时返回值类型为<code>IObservable</code>。</li><li>第二行“<code>.Subscribe(_ =&gt;&#123;print(&quot;TODO&quot;);&#125;)</code>”为此观察器订阅了一个onNext事件，构成了一个释放器，此时返回值类型为<code>IDisposable</code>。</li><li>第三行“<code>.AddTo(this)</code>”将此释放器的生命周期绑定到本物体上，语句结束。</li><li>这个消息语句的目的是：在每帧游戏刷新时输出“TODO”，直到本物体的销毁。</li><li>这个消息语句替换为节点化编程类似于：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    1(&quot;EveryUpdate&quot;)==&gt;2(&quot;Subscribe&quot;);</span><br><span class="line">    2(&quot;Subscribe&quot;)==&gt;3(&quot;AddTo&quot;);</span><br></pre></td></tr></table></figure><h3 id="贰：观察者、观察器与释放器"><a href="#贰：观察者、观察器与释放器" class="headerlink" title="贰：观察者、观察器与释放器"></a>贰：观察者、观察器与释放器</h3><ul><li>观察者是Observer，接口为IObserver</li><li>观察器是Observable，接口为IObservable</li><li>释放器是Disposable，接口为IDisposable</li></ul><h4 id="【观察者】"><a href="#【观察者】" class="headerlink" title="【观察者】"></a>【观察者】</h4><ul><li><code>Subscribe</code>操作符主要干一个功能，将输入的观察器绑定到新建的观察者上，并向观察者输入三状态方法：<code>onNext</code>，<code>onComplete</code>，<code>onError</code>。</li><li>由于观察者一般是操作符自动生成的，所以一般不会有什么特殊操作。</li></ul><h4 id="【观察器】"><a href="#【观察器】" class="headerlink" title="【观察器】"></a>【观察器】</h4><ul><li>有多种方法可以用来生成观察器，不仅仅只有<code>EveryUpdate</code>一种。</li><li>比如说从某游戏物体身上生成的观察器，这样的观察器转换的释放器可以不考虑绑定问题。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">public</span> GameObject GO_Sample;<span class="comment">//外部获取一个游戏物体</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//物体生命周期观察器会自动绑定该物体，不需要使用AddTo去重新绑定</span></span><br><span class="line">    GO_Sample.OnEnableAsObservable()<span class="comment">//从当物体可用时生成观察器</span></span><br><span class="line">        .Subscribe(_ =&gt; &#123; print(<span class="string">&quot;OnEnable&quot;</span>); &#125;);</span><br><span class="line">    GO_Sample.OnDisableAsObservable()<span class="comment">//从当物体禁用时生成观察器</span></span><br><span class="line">        .Subscribe(_ =&gt; &#123; print(<span class="string">&quot;OnDisable&quot;</span>); &#125;);</span><br><span class="line">    GO_Sample.OnDestroyAsObservable()<span class="comment">//从当物体被删除时生成观察器</span></span><br><span class="line">        .Subscribe(_ =&gt; &#123; print(<span class="string">&quot;OnDestroy&quot;</span>); &#125;);</span><br><span class="line">    GO_Sample.UpdateAsObservable()<span class="comment">//从物体更新生成观察器（FixedUpdate / LateUpdate）</span></span><br><span class="line">        .Subscribe(_ =&gt; &#123; print(<span class="string">&quot;Update&quot;</span>); &#125;);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    GO_Sample.OnBecameVisibleAsObservable()<span class="comment">//从当物体渲染器组件可用时生成观察器</span></span><br><span class="line">        .Subscribe(_ =&gt; &#123; print(<span class="string">&quot;OnBecameVisible&quot;</span>); &#125;);</span><br><span class="line">    GO_Sample.OnBecameInvisibleAsObservable()<span class="comment">//从当物体渲染器组件不可用时生成观察器</span></span><br><span class="line">        .Subscribe(_ =&gt; &#123; print(<span class="string">&quot;OnBecameInvisible&quot;</span>); &#125;);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    GO_Sample.OnMouseDownAsObservable()<span class="comment">//从当鼠标按下此物体时那帧生成观察器</span></span><br><span class="line">        .Subscribe(_ =&gt; &#123; print(<span class="string">&quot;OnMouseDown&quot;</span>); &#125;);</span><br><span class="line">    GO_Sample.OnMouseDragAsObservable()<span class="comment">//从当鼠标持续按下此物体时生成观察器</span></span><br><span class="line">        .Subscribe(_ =&gt; &#123; print(<span class="string">&quot;OnMouseDrag&quot;</span>); &#125;);</span><br><span class="line">    GO_Sample.OnMouseEnterAsObservable()<span class="comment">//从当鼠标进入此物体时那帧生成观察器</span></span><br><span class="line">        .Subscribe(_ =&gt; &#123; print(<span class="string">&quot;OnMouseEnter&quot;</span>); &#125;);</span><br><span class="line">    GO_Sample.OnMouseExitAsObservable()<span class="comment">//从当鼠标悬浮此物体之上时生成观察器</span></span><br><span class="line">        .Subscribe(_ =&gt; &#123; print(<span class="string">&quot;OnMouseExit&quot;</span>); &#125;);</span><br><span class="line">    GO_Sample.OnMouseOverAsObservable()<span class="comment">//从当鼠标移出此物体时那帧生成观察器</span></span><br><span class="line">        .Subscribe(_ =&gt; &#123; print(<span class="string">&quot;OnMouseOver&quot;</span>); &#125;);</span><br><span class="line">    GO_Sample.OnMouseUpAsButtonAsObservable()<span class="comment">//从当鼠标抬起于此物体时且与按下时的物体相同时那帧生成观察器</span></span><br><span class="line">        .Subscribe(_ =&gt; &#123; print(<span class="string">&quot;OnMouseUpAsButton&quot;</span>); &#125;);</span><br><span class="line">    GO_Sample.OnMouseUpAsObservable()<span class="comment">//从当鼠标抬起于此物体时那帧生成观察器</span></span><br><span class="line">        .Subscribe(_ =&gt; &#123; print(<span class="string">&quot;OnMouseUp&quot;</span>); &#125;);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    GO_Sample.OnCollisionEnterAsObservable()<span class="comment">//从当物体进入碰撞除了角色控制器时生成观察器（有2D版本）</span></span><br><span class="line">        .Subscribe(_ =&gt; &#123; print(<span class="string">&quot;OnCollisionEnter&quot;</span>); &#125;);</span><br><span class="line">    GO_Sample.OnCollisionStayAsObservable()<span class="comment">//从当物体持续碰撞除了角色控制器时生成观察器（有2D版本）</span></span><br><span class="line">        .Subscribe(_ =&gt; &#123; print(<span class="string">&quot;OnCollisionStay&quot;</span>); &#125;);</span><br><span class="line">    GO_Sample.OnCollisionExitAsObservable()<span class="comment">//从当物体离开碰撞除了角色控制器时生成观察器（有2D版本）</span></span><br><span class="line">        .Subscribe(_ =&gt; &#123; print(<span class="string">&quot;OnCollisionExit&quot;</span>); &#125;);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    GO_Sample.OnTriggerEnterAsObservable()<span class="comment">//从当物体进入触发除了角色控制器时生成观察器（有2D版本）</span></span><br><span class="line">        .Subscribe(_ =&gt; &#123; print(<span class="string">&quot;OnTriggerEnter&quot;</span>); &#125;);</span><br><span class="line">    GO_Sample.OnTriggerStayAsObservable()<span class="comment">//从当物体持续触发除了角色控制器时生成观察器（有2D版本）</span></span><br><span class="line">        .Subscribe(_ =&gt; &#123; print(<span class="string">&quot;OnTriggerStay&quot;</span>); &#125;);</span><br><span class="line">    GO_Sample.OnTriggerExitAsObservable()<span class="comment">//从当物体离开触发除了角色控制器时生成观察器（有2D版本）</span></span><br><span class="line">        .Subscribe(_ =&gt; &#123; print(<span class="string">&quot;OnTriggerExit&quot;</span>); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以及由集合类型演变而成的观察器，将每一个数据转化为一个该类型的信号来输出（字典也可以）。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//此处定义数列类型与数组类型</span></span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; lst_Int = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="built_in">int</span>[] arr_Int = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//集合类型的ToObservable将集合中的每一个数据转化为一个该类型的信号来输出，相当于foreach</span></span><br><span class="line">    lst_Int.ToObservable()</span><br><span class="line">        .Subscribe(i =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">$&quot;List <span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    arr_Int.ToObservable()</span><br><span class="line">        .Subscribe(i =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">$&quot;Array <span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>UniRX有一些响应化的数值，也可以转换成观察器，仅当值变化时触发事件。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ReactiveProperty&lt;<span class="built_in">int</span>&gt; RP_Int = <span class="keyword">new</span> ReactiveProperty&lt;<span class="built_in">int</span>&gt;();<span class="comment">//响应化类型</span></span><br><span class="line"><span class="keyword">public</span> ReactiveCollection&lt;<span class="built_in">int</span>&gt; RC_Int = <span class="keyword">new</span> ReactiveCollection&lt;<span class="built_in">int</span>&gt;();<span class="comment">//响应化集合</span></span><br><span class="line"><span class="keyword">public</span> ReactiveDictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; RD_Int = <span class="keyword">new</span> ReactiveDictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt;();<span class="comment">//响应化字典</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    RP_Int.AsObservable()</span><br><span class="line">        .Subscribe(i =&gt; print(<span class="string">&quot;数据变化&quot;</span>));</span><br><span class="line">    RC_Int.ObserveAdd()</span><br><span class="line">        .Subscribe(lst =&gt; print(<span class="string">&quot;集合元素增加&quot;</span>));</span><br><span class="line">    RC_Int.ObserveRemove()</span><br><span class="line">        .Subscribe(lst =&gt; print(<span class="string">&quot;集合元素减少&quot;</span>));</span><br><span class="line">    RC_Int.ObserveCountChanged()</span><br><span class="line">        .Subscribe(lst =&gt; print(<span class="string">&quot;集合元素个数变化&quot;</span>));</span><br><span class="line">    RD_Int.ObserveAdd()</span><br><span class="line">        .Subscribe(lst =&gt; print(<span class="string">&quot;字典元素增加&quot;</span>));</span><br><span class="line">    RD_Int.ObserveRemove()</span><br><span class="line">        .Subscribe(lst =&gt; print(<span class="string">&quot;字典元素减少&quot;</span>));</span><br><span class="line">    RD_Int.ObserveCountChanged()</span><br><span class="line">        .Subscribe(lst =&gt; print(<span class="string">&quot;字典元素个数变化&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有一种泛型拓展方法，可以记录某某类中的某某值是否发生了改变：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">public</span> CharacterController cc;<span class="comment">//获取角色控制器</span></span><br><span class="line"><span class="keyword">public</span> ReactiveProperty&lt;<span class="built_in">int</span>&gt; RP_Int = <span class="keyword">new</span> ReactiveProperty&lt;<span class="built_in">int</span>&gt;();<span class="comment">//响应化类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//ObserveEveryValueChanged可以绑定在任何类的任何子属性上，观测此子属性的变化</span></span><br><span class="line">    cc.ObserveEveryValueChanged(cha =&gt; cha.isGrounded)</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;角色离地或接地&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    RP_Int.ObserveEveryValueChanged(RP_Int =&gt; RP_Int.Value)</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;值变化&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    Observable.EveryUpdate()<span class="comment">//每一帧去更改RP_Int.Value的值</span></span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            RP_Int.Value++;</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="【释放器】"><a href="#【释放器】" class="headerlink" title="【释放器】"></a>【释放器】</h4><ul><li>当你使用<code>Subscribe</code>方法将观察器转为释放器后，需要去考虑释放器如何从内存中释放</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    IDisposable dpb = <span class="literal">null</span>;<span class="comment">//观察器的返回值为IDisposable接口类型</span></span><br><span class="line">dpb = Observable.EveryUpdate()</span><br><span class="line">.Subscribe(_ =&gt;</span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">&quot;TODO&quot;</span>);</span><br><span class="line">dpb.Dispose();<span class="comment">//手动释放观察器</span></span><br><span class="line">&#125;);</span><br><span class="line">    <span class="comment">//在运行的第一帧时，dpb.Dispose()将释放器释放，释放器释放后将不再继续运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>释放器有一个独立版本，类型为<code>CompositeDisposable</code>。多个释放器可以被绑定在一起释放。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这种应该算作是“合成释放器”，简称垃圾桶</span></span><br><span class="line">    CompositeDisposable com_dpb = <span class="keyword">new</span> CompositeDisposable();<span class="comment">//释放器</span></span><br><span class="line">    <span class="comment">// ------------------------</span></span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;TODO1&quot;</span>);</span><br><span class="line">            com_dpb.AddTo(gameObject);<span class="comment">//可以将释放器绑定到某物体上</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(com_dpb);<span class="comment">//绑定到释放器</span></span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;TODO2&quot;</span>);</span><br><span class="line">            com_dpb.Dispose();<span class="comment">//手动释放释放器</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(com_dpb);<span class="comment">//绑定到释放器</span></span><br><span class="line">    <span class="comment">//以下是“合成释放器”的一些基础方法：</span></span><br><span class="line">    com_dpb.Clear();<span class="comment">//清空垃圾桶，释放里面的所有释放器，但唯独不释放垃圾桶</span></span><br><span class="line">    com_dpb.Dispose();<span class="comment">//释放垃圾桶，释放里面的所有释放器</span></span><br><span class="line">    com_dpb.Add(Observable.EveryUpdate().Subscribe());<span class="comment">//单独去添加一个释放器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="叁：主体类Subject"><a href="#叁：主体类Subject" class="headerlink" title="叁：主体类Subject"></a>叁：主体类Subject</h3><ul><li><code>Subject</code>类型既实现了<code>IObserver</code>接口，又实现了<code>IObservable</code>接口。</li><li>可以把<code>Subject</code>想象成一个用户自定义的观察器，用户能够随时调用观察器的观察者，而像其他观察器就无法手动调用。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Subject&lt;<span class="built_in">int</span>&gt; SUB_Int = <span class="keyword">new</span> Subject&lt;<span class="built_in">int</span>&gt;();<span class="comment">//主体化类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Subject类型订阅事件</span></span><br><span class="line">    SUB_Int</span><br><span class="line">        .Subscribe((index) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            SUB_Int.Dispose();</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">//以下是Subject类型常用方法：</span></span><br><span class="line">    SUB_Int.OnNext(<span class="number">0</span>);<span class="comment">//执行Subject</span></span><br><span class="line">    SUB_Int.OnCompleted();<span class="comment">//结束Subject</span></span><br><span class="line">    SUB_Int.OnError(<span class="keyword">new</span> Exception());<span class="comment">//异常Subject</span></span><br><span class="line">    SUB_Int.AddTo(<span class="keyword">this</span>);<span class="comment">//绑定Subject</span></span><br><span class="line">    SUB_Int.Dispose();<span class="comment">//释放Subject</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="肆：事件类操作符（常用）"><a href="#肆：事件类操作符（常用）" class="headerlink" title="肆：事件类操作符（常用）"></a>肆：事件类操作符（常用）</h3><ul><li><p><code>Subscribe</code>：注册事件</p></li><li><p><code>AddTo</code>：绑定事件</p></li><li><p><code>Do</code>：前置事件</p></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例用于演示Subscribe操作符的用法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">    <span class="comment">//Do会在Subscribe前执行前置事件，是最普通的事件委托</span></span><br><span class="line">    .Do(_ =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    print(<span class="string">&quot;Do&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//Subscribe方法里最多配置三个事件：</span></span><br><span class="line">    <span class="comment">//-onNext执行事件，单纯地执行委托的方法而已</span></span><br><span class="line">    <span class="comment">//-OnComplete结束事件，可能需要告诉编译器什么时候观察结束，当执行OnComplete后会自动释放</span></span><br><span class="line">    <span class="comment">//-OnError异常事件，仅当前置条件或执行方法里出错时会调用，当执行OnError后会自动释放</span></span><br><span class="line">    .Subscribe(</span><br><span class="line">        onNext: u =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">        print(<span class="string">$&quot;OnNext <span class="subst">&#123;u&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        onCompleted: () =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">        print(<span class="string">$&quot;OnComplete&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        onError: exc =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">        print(<span class="string">$&quot;OnError <span class="subst">&#123;exc&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="comment">//AddTo将释放器绑定在this本地类上</span></span><br><span class="line">    <span class="comment">//当绑定类销毁时，调用绑定类的OnDestroy()函数，释放器会自动在此释放。</span></span><br><span class="line">    .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="伍：流程类操作符（常用）"><a href="#伍：流程类操作符（常用）" class="headerlink" title="伍：流程类操作符（常用）"></a>伍：流程类操作符（常用）</h3><ul><li><code>Where</code>：条件判断</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        <span class="comment">//Where操作符：当……时执行，这里是当鼠标左键按下时执行</span></span><br><span class="line">.Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        <span class="comment">//Where操作符里的委托方法必须返回一个布尔值来截流余下操作</span></span><br><span class="line">        .Where(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Input.GetMouseButtonDown(<span class="number">0</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">.Subscribe(_ =&gt;</span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">&quot;TODO&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>OfType</code>：类型判断</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//新建一个主体类，专门接收object类型物体</span></span><br><span class="line">    Subject&lt;<span class="built_in">object</span>&gt; SUB_UNIT = <span class="keyword">new</span> Subject&lt;<span class="built_in">object</span>&gt;();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SUB_UNIT</span><br><span class="line">        <span class="comment">//int类型属于或继承于object，所以可以使用OfType来过滤</span></span><br><span class="line">.OfType&lt;<span class="built_in">object</span>, <span class="built_in">int</span>&gt;()</span><br><span class="line">.Subscribe(i =&gt;</span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">$&quot;Number <span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    <span class="comment">//主体类调用</span></span><br><span class="line">SUB_UNIT.OnNext(<span class="number">10</span>);</span><br><span class="line">SUB_UNIT.OnNext(<span class="string">&quot;20&quot;</span>);</span><br><span class="line">SUB_UNIT.OnCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Distinct</code>：当与之前输出不同时才输出</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; lst_Int = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="comment">//将数列转化为数据流</span></span><br><span class="line">lst_Int.ToObservable()</span><br><span class="line">.Distinct()</span><br><span class="line">.Subscribe(i =&gt;</span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">$&quot;List <span class="subst">&#123;i&#125;</span>&quot;</span>);<span class="comment">//输出1,3,5</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>DistinctUntilChanged</code>：当与前一个输出不同时才输出</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; lst_Int = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">//将数列转化为数据流</span></span><br><span class="line">lst_Int.ToObservable()</span><br><span class="line">.DistinctUntilChanged()</span><br><span class="line">.Subscribe(i =&gt;</span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">$&quot;List <span class="subst">&#123;i&#125;</span>&quot;</span>);<span class="comment">//输出1,3,1,2</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>StartWith</code>：将信息放置在输出之前来执行</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; lst_Int = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">//将数列转化为数据流</span></span><br><span class="line">    lst_Int.ToObservable()</span><br><span class="line">.StartWith(<span class="number">0</span>)</span><br><span class="line">.Subscribe(i =&gt;</span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">$&quot;List <span class="subst">&#123;i&#125;</span>&quot;</span>);<span class="comment">//输出0,1,2,3,4,5</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//每一帧的数据流</span></span><br><span class="line">Observable.EveryUpdate()</span><br><span class="line">.Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        <span class="comment">//无论如何，Startwith永远在第一帧时输出</span></span><br><span class="line">.StartWith(<span class="number">0</span>)</span><br><span class="line">.Subscribe(l =&gt;</span><br><span class="line">&#123;</span><br><span class="line">print(l.ToString());</span><br><span class="line">&#125;)</span><br><span class="line">.AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="陆：断点类操作符（常用）"><a href="#陆：断点类操作符（常用）" class="headerlink" title="陆：断点类操作符（常用）"></a>陆：断点类操作符（常用）</h3><ul><li><code>First</code>：当第一次触发时输出</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">.Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">    <span class="comment">//仅会在第一次执行时输出</span></span><br><span class="line">.First()</span><br><span class="line">.Subscribe(_ =&gt;</span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">&quot;First&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Last</code>：当最后一次触发时输出（需要使用其他语句来告诉程序何时为最后一次输出）</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; lst_Int = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">lst_Int.ToObservable()</span><br><span class="line">        <span class="comment">//仅会在最后一次执行时输出</span></span><br><span class="line">.Last()</span><br><span class="line">.Subscribe(i =&gt;</span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">$&quot;Last <span class="subst">&#123;i&#125;</span>&quot;</span>);<span class="comment">//输出5</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Take</code>：输出次数限制（<code>TakeWhile</code> <code>TakeUntil</code>）</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        <span class="comment">//最多会输出5次</span></span><br><span class="line">        .Take(<span class="number">5</span>)</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">        print(<span class="string">&quot;Take&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        <span class="comment">//当是条件时执行，如果触发否条件，则余下都不执行</span></span><br><span class="line">        .TakeWhile(_ =&gt; !Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;TakeWhile&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        <span class="comment">//当某观察器否条件时执行，如果触发是条件，则余下都不执行</span></span><br><span class="line">        .TakeUntil(</span><br><span class="line">            Observable.EveryUpdate()</span><br><span class="line">            .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        )</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;TakeUntil&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Skip</code>：输出次数忽略（<code>SkipWhile</code> <code>SkipUntil</code>）</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        <span class="comment">//从触发第5次后才开始输出</span></span><br><span class="line">        .Skip(<span class="number">5</span>)</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;Skip&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        <span class="comment">//当是条件时不执行，如果触发否条件，则余下都执行</span></span><br><span class="line">        .SkipWhile(_ =&gt; !Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;SkipWhile&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">       <span class="comment">//当某观察器否条件时不执行，如果触发是条件，则余下都执行</span></span><br><span class="line">       .SkipUntil(</span><br><span class="line">            Observable.EveryUpdate()</span><br><span class="line">            .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        )</span><br><span class="line">       .Subscribe(_ =&gt;</span><br><span class="line">       &#123;</span><br><span class="line">           print(<span class="string">&quot;SkipUntil&quot;</span>);</span><br><span class="line">       &#125;)</span><br><span class="line">       .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="柒：延时类操作符（常用）"><a href="#柒：延时类操作符（常用）" class="headerlink" title="柒：延时类操作符（常用）"></a>柒：延时类操作符（常用）</h3><ul><li><code>Delay</code>：延时（<code>DelayFrame</code>）</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        <span class="comment">//需要等2秒钟才能输出</span></span><br><span class="line">        .Delay(System.TimeSpan.FromSeconds(<span class="number">2</span>))</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;Delay&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        <span class="comment">//需要等60帧才能输出</span></span><br><span class="line">        .DelayFrame(<span class="number">60</span>)</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;Delay&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>NextFrame[观察器]</code>：等待下一帧</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(Time.frameCount);</span><br><span class="line">            <span class="comment">//NextFrame其实会等到下下帧</span></span><br><span class="line">            Observable.NextFrame()</span><br><span class="line">                .Subscribe(_ =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    print(Time.frameCount);</span><br><span class="line">                &#125;)</span><br><span class="line">                .AddTo(<span class="keyword">this</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Timer[观察器]</code>：计时器</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//从此时开始计时器来生成观察器</span></span><br><span class="line">    Observable.Timer(TimeSpan.FromSeconds(<span class="number">1</span>))</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;Timer&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Interval[观察器]</code>：循环计时器</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//从此时开始计时器循环来生成观察器</span></span><br><span class="line">Observable.Interval(TimeSpan.FromSeconds(<span class="number">1</span>))</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;Interval&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>TimeInterval</code>：获取触发时间间隔</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        <span class="comment">//获取相邻两次触发之间的间隔</span></span><br><span class="line">        .TimeInterval()</span><br><span class="line">        .Subscribe(t =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">$&quot;与上一次触发的时间差 <span class="subst">&#123;t.Interval.TotalSeconds&#125;</span>&quot;</span>);</span><br><span class="line">            print(<span class="string">$&quot;整体时间帧数 <span class="subst">&#123;t.Value&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="捌：采样类操作符（常用）"><a href="#捌：采样类操作符（常用）" class="headerlink" title="捌：采样类操作符（常用）"></a>捌：采样类操作符（常用）</h3><ul><li><code>Sample</code>：输出采样</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        <span class="comment">//设置采样时间，集中从某一段时间的执行中抽取一次来执行</span></span><br><span class="line">        <span class="comment">//如果在这么一段时间内没有触发，也就没有采样输出</span></span><br><span class="line">.Sample(TimeSpan.FromSeconds(<span class="number">1</span>))</span><br><span class="line">.Subscribe(_ =&gt;</span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">&quot;Sample&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Buffer</code>：输出缓存</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        <span class="comment">//请求缓存，会将固定时间内的执行放到缓存数组中，到计时器的周期时执行并返回</span></span><br><span class="line">        .Buffer(TimeSpan.FromSeconds(<span class="number">2.0f</span>))</span><br><span class="line">        .Subscribe(lstLong =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//每两秒钟都会执行，但返回的lstLong数组内不一定有值</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">long</span> time <span class="keyword">in</span> lstLong)</span><br><span class="line">            &#123;</span><br><span class="line">                print(<span class="string">$&quot;Buffer<span class="subst">&#123;time&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Throttle</code>：结束连续性计时判断</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        <span class="comment">//连续性判断，设置几秒内为连续</span></span><br><span class="line">        <span class="comment">//当超过秒数后没有再次触发时才执行</span></span><br><span class="line">        .Throttle(TimeSpan.FromSeconds(<span class="number">0.5f</span>))</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;Trottle&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ThrottleFirst</code>：开始连续性计时判断</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        <span class="comment">//连续性判断，设置几秒内为连续</span></span><br><span class="line">        <span class="comment">//当触发时执行并开启计时器，计时器内再次触发不会执行，直到计时完毕</span></span><br><span class="line">        .ThrottleFirst(TimeSpan.FromSeconds(<span class="number">0.5f</span>))</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;TrottleFirst&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Zip[观察器]</code>：打包等待</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> obs1 = Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>));<span class="comment">//按下鼠标左键时触发</span></span><br><span class="line">    <span class="keyword">var</span> obs2 = Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">1</span>));<span class="comment">//按下鼠标右键时触发</span></span><br><span class="line">    <span class="comment">//Zip操作符会打包两个观察器</span></span><br><span class="line">    <span class="comment">//当观察器A输出第N次时，需要等待到观察器B输出第N次才能输出</span></span><br><span class="line">    obs1.Zip(obs2, (l, r) =&gt; Unit.Default)</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;Zip&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Timeout</code>：输出间隔超时判断</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        <span class="comment">//当超过时间没有输出时，会向观察者传递一个onError事件</span></span><br><span class="line">        .Timeout(System.TimeSpan.FromSeconds(<span class="number">5.0f</span>))</span><br><span class="line">        .Subscribe(</span><br><span class="line">            onNext: _ =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                print(<span class="string">&quot;TimeOut&quot;</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            onError: _ =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                print(<span class="string">&quot;TimeOutEXC&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="玖：异常类操作符（常用）"><a href="#玖：异常类操作符（常用）" class="headerlink" title="玖：异常类操作符（常用）"></a>玖：异常类操作符（常用）</h3><ul><li><code>Catch</code>：捕获异常</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        .Timeout(System.TimeSpan.FromSeconds(<span class="number">5.0f</span>))</span><br><span class="line">        <span class="comment">//Catch会尝试去捕捉异常，需要返回一个空的观察器</span></span><br><span class="line">        .Catch&lt;<span class="built_in">long</span>, Exception&gt;(exc =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;Catch&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Observable.Empty&lt;<span class="built_in">long</span>&gt;();</span><br><span class="line">        &#125;)</span><br><span class="line">        .Subscribe()</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>OnErrorRetry</code>：当异常出现时执行，然后终止余下操作</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        .Timeout(System.TimeSpan.FromSeconds(<span class="number">2.0f</span>))</span><br><span class="line">        <span class="comment">//当错误被捕捉时，会先进入OnErrorRetry，然后终止余下操作</span></span><br><span class="line">        .OnErrorRetry((Exception ex) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;OnErrorRetry&quot;</span>);<span class="comment">//在无鼠标输入后第2秒钟时输出</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .Subscribe()</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Retry</code>：当异常出现时跳过，继续余下操作</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        .Timeout(System.TimeSpan.FromSeconds(<span class="number">2.0f</span>))</span><br><span class="line">        <span class="comment">//Retry会在错误发生后跳过错误，继续余下操作，传参指能容忍到第几个错误</span></span><br><span class="line">        .Retry(<span class="number">3</span>)</span><br><span class="line">        .OnErrorRetry((Exception ex) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">&quot;OnErrorRetry&quot;</span>);<span class="comment">//在无鼠标输入后第6秒钟时输出</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .Subscribe()</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拾：工具类操作符（常用）"><a href="#拾：工具类操作符（常用）" class="headerlink" title="拾：工具类操作符（常用）"></a>拾：工具类操作符（常用）</h3><ul><li><code>Merge</code>：合并观察器</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Subject&lt;<span class="built_in">long</span>&gt; Sub_Long = <span class="keyword">new</span> Subject&lt;<span class="built_in">long</span>&gt;();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="keyword">var</span> obs1 = Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>));<span class="comment">//按下鼠标左键时触发</span></span><br><span class="line">    <span class="keyword">var</span> obs2 = Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">1</span>));<span class="comment">//按下鼠标右键时触发</span></span><br><span class="line"><span class="comment">//使用Merge能够将施者与被施者绑定，返回绑定后的观察器，Merge里能接数个观察器</span></span><br><span class="line">    Sub_Long.Merge(obs1, obs2)</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;Merge&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Amb</code>：执行优先观察器</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> obs1 = Observable.EveryUpdate()</span><br><span class="line">            .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>));<span class="comment">//按下鼠标左键时触发</span></span><br><span class="line">    <span class="keyword">var</span> obs2 = Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">1</span>));<span class="comment">//按下鼠标右键时触发</span></span><br><span class="line">    <span class="comment">//使用Amb可以绑定多个观察器</span></span><br><span class="line">    <span class="comment">//当其中第一个观察器触发后，取消其余的观察器，之后只运行这一个</span></span><br><span class="line">    Observable.Amb(obs1, obs2)</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;Amb&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Aggregate</code>：迭代器，在迭代完成后输出</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; lst_Int1 = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    lst_Int1.ToObservable()</span><br><span class="line">        <span class="comment">//将历史迭代数据与当前数据作为参数，返回迭代后的数据</span></span><br><span class="line">        .Aggregate((iteration, current) =&gt; iteration * current)</span><br><span class="line">        .Subscribe(val =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">$&quot;Aggregate <span class="subst">&#123;val&#125;</span>&quot;</span>);<span class="comment">//((((1*2)*3)*4)*5)=120</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Scan</code>：迭代器，当每次迭代后输出</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; lst_Int = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    lst_Int.ToObservable()</span><br><span class="line">        <span class="comment">//将历史迭代数据与当前数据作为参数，返回迭代后的数据</span></span><br><span class="line">        .Scan((iteration, current) =&gt; iteration * current)</span><br><span class="line">        .Subscribe(val =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">$&quot;Scan <span class="subst">&#123;val&#125;</span>&quot;</span>);<span class="comment">//1, 2, 6, 24, 120</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Range[观察器]</code>：将某范围内的数作为输出来触发</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置初始值-2与长度5，返回[-2, -1, 0, 1, 2]五个数</span></span><br><span class="line">    Observable.Range(<span class="number">-2</span>, <span class="number">5</span>)</span><br><span class="line">        .Scan((iteration, current) =&gt; iteration + current)</span><br><span class="line">        .Subscribe(val =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">$&quot;Scan <span class="subst">&#123;val&#125;</span>&quot;</span>);<span class="comment">//-2, -3, -3, -2, 0</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Repeat</code>：重复执行输入</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Repeat将某个物体循环输入N次</span></span><br><span class="line">    Observable.Repeat(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">        .Scan((iteration, current) =&gt; iteration * current)</span><br><span class="line">        .Subscribe(val =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">$&quot;Repeat <span class="subst">&#123;val&#125;</span>&quot;</span>);<span class="comment">//10, 100, 1000, 10000, 100000</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Concat</code>：观察器前后相搭</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; lst_Int1 = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; lst_Int2 = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    lst_Int1.ToObservable()</span><br><span class="line">        <span class="comment">//Concat将被施方绑定在施方之后</span></span><br><span class="line">        .Concat(lst_Int2.ToObservable())</span><br><span class="line">        .Subscribe(val =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">$&quot;Concat <span class="subst">&#123;val&#125;</span>&quot;</span>);<span class="comment">//1,2,3,4,5,6,7,8,9,0</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>SelectMany</code>：观察器置换器</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> mouseStream = Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">var</span> listStream = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;.ToObservable();</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//每当mouseStream触发时，listStream里的所有元素都会触发一次</span></span><br><span class="line">    <span class="comment">//将listStream里的当前元素返回</span></span><br><span class="line">    Observable.SelectMany(mouseStream, listStream)</span><br><span class="line">        .Subscribe(i =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">$&quot;SelectMany <span class="subst">&#123;i&#125;</span>&quot;</span>);<span class="comment">//1, 2, 3, 4, 5</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>WhenAll</code>：当所有触发满足条件时，在结束时触发</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    IObservable&lt;<span class="built_in">long</span>&gt; obs1 = Observable.Timer(System.TimeSpan.FromSeconds(<span class="number">1</span>));</span><br><span class="line">    IObservable&lt;<span class="built_in">long</span>&gt; obs2 = Observable.Timer(System.TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Observable.WhenAll(obs1, obs2)</span><br><span class="line">        .Delay(System.TimeSpan.FromSeconds(<span class="number">1</span>))</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;WhenAll&quot;</span>);<span class="comment">//等待3s后输出</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拾壹：UniRX与消息机制"><a href="#拾壹：UniRX与消息机制" class="headerlink" title="拾壹：UniRX与消息机制"></a>拾壹：UniRX与消息机制</h3><ul><li>UniRX的消息机名为<code>MessageBroker</code>，使用也是比较简单的。</li><li>更为方便的是，消息接收者不需要知道消息发送者是谁。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()<span class="comment">//这是Unity某个继承自MonoBehaviour的类的启动方法</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//消息发送</span></span><br><span class="line">    Observable.EveryUpdate()</span><br><span class="line">        .Where(_ =&gt; Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        .Subscribe(_ =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBroker.Default.Publish(<span class="string">&quot;Hello&quot;</span>);<span class="comment">//发送字符串消息Hello</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//消息接收</span></span><br><span class="line">    MessageBroker.Default.Receive&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">        .SubscribeOnMainThread()<span class="comment">//在主线程中接收</span></span><br><span class="line">        .Where(message =&gt; message == <span class="string">&quot;Hello&quot;</span>)<span class="comment">//截流字符串消息Hello</span></span><br><span class="line">        .Subscribe(message =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">$&quot;MessageBroker&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddTo(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拾贰：自定义操作符模版"><a href="#拾贰：自定义操作符模版" class="headerlink" title="拾贰：自定义操作符模版"></a>拾贰：自定义操作符模版</h3><ul><li>暂且记录以下实现的一个小功能：检测是否在编辑器环境的暂停状态，如果不在编辑器内，则直接通过</li><li>因为大量的UniRX的观察器都不依赖Unity的编辑器状态，致使在编辑器暂停时也能继续运行</li><li>这个问题会导致不方便测试，所以自制了一个操作符<code>EditorDebug</code>来规避这个情况</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个非泛型静态类，专门用来存放扩展方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">My_UniRX_Extension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这个方法属于是Where的标准模版了，用法也跟Where一模一样</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IObservable</span>&lt;<span class="title">T</span>&gt; <span class="title">CustomOperator</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> IObservable&lt;T&gt; source, Func&lt;T, <span class="built_in">bool</span>&gt; conditionalFunc</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CustomObservable&lt;T&gt;(source, conditionalFunc);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个方法里使用了Unity的宏，规范了返回值在编辑器内与编辑器外的变化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IObservable</span>&lt;<span class="title">T</span>&gt; <span class="title">EditorDebug</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> IObservable&lt;T&gt; source</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CustomObservable&lt;T&gt;(source,</span><br><span class="line">_ =&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line"><span class="keyword">return</span> !UnityEditor.EditorApplication.isPaused;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为特地设置的自定义返回观察器，是直接复制改名了Where操作符的定义</span></span><br><span class="line"><span class="comment">//为什么不能使用UniRX现有的类型来返回哪，还不是因为那些值都是内部标识的，不然早用了</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UniRx.Operators</span><span class="comment">//为UniRX命名空间进行扩展</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自定义链的观察器构建</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">CustomObservable</span>&lt;<span class="title">T</span>&gt; : <span class="title">OperatorObservableBase</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">readonly</span> IObservable&lt;T&gt; source;</span><br><span class="line">        <span class="keyword">readonly</span> Func&lt;T, <span class="built_in">bool</span>&gt; predicate;</span><br><span class="line">        <span class="keyword">readonly</span> Func&lt;T, <span class="built_in">int</span>, <span class="built_in">bool</span>&gt; predicateWithIndex;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomObservable</span>(<span class="params">IObservable&lt;T&gt; source, Func&lt;T, <span class="built_in">bool</span>&gt; predicate</span>)</span></span><br><span class="line"><span class="function">            : <span class="title">base</span>(<span class="params">source.IsRequiredSubscribeOnCurrentThread(</span>))</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.source = source;</span><br><span class="line">            <span class="keyword">this</span>.predicate = predicate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomObservable</span>(<span class="params">IObservable&lt;T&gt; source, Func&lt;T, <span class="built_in">int</span>, <span class="built_in">bool</span>&gt; predicateWithIndex</span>)</span></span><br><span class="line"><span class="function">            : <span class="title">base</span>(<span class="params">source.IsRequiredSubscribeOnCurrentThread(</span>))</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.source = source;</span><br><span class="line">            <span class="keyword">this</span>.predicateWithIndex = predicateWithIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> IDisposable <span class="title">SubscribeCore</span>(<span class="params">IObserver&lt;T&gt; observer, IDisposable cancel</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> source.Subscribe(<span class="keyword">new</span> Custom(<span class="keyword">this</span>, observer, cancel));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> source.Subscribe(<span class="keyword">new</span> Custom_(<span class="keyword">this</span>, observer, cancel));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义链的观察者构建</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title">Custom</span> : <span class="title">OperatorObserverBase</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">readonly</span> CustomObservable&lt;T&gt; parent;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Custom</span>(<span class="params">CustomObservable&lt;T&gt; parent, IObserver&lt;T&gt; observer, IDisposable cancel</span>)</span></span><br><span class="line"><span class="function">                : <span class="title">base</span>(<span class="params">observer, cancel</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.parent = parent;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnNext</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> isPassed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    isPassed = parent.predicate(<span class="keyword">value</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123; observer.OnError(ex); &#125; <span class="keyword">finally</span> &#123; Dispose(); &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isPassed)</span><br><span class="line">                &#123;</span><br><span class="line">                    observer.OnNext(<span class="keyword">value</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnError</span>(<span class="params">Exception error</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; observer.OnError(error); &#125; <span class="keyword">finally</span> &#123; Dispose(); &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCompleted</span>()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; observer.OnCompleted(); &#125; <span class="keyword">finally</span> &#123; Dispose(); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title">Custom_</span> : <span class="title">OperatorObserverBase</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">readonly</span> CustomObservable&lt;T&gt; parent;</span><br><span class="line">            <span class="built_in">int</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Custom_</span>(<span class="params">CustomObservable&lt;T&gt; parent, IObserver&lt;T&gt; observer, IDisposable cancel</span>)</span></span><br><span class="line"><span class="function">                : <span class="title">base</span>(<span class="params">observer, cancel</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.parent = parent;</span><br><span class="line">                <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnNext</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> isPassed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    isPassed = parent.predicateWithIndex(<span class="keyword">value</span>, index++);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123; observer.OnError(ex); &#125; <span class="keyword">finally</span> &#123; Dispose(); &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isPassed)</span><br><span class="line">                &#123;</span><br><span class="line">                    observer.OnNext(<span class="keyword">value</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnError</span>(<span class="params">Exception error</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; observer.OnError(error); &#125; <span class="keyword">finally</span> &#123; Dispose(); &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCompleted</span>()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; observer.OnCompleted(); &#125; <span class="keyword">finally</span> &#123; Dispose(); &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链式编程与UniRX的基础使用&quot;&gt;&lt;a href=&quot;#链式编程与UniRX的基础使用&quot; class=&quot;headerlink&quot; title=&quot;链式编程与UniRX的基础使用&quot;&gt;&lt;/a&gt;链式编程与UniRX的基础使用&lt;/h1&gt;&lt;h1 id=&quot;第一部分：链式编程&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="unity" scheme="http://iamsleepingnow.github.io/categories/unity/"/>
    
    
    <category term="unity" scheme="http://iamsleepingnow.github.io/tags/unity/"/>
    
    <category term="ReactiveX" scheme="http://iamsleepingnow.github.io/tags/ReactiveX/"/>
    
  </entry>
  
  <entry>
    <title>Unity中使碰撞检测的碰撞箱处于不同层级的方法</title>
    <link href="http://iamsleepingnow.github.io/2022/07/08/Unity/Unity%E4%B8%AD%E8%AE%A9%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E7%A2%B0%E6%92%9E%E7%AE%B1%E5%A4%84%E4%BA%8E%E4%B8%8D%E5%90%8C%E5%B1%82%E7%BA%A7%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://iamsleepingnow.github.io/2022/07/08/Unity/Unity%E4%B8%AD%E8%AE%A9%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E7%A2%B0%E6%92%9E%E7%AE%B1%E5%A4%84%E4%BA%8E%E4%B8%8D%E5%90%8C%E5%B1%82%E7%BA%A7%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2022-07-08T05:42:25.000Z</published>
    <updated>2023-04-22T09:23:57.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity中使碰撞检测的碰撞箱处于不同层级的方法"><a href="#Unity中使碰撞检测的碰撞箱处于不同层级的方法" class="headerlink" title="Unity中使碰撞检测的碰撞箱处于不同层级的方法"></a>Unity中使碰撞检测的碰撞箱处于不同层级的方法</h1><ul><li>Unity在做碰撞检测时，Mono基类的碰撞与触发检测函数诸如OnCollisionEnter()之类必须得获取到与其代码附着地同层级的碰撞箱才能进行检测，当碰撞箱单独拎出来时，代码就不会工作了。</li><li>我被这狗屎问题困扰了多年，今天终于有了解决方案。</li><li>当然这个方法只是解决此问题的众多方法之一，成熟点的方法也许会用到接口与委托，这里我就使用我的方法。</li></ul><h2 id="（甲）物理碰撞的条件"><a href="#（甲）物理碰撞的条件" class="headerlink" title="（甲）物理碰撞的条件"></a>（甲）物理碰撞的条件</h2><ul><li>达成物理碰撞有如下的条件：<ul><li>碰撞物体双方都拥有碰撞箱（Collider抽象类及其子类）</li><li>碰撞物体至少有一方拥有刚体（Rigidbody类）</li></ul></li></ul><h2 id="（乙）碰撞及触发检测方法"><a href="#（乙）碰撞及触发检测方法" class="headerlink" title="（乙）碰撞及触发检测方法"></a>（乙）碰撞及触发检测方法</h2><ul><li>基础的碰撞检测方法如下：<ul><li>private void OnCollisionEnter(Collision collision)</li><li>private void OnCollisionStay(Collision collision)</li><li>private void OnCollisionExit(Collision collision)</li></ul></li><li>基础的触发检测方法如下：<ul><li>private void OnTriggerEnter(Collider other)</li><li>private void OnTriggerStay(Collider other)</li><li>private void OnTriggerExit(Collider other)</li></ul></li></ul><h2 id="（丙）使用代理碰撞器"><a href="#（丙）使用代理碰撞器" class="headerlink" title="（丙）使用代理碰撞器"></a>（丙）使用代理碰撞器</h2><ul><li>首先需要一个基类，负责管理所有的碰撞事件，在此命名为<code>ObjectManager</code></li></ul><img src="https://s2.loli.net/2023/04/19/X3fyj9YkGMpPsuF.png" width=400><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ObjectManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>再创建一个代理碰撞器类，代理碰撞器会代替基类去碰撞，在此命名为<code>CollisionProxy</code></li></ul><img src="https://s2.loli.net/2023/04/19/iBJRtQMLmO29Wc8.png" width=400><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CollisionProxy</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在代理器中加入需要代理的检测方法，注意代理器与基类都需要继承自<code>MonoBehaviour</code></li></ul><img src="https://s2.loli.net/2023/04/19/yuOxfmar8YPdsje.png" width=550><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ObjectManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//Mono基类的碰撞或触发检测方法，这里是碰撞器进入方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Mono基类的碰撞或触发检测方法，这里是触发器进入方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代理器中还需要获取代理的基类以及自身的代理序号</li></ul><img src="https://s2.loli.net/2023/04/19/FV4XpBL1sOETkmq.png" width=550><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ObjectManager objectManager;<span class="comment">//代理器所代理的基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> proxyIndex = <span class="number">0</span>;<span class="comment">//此代理器的代理序号</span></span><br></pre></td></tr></table></figure><ul><li>在基类里定义与代理器中相对应的代理方法，需要在参数中传递碰撞信息与代理器自身</li><li>代理方法需要用<code>virtual</code>设置为虚拟方法，这样子类就能够用<code>override</code>重写</li></ul><img src="https://s2.loli.net/2023/04/19/YU3qzK5eVw79l6r.png" width=750><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ObjectManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//代理碰撞器进入方法（虚拟）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCollisionEnterProxy</span>(<span class="params">Collision collision, CollisionProxy proxy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代理触发器进入方法（虚拟）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnTriggerEnterProxy</span>(<span class="params">Collider other, CollisionProxy proxy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>加入用来调用测试的行</li></ul><img src="https://s2.loli.net/2023/04/19/GxnMLFBjeuazPOW.png" width=750><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ObjectManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//代理碰撞器进入方法（虚拟）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnCollisionEnterProxy</span>(<span class="params">Collision collision, CollisionProxy proxy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">$&quot;Manager的代理<span class="subst">&#123;proxy.name&#125;</span>序号为<span class="subst">&#123;proxy.proxyIndex&#125;</span>，碰撞了物体<span class="subst">&#123;collision.collider.name&#125;</span>。&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (proxy.proxyIndex == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;检测到了3号碰撞器&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代理触发器进入方法（虚拟）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnTriggerEnterProxy</span>(<span class="params">Collider other, CollisionProxy proxy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">$&quot;Manager的代理<span class="subst">&#123;proxy.name&#125;</span>序号为<span class="subst">&#123;proxy.proxyIndex&#125;</span>，触发了物体<span class="subst">&#123;other.name&#125;</span>。&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (proxy.proxyIndex == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;检测到了3号碰撞器&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在代理器中调用此基类的代理方法，将信息传入</li></ul><img src="https://s2.loli.net/2023/04/19/DkyLmE7nNtopbF6.png" width=550><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CollisionProxy</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ObjectManager objectManager;<span class="comment">//代理器所代理的基类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> proxyIndex = <span class="number">0</span>;<span class="comment">//此代理器的代理序号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Mono基类的碰撞或触发检测方法，这里是碰撞器进入方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCollisionEnter</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用所代理的基类的方法</span></span><br><span class="line">        objectManager.OnCollisionEnterProxy(collision, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Mono基类的碰撞或触发检测方法，这里是触发器进入方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用所代理的基类的方法</span></span><br><span class="line">        objectManager.OnTriggerEnterProxy(other, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>回到Unity里，创建一个球，携带碰撞箱，在其身上加上刚体，勾去使用重力，勾选<code>Is Kinematic</code>，这个球就是需要被检测的对象</li><li>再新建一个方体，把碰撞箱移除，附上<code>ObjectManager</code>基类</li><li>在方体的子级里添加三个空物体，附上碰撞箱组件（这里是<code>Sphere Collider</code>），再附上<code>CollisionProxy</code>代理器组件，将父级赋给代理器组件中的<code>objectManager</code>参数，更改每一个代理器中的<code>proxyIndex</code>序号</li><li>这里为了测试触发器，将代理器中的碰撞箱的<code>Is Trigger</code>勾上了</li></ul><img src="https://s2.loli.net/2023/04/19/fKd85BDtaWxbzCM.png" width=250><img src="https://s2.loli.net/2023/04/19/bvA1xfEmO29IS5z.png" width=350><img src="https://s2.loli.net/2023/04/20/E4A6JijhbMlCKdZ.png" width=350><ul><li>这时运行工程，手动移动方体的位置，使得子级代理器的碰撞箱触发球体</li></ul><img src="https://s2.loli.net/2023/04/20/9uYnPxg3cDpS6VL.png" width=450><ul><li>测试成功，基类获取到了触发信息（包括触发的物体、代理器序号的信息）</li><li>为了使得此方法变得更好用，这里定义一个新脚本来继承<code>ObjectManager</code>基类，在此命名为<code>ObjectManagerSon</code></li><li>因为面向对象的多态特性，代理器组件所调用的基类函数会下达到其子类的重写函数，所以只需要在<code>ObjectManagerSon</code>中，重写代理碰撞方法，稍微对测试行进行修改</li></ul><img src="https://s2.loli.net/2023/04/20/8VoxshI1EKzfu2J.png" width=750><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ObjectManagerSon</span> : <span class="title">ObjectManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//代理碰撞器进入方法（重写）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCollisionEnterProxy</span>(<span class="params">Collision collision, CollisionProxy proxy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">$&quot;ManagerSon的代理<span class="subst">&#123;proxy.name&#125;</span>序号为<span class="subst">&#123;proxy.proxyIndex&#125;</span>，碰撞了物体<span class="subst">&#123;collision.collider.name&#125;</span>。&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (proxy.proxyIndex == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;检测到了3号碰撞器，而且此管理器为ObjectManager的子类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代理触发器进入方法（重写）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnTriggerEnterProxy</span>(<span class="params">Collider other, CollisionProxy proxy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">$&quot;ManagerSon的代理<span class="subst">&#123;proxy.name&#125;</span>序号为<span class="subst">&#123;proxy.proxyIndex&#125;</span>，触发了物体<span class="subst">&#123;other.name&#125;</span>。&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (proxy.proxyIndex == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print(<span class="string">&quot;检测到了3号碰撞器，而且此管理器为ObjectManager的子类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将场景中方体身上的<code>ObjectManager</code>替换为子类<code>ObjectManagerSon</code>，并赋给三个代理器的<code>objectManager</code>参数</li></ul><img src="https://s2.loli.net/2023/04/20/7xJZOTiyIVCAvwz.png" width=450><ul><li>成功</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity中使碰撞检测的碰撞箱处于不同层级的方法&quot;&gt;&lt;a href=&quot;#Unity中使碰撞检测的碰撞箱处于不同层级的方法&quot; class=&quot;headerlink&quot; title=&quot;Unity中使碰撞检测的碰撞箱处于不同层级的方法&quot;&gt;&lt;/a&gt;Unity中使碰撞检测的碰撞</summary>
      
    
    
    
    <category term="unity" scheme="http://iamsleepingnow.github.io/categories/unity/"/>
    
    
    <category term="unity" scheme="http://iamsleepingnow.github.io/tags/unity/"/>
    
    <category term="特性" scheme="http://iamsleepingnow.github.io/tags/%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Articy Draft 3 与 Unity</title>
    <link href="http://iamsleepingnow.github.io/2022/05/05/ArticyDraft/Articy%20Draft%203%20%E4%B8%8E%20Unity/"/>
    <id>http://iamsleepingnow.github.io/2022/05/05/ArticyDraft/Articy%20Draft%203%20%E4%B8%8E%20Unity/</id>
    <published>2022-05-05T09:46:30.000Z</published>
    <updated>2023-04-22T17:43:22.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Articy-Draft-3-与-Unity"><a href="#Articy-Draft-3-与-Unity" class="headerlink" title="Articy Draft 3 与 Unity"></a>Articy Draft 3 与 Unity</h1><ul><li><code>Articy Draft 3</code> 是Steam上的一个做叙事游戏数值剧情策划的软件，为了去结合Unity或是Unreal，可以作为一个独立的第三方软件(不是插件)使用。最近出了免费试用版，但是有一定的容量限制(660个游戏物体或对话)，但是能够符合一个基本的小型游戏或弱叙事游戏使用了。</li></ul><img src="https://s2.loli.net/2023/04/23/sEZ7jLdmUgJzKMh.png"  width="400"><ul><li>鉴于属于一个比较方便的文字建模软件，于是我就其官网上的生肉以及实践做出了以下学习笔记。</li><li>这个笔记只涉及一些文字游戏的基础功能，像高级功能诸如地点和旅程就不涉及了。</li><li>当然，还有B站好心人<a href="https://www.bilibili.com/video/BV15J41157Jf">搬运的视频</a>，AD的基础使用按键操作什么的就不讲了，看视频就能明白。</li></ul><h3 id="翻译中比较让人困惑的地方："><a href="#翻译中比较让人困惑的地方：" class="headerlink" title="**翻译中比较让人困惑的地方："></a>**翻译中比较让人困惑的地方：</h3><ul><li>在软件中有一堆以“复数”为开头的中文翻译，例如：“复数资源”，实际上指的是资源单词的复数形式：”Assets”，请自动省略掉”复数”两字。</li><li>软件中把Location翻译成了地点，实际上Spot才是地点，但是Spot被翻译成了“斑点”，这也是翻译错误。</li></ul><h2 id="（甲）主要世界观"><a href="#（甲）主要世界观" class="headerlink" title="（甲）主要世界观"></a>（甲）主要世界观</h2><ul><li>属性(Property)：<ul><li>属性是代码层面上的最基础的单位，基本对应的是对于数值类型的定义：布尔值、基础数值。</li></ul></li></ul><img src="https://s2.loli.net/2023/04/23/2Tphf5AZyDWdwkY.png"  width="300"><ul><li>特性(Feature)：<ul><li>特性是由许多属性构成的结构体，比方说玩家和npc们都有基础特性：血量、攻击力、敏捷，而玩家可能在此基础上还拥有只属于玩家的玩家特性：经验、背包容量等。</li></ul></li></ul><img src="https://s2.loli.net/2023/04/23/OsIP16WdSkf7HQa.png"  width="300"><ul><li>模板(Template)：<ul><li>每一个流程中的节点、每一个工程里的资源文件，都可以使用其规定类型的自定义模板。模板是由许多特性构成的集合，比如玩家PC的模板与电脑NPC的模板中特性的分布不同。</li></ul></li></ul><img src="https://s2.loli.net/2023/04/23/PtIkyxegdOMK9Uf.png"  width="300"><ul><li>实体(Entity)：<ul><li>实体可以类比Unity中的GameObject，Unreal里的Actor，每个实体能使用一个模板。人物可以是实体，道具可以是实体，一些抽象的命令也可以是实体。</li></ul></li></ul><img src="https://s2.loli.net/2023/04/23/sewQ5cUxMXZHm8y.png"  width="300"><ul><li>流程(Flow)：<ul><li>流程是故事叙事大纲，是一个节点面板，可以在此处编写逻辑和故事。</li></ul></li></ul><img src="https://s2.loli.net/2023/04/23/tlr2a3Wz7G8uviU.png"  width="300"><ul><li>全局变量(Global Variables)：<ul><li>全局变量规定必须属于一个变量集，所以必须先创建变量集，在里面才能添加全局变量。就比如说一些基础判断布尔，整数数值的累积，以及字符串。</li></ul></li></ul><img src="https://s2.loli.net/2023/04/23/A1kREbiIanX8Uuw.png"  width="300"><ul><li>地点(Location)：(本指南不涉及)<ul><li>许多日式解谜游戏都喜欢在一个固定的图片画面里藏一些鼠标点击才触发剧情的东西，这里边有一个基础的地图绘制系统。（免费版地图上限只有10个）</li></ul></li></ul><img src="https://s2.loli.net/2023/04/23/cD1xLbaIeHfgurk.png"  width="300"><ul><li>旅程(Journeys)：(本指南不涉及)<ul><li>这里的旅程指的是RPG游戏中的好结局(GE)坏结局(BE)之类，规定玩家必须走哪个流程才能达成结局。</li></ul></li></ul><img src="https://s2.loli.net/2023/04/23/dOLbA4NgujUvYVn.png"  width="300"><h2 id="（乙）流程-Flow-中节点"><a href="#（乙）流程-Flow-中节点" class="headerlink" title="（乙）流程(Flow)中节点"></a>（乙）流程(Flow)中节点</h2><ul><li>流程片段(流片段)(Flow Fragment)<ul><li>流程片段是一个最基础的节点，可以作为一个剧情容器，将其他剧情对话放在容器中。</li><li>左上角需要选择预览图像；右上角需要拖拽一些引用的实体；在下方填入说明文本。</li></ul></li></ul><img src="https://s2.loli.net/2023/04/23/trcLGFT6idpQqVn.png"  width="300"><ul><li>对话(Dialogue)<ul><li>对话节点主要代表一个完整的对话，而不是一个人说的一句话。与流程片段节点几乎等价。</li><li>左上角需要选择预览图像；右上角需要拖拽一些引用的实体；在下方填入说明文本。</li></ul></li></ul><img src="https://s2.loli.net/2023/04/23/6WCaI2YObqDMKin.png"  width="300"><ul><li>对话片段(Dialogue Fragment)<ul><li>对话片段是一个人说的一句话，需要“沉浸”到对话片段中（放于节点子集）。</li><li>上方发言者需要引用一个实体；头像槽右方需要填写菜单文本，菜单文本显示在当该节点需要通过分支选项按钮点击进来时，分支按钮上显示的文字；下方舞台指示区是一些剧本的提示信息，比如人物实体说话时的语气，供后期配音演员比对；最下方是对话的实际文字。</li></ul></li></ul><img src="https://s2.loli.net/2023/04/23/MA4g1hQmsazjepu.png"  width="275"><ul><li>核心(Hub)<ul><li>核心是一个抽象的状态，多个对话可以链接到同一核心，核心也可以输出到多个对话中，相当于集线器。</li></ul></li></ul><img src="https://s2.loli.net/2023/04/23/QU9nVTNJDFfM6ak.png"  width="250"><ul><li>跳转(Jump)<ul><li>方便跳转到某个节点上，例如核心节点。</li><li>跳转需要在槽中填写将要跳转的节点，一般是核心(Hub)节点。</li></ul></li></ul><img src="https://s2.loli.net/2023/04/23/gXzjGARCtHxiMoQ.png"  width="250"><ul><li>条件(Condition)<ul><li>条件需要你去写脚本，当条件满足，跳到绿色输出针脚；当条件不满足，则跳到红色输出针脚。</li><li>需要填写条件。</li></ul></li></ul><img src="https://s2.loli.net/2023/04/23/AbqGNzKT5Lg6nyH.png"  width="300"><ul><li>命令(说明)(Instruction)<ul><li>命令说明节点是设置条件，修改数值。</li><li>需要填写命令。</li></ul></li></ul><img src="https://s2.loli.net/2023/04/23/vOQ3lYRoUhTXrWB.png"  width="300"><ul><li>注释(Annotation)<ul><li>就是注释，没别的活儿。</li></ul></li></ul><img src="https://s2.loli.net/2023/04/23/HDXdvQaAgmoC2eK.png"  width="300"><h2 id="（丙）物体基础信息查看"><a href="#（丙）物体基础信息查看" class="headerlink" title="（丙）物体基础信息查看"></a>（丙）物体基础信息查看</h2><ul><li>以流程片段(FlowFragment)节点为例，在流程(Flow)面板里选择该节点，右键打开属性(F8)：<ul><li>技术名称：该节点在代码中调用时所称呼的名称，没有两个游戏物体的技术名是一致的。</li><li>ID：代码中也可以调用该物体的ID，削微有一点不常用。</li></ul></li></ul><img src="https://s2.loli.net/2023/04/23/62IywkFK1i8fuLe.png"  width="600"><ul><li>点开“模板”标签，如果提示没有应用模板，则按右边的按钮选择一个模板。<ul><li>例如此时的模板名为FlowFragMessage，该模板下有两个特性：NodeMessage和DiaMessage，NodeMessage特性下又有一个布尔属性：isLastNode。</li></ul></li></ul><img src="https://s2.loli.net/2023/04/23/WpKftC9wL8vbasQ.png"  width="600"><h2 id="（丁）Articy-Expresso表达式"><a href="#（丁）Articy-Expresso表达式" class="headerlink" title="（丁）Articy:Expresso表达式"></a>（丁）Articy:Expresso表达式</h2><ul><li>AE表达式主要是为了配合条件和命令两个节点来使用的，基本上就是普通编程语言的青春版。</li></ul><h3 id="如何获取基础信息"><a href="#如何获取基础信息" class="headerlink" title="如何获取基础信息"></a>如何获取基础信息</h3><ul><li>基本上获取下列两种游戏信息就足够了：<ul><li>全局变量：<ul><li>可Get可Set：<code>[变量集名].[变量名]</code></li></ul></li><li>属性变量：<ul><li>Get方法：<code>getProp(getObj(&quot;[物体技术名]&quot;), &quot;[特征名].[属性名]&quot;)</code></li><li>Set方法：<code>setProp(getObj(&quot;[物体技术名]&quot;), &quot;[特征名].[属性名]&quot;, [新值])</code></li></ul></li></ul></li></ul><h3 id="条件节点-Condition"><a href="#条件节点-Condition" class="headerlink" title="条件节点(Condition)"></a>条件节点(Condition)</h3><ul><li>条件节点里面唯一要填写的是一个布尔变量；这个布尔变量由判断表达式构成：<ul><li>判断操作符：<code>等于==</code>  <code>不等于!=</code>  <code>小于等于&lt;=</code>  <code>大于等于&gt;=</code>  <code>小于&lt;</code>  <code>大于&gt;</code></li><li>逻辑操作符：<code>与&amp;&amp;</code>  <code>或||</code></li><li>基础运算符：<code>加减乘除余+-*/%</code></li></ul></li><li>比方说我在全局变量集MyVariableSet里有布尔变量isOpened，我需要在一个节点前先判断是否isOpened是真，就可以这么写：<ul><li><code>MyVariableSet. isOpened == true</code>（没有分号结尾）</li></ul></li><li>比方说玩家人物的技术名称为PC_Player，判断其模板中BasicFeature特性中attack数值属性是否大于10，就可以这么写：<ul><li><code>getProp(getObj(&quot;PC_player&quot;), &quot;BasicFeature. attack&quot;) &gt; 10</code>（没有分号结尾）</li></ul></li><li>如果该节点是对话片段(Dialogue Fragment)节点，发言者正好是玩家，就可以直接调用其发言者speaker：<ul><li><code>getProp(speaker, &quot;BasicFeature. attack&quot;) &gt; 10</code>（没有分号结尾）</li></ul></li><li>在流程(Flow)中的带引脚的节点的左引脚可以双击，在弹出的对话框里可以写入条件。</li></ul><h3 id="命令节点-Instruction"><a href="#命令节点-Instruction" class="headerlink" title="命令节点(Instruction)"></a>命令节点(Instruction)</h3><ul><li>命令节点里需要填写赋值命令，以英文分号间隔；命令节点里除了基础运算符之外，还有：<ul><li>引用运算符：<code>自增+=</code>  <code>自减-=</code>  <code>自乘*=</code>  <code>自除/=</code>  <code>自余%=</code></li></ul></li><li>如果我要修改MyVariableSet变量集里的isOpened布尔值：<ul><li><code>MyVariableSet. isOpened = true;</code>（每一句都要有分号结尾）</li></ul></li><li>如果我要修改玩家实体的BasicFeature特性中的attack数值：<ul><li><code>setProp(getProp(&quot;PC_Player&quot;), &quot;BasicFeature. attack&quot;, 10);</code>（每一句都要有分号结尾）</li></ul></li><li>如果玩家属性是需要自增的，就必须先getProp，再setProp：<ul><li><code>setProp(getProp(&quot;PC_Player&quot;), &quot;BasicFeature. attack&quot;, getProp(getObj(&quot;PC_player&quot;), &quot;BasicFeature. attack&quot;) + 1);</code>（每一句都要有分号结尾）</li></ul></li><li>在流程(Flow)中的带引脚的节点的右引脚可以双击，在弹出的对话框里可以写入命令。</li></ul><h2 id="（戊）Unity代码层面获取信息"><a href="#（戊）Unity代码层面获取信息" class="headerlink" title="（戊）Unity代码层面获取信息"></a>（戊）Unity代码层面获取信息</h2><ul><li>引用</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Articy.Unity;<span class="comment">//Articy的主要内容</span></span><br><span class="line"><span class="keyword">using</span> Articy.Unity.Interfaces;<span class="comment">//Articy的接口</span></span><br><span class="line"><span class="comment">//这个引用需要与 Articy Draft 3 的工程名对应，不然会报错，比如说示例的工程名为Samplenarrative，其自动生成的脚本都会自动隶属于这个命名空间内。</span></span><br><span class="line"><span class="keyword">using</span> Articy.Samplenarrative;</span><br></pre></td></tr></table></figure><ul><li>使用检视界面来获取物体引用</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ArticyTypeConstraint(typeof([模板名</span>]))]<span class="comment">//使用属性限制取值类型</span></span><br><span class="line"><span class="keyword">public</span> Articy.Unity.ArticyRef playerRef;<span class="comment">//使用Inspector来检索Articy打包的物体</span></span><br><span class="line"><span class="comment">//此处模板名指的是在Unity的Assets/ArticyImporter/Content/Generated路径下的系统自动生成的脚本的类名，一般物体都会以其所应用模板的名来命名。</span></span><br></pre></td></tr></table></figure><ul><li>获取或设置全局变量</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> globalBool =</span><br><span class="line">    ArticyGlobalVariables.Default.[变量集名].[变量名];<span class="comment">//获取Get</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">ArticyGlobalVariables.Default.[变量集名].[变量名] = globalBool;<span class="comment">//设置Set</span></span><br></pre></td></tr></table></figure><ul><li>使用数据库来获取物体属性</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> property = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//为防止获取不到而报错，所以应该先判断是否可以投射(Cast)到模板类。</span></span><br><span class="line"><span class="keyword">if</span> (ArticyDatabase. GetObject(<span class="string">&quot;[技术名]&quot;</span>) <span class="keyword">as</span> [模板名])</span><br><span class="line">&#123;</span><br><span class="line">    property = (ArticyDatabase. GetObject(<span class="string">&quot;[技术名]&quot;</span>) <span class="keyword">as</span> [模板名]).</span><br><span class="line">        getProp(<span class="string">&quot;[特性名].[属性名]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处模板名指的是在Unity的Assets/ArticyImporter/Content/Generated路径下的系统自动生成的脚本的类名，一般物体都会以其所应用模板的名来命名。</span></span><br></pre></td></tr></table></figure><h2 id="（己）自制AD模板与其所对应的Unity模板"><a href="#（己）自制AD模板与其所对应的Unity模板" class="headerlink" title="（己）自制AD模板与其所对应的Unity模板"></a>（己）自制AD模板与其所对应的Unity模板</h2><h3 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h3><ul><li>在此Unity模板中需要有第三方Unity插件：<ul><li>Odin Inspector：做编辑器界面的，没有也没关系，把爆红的删掉就行。</li><li>Text Mesh Pro：Unity的一个隐性内置文字插件，需要在Package Manager里面安装。</li><li>Anima Text：做文字动画的插件，没有也可以，删掉就行，不妨碍，大不了没动画。</li></ul></li></ul><h3 id="AD模板设置"><a href="#AD模板设置" class="headerlink" title="AD模板设置"></a>AD模板设置</h3><ul><li>特性定义：<ul><li>ActorFeature：<ul><li>(数值)hitPoint：100，0，100，0（默认值，最小值，最大值，小数位数）</li><li>(数值)attack：1，1，20，0（默认值，最小值，最大值，小数位数）</li><li>(数值)defense：0，0，100，0（默认值，最小值，最大值，小数位数）</li><li>(文本小)actorName：_, , , （默认值，……）</li></ul></li><li>NodeMessage：<ul><li>(布尔)isLastNode：False（默认值）</li></ul></li><li>DiaMessage：<ul><li>(数值)startDelay：0，0，100，2（默认值，最小值，最大值，小数位数）</li><li>(数值)branchDelay：0.25，0，100，2（默认值，最小值，最大值，小数位数）</li><li>(数值)passDelay：0.1，0，100，2（默认值，最小值，最大值，小数位数）</li><li>(数值)wordSpeed：5，1，10，0（默认值，最小值，最大值，小数位数）</li></ul></li></ul></li><li>模板定义：<ul><li>(复数流片段)FlowFragMessage：NodeMessage，DiaMessage</li><li>(复数对话)DialogueMessage：NodeMessage，DiaMessage</li><li>(复数对话片段)BasicDialogue：NodeMessage，DiaMessage</li><li>(复数核心)HubMessage：NodeMessage</li><li>(复数条件)ConditionMessage：NodeMessage</li><li>(复数说明)InstructionMessage：NodeMessage</li><li>(实体)Player：ActorFeature</li><li>(实体)NPC：ActorFeature</li></ul></li><li>模板使用方法：<ul><li>在流程(Flow)根画布上新建流程片段，表示第一章的所有内容归类。<ul><li>注意：包括此节点在内，接下来所有节点都必须应用上面所规定的模板！</li></ul></li><li>在此流程片段上按回车，进入节点子集，新建对话(不是对话片段)，表示一大段的对话。<ul><li>注意：对话节点需要与虚框上左右两边的输入输出节点相连！</li></ul></li><li>在此对话节点上按回车，进入节点子集，新建一些对话片段，彼此相连（包括虚框），在最后一个对话片段节点上右键属性，将NodeMessage特性里isLastNode设为true，表示这是对话的最后一个节点。</li><li>在最后一个对话片段之后再新建一个流程片段节点，其标题名设置为此段对话的结束按钮名。<ul><li>注意：首尾节点需要与虚框上左右两边的输入输出节点相连！</li></ul></li></ul></li></ul><h3 id="将AD的工程信息导入到Unity中"><a href="#将AD的工程信息导入到Unity中" class="headerlink" title="将AD的工程信息导入到Unity中"></a>将AD的工程信息导入到Unity中</h3><ul><li>点击AD界面左上角圆形菜单，点导出，跳出导出页面：<ul><li>选择技术输出中的Unity导出，应用默认的导出规则集，选择Unity工程的Assets路径为导出文件夹。</li><li>点“好的”。（前提是Unity需要到Asset Store上下载导入器，否则无效）</li></ul></li></ul><h3 id="Unity模板"><a href="#Unity模板" class="headerlink" title="Unity模板"></a>Unity模板</h3><ul><li>Unity的Asset Store上面搜索Articy Draft，将导入器下到工程里。<ul><li>注意：导入器不可变更其绝对路径！</li></ul></li><li>当在AD里将工程信息导入之后，按照如下步骤建立对话系统：<ul><li>在大纲里新建Canvas画布，添加ArticyFlowPlayer组件。</li><li>在此Canvas画布里构建一个拥有：<ul><li>作为对话头像预览的Image组件。</li><li>作为对话的实际文本框的TextMeshProUGUI组件。（此文字组件再加上AnimatextTMProOld组件，如果有Animatext插件的话）</li><li>作为自动生成的分支按钮所存放的父级，这里推荐使用ScrollView卷轴。</li></ul></li><li>新建脚本ArticyBranch，将其加在一个新建的按钮Button上，将按钮设为预制体，并将实例删除。</li><li>新建脚本ArticyFlowManager，并将其加在Canvas画布的ArticyFlowPlayer下。</li><li>将Canvas画布设为预制体。</li><li>新建脚本ArticyInitTrigger，并将其加在一个trigger触发器上，将Canvas画布预制体放到trigger触发器的子集，将画布的Enable设置为false，将trigger触发器设为预制体。</li></ul></li></ul><h3 id="脚本ArticyFlowManager内容"><a href="#脚本ArticyFlowManager内容" class="headerlink" title="脚本ArticyFlowManager内容"></a>脚本ArticyFlowManager内容</h3><ul><li><p>脚本功能介绍：将ArticyFlowPlayer里面所播放的节点的隐性数据使用UI来公之于众。（为了实现Articy的IArticyFlowPlayerCallbacks接口） </p></li><li><p><a href="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/tree/master/docs/ArticyToUnityTemplate/ArticyFlowManager.cs">点击查看（如果点不开就复制下面的代码吧）</a></p></li><li><p>branchPrefab：按钮预制体</p></li><li><p>txt_mainText：对话文本框</p></li><li><p>rTrans_branchParent：按钮父级</p></li><li><p>img_previewImage：对话头像预览UI</p></li><li><p>IsPlaying：对话运行状态</p></li><li><p>showFalseBranches：是否允许出现非法分支</p></li><li><p>flowPlayer：绑定的ArticyFlowPlayer播放器组件</p></li><li><p>StartOnFlow：对话从哪个节点开始</p></li><li><p>key_forceJumpDelay：跳过按钮出现等待时间的按键</p></li><li><p>textEffect：Animatext插件模板（在文末有模板数据）</p></li><li><p>intervalRange：每个字出现耗时的最小值与最大值</p></li></ul><img src="https://s2.loli.net/2023/04/23/s1zxtYZgMNLvajd.png"  width="400"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">using</span> Sirenix.OdinInspector;</span><br><span class="line"><span class="keyword">using</span> TMPro;</span><br><span class="line"><span class="keyword">using</span> Animatext.Effects;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">using</span> Articy.Unity;</span><br><span class="line"><span class="keyword">using</span> Articy.Unity.Interfaces;</span><br><span class="line"><span class="keyword">using</span> Articy.Samplenarrative;<span class="comment">//这个引用需要与 Articy Draft 3 的工程名对应，不然会报错，比如说示例的工程名为Samplenarrative</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">RequireComponent(typeof(ArticyFlowPlayer))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ArticyFlowManager</span> : <span class="title">MonoBehaviour</span>, <span class="title">IArticyFlowPlayerCallbacks</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 变量声明</span></span><br><span class="line">    [<span class="meta">BoxGroup(<span class="string">&quot;预制体&quot;</span>, true, true)</span>]</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">public</span> GameObject branchPrefab;<span class="comment">//用来生成分支实例的分支预制</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">BoxGroup(<span class="string">&quot;界面元素&quot;</span>, true, true)</span>]</span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">public</span> TextMeshProUGUI txt_mainText;<span class="comment">//节点对话显示UI</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">BoxGroup(<span class="string">&quot;界面元素&quot;</span>, true, true)</span>]</span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">public</span> RectTransform rTrans_branchParent;<span class="comment">//分支选项父级</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">BoxGroup(<span class="string">&quot;界面元素&quot;</span>, true, true)</span>]</span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">public</span> Image img_previewImage;<span class="comment">//节点预览图显示槽UI</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">BoxGroup(<span class="string">&quot;流程控制&quot;</span>, true, true), ReadOnly</span>]</span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">public</span> <span class="built_in">bool</span> isPlaying = <span class="literal">false</span>;<span class="comment">//是否正在运行（目前被ArticyInitTrigger引用）</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">BoxGroup(<span class="string">&quot;流程控制&quot;</span>, true, true)</span>]</span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">public</span> <span class="built_in">bool</span> showFalseBranches = <span class="literal">false</span>;<span class="comment">//是否显示已经无法通过的分支</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">BoxGroup(<span class="string">&quot;流程控制&quot;</span>, true, true)</span>]</span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">public</span> ArticyFlowPlayer flowPlayer;<span class="comment">//流程播放器组件</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">BoxGroup(<span class="string">&quot;流程控制&quot;</span>, true, true)</span>]</span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">public</span> ArticyRef startOnFlow;<span class="comment">//开始节点位置</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">BoxGroup(<span class="string">&quot;流程控制&quot;</span>, true, true)</span>]</span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">public</span> KeyCode key_forceJumpDelay = KeyCode.Mouse0;<span class="comment">//强制跳出延迟的按键</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">BoxGroup(<span class="string">&quot;特效&quot;</span>, true, true)</span>]</span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">public</span> DefaultTemplateEffect textEffect;<span class="comment">//文字动画特效模板</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">BoxGroup(<span class="string">&quot;特效&quot;</span>, true, true), MinMaxSlider(0.0f, 0.5f, ShowFields=true), LabelWidth(100)</span>]</span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">public</span> Vector2 intervalRange = <span class="keyword">new</span> Vector2(<span class="number">0.025f</span>, <span class="number">0.25f</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> startDelayTimer = <span class="number">0.0f</span>;<span class="comment">//开始延迟计时器</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> startDelayTimerMax = <span class="number">0.0f</span>;<span class="comment">//开始延迟计时器最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> initBranchTimer = <span class="number">0.0f</span>;<span class="comment">//生成选项的延迟计时器</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> initBranchTimerMax = <span class="number">0.0f</span>;<span class="comment">//生成选项的延迟计时器最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> passDelayTimer = <span class="number">0.0f</span>;<span class="comment">//跳过选项的延迟计时器</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> passDelayTimerMax = <span class="number">0.0f</span>;<span class="comment">//跳过选项的延迟计时器最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> cur_startDelay = <span class="number">0.0f</span>;<span class="comment">//当前语段的初始延迟（经过初始延迟之后，文字才会出来）</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> cur_branchDelay = <span class="number">0.25f</span>;<span class="comment">//当前语段的分支延迟（在文字出来之后，再经过分支延迟，分支才会出来）</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> cur_passDelay = <span class="number">0.1f</span>;<span class="comment">//当前语段的跳过延迟（在文字出来之后，再经过跳过延迟，就可以提前跳过分支延迟，直接显示分支）</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> cur_wordSpeed = <span class="number">5</span>;<span class="comment">//当前语段的文字动画速度</span></span><br><span class="line">[<span class="meta">HideInInspector</span>] <span class="keyword">public</span> <span class="built_in">bool</span> cur_isLastNode = <span class="literal">false</span>;<span class="comment">//当前语段是否是最后一句话</span></span><br><span class="line"><span class="keyword">private</span> IFlowObject cur_flowObject;<span class="comment">//当前接口参数流程物体</span></span><br><span class="line"><span class="keyword">private</span> IList&lt;Branch&gt; cur_branches;<span class="comment">//当前语段生成的分支</span></span><br><span class="line">[<span class="meta">HideInInspector</span>] <span class="keyword">public</span> List&lt;Button&gt; cur_branchButtons = <span class="keyword">new</span> List&lt;Button&gt;();<span class="comment">//当前语段分支的按钮组件</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> isStartDelay = <span class="literal">false</span>;<span class="comment">//控制开始延迟的计数</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> isInitBranch = <span class="literal">false</span>;<span class="comment">//控制分支选项的生成</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> isPassDelay = <span class="literal">false</span>;<span class="comment">//控制跳过选项的计数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    <span class="comment">//——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> Mono流程函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ClearAllBranches();<span class="comment">//清理所有之前的分支</span></span><br><span class="line">JumpToFlow(startOnFlow);<span class="comment">//设置开始节点</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">UpdateStartDelayTimer();<span class="comment">//根据计时器来控制文字的显示</span></span><br><span class="line">UpdateBranchTimer();<span class="comment">//根据计时器来控制选项的生成</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    <span class="comment">//——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 原型接口实现</span></span><br><span class="line">    <span class="comment">//人物对话都可在jumpDelay之后跳过，需要有一种特殊的跳过按钮，上面没有字，生成的位置与普通选项不一样</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnFlowPlayerPaused</span>(<span class="params">IFlowObject aObject</span>)<span class="comment">//必须实现的接口：当进入新的对话节点时</span></span></span><br><span class="line">&#123;</span><br><span class="line">ExtractCurrentPausePreviewImage(aObject);<span class="comment">//显示此时的节点预览图</span></span><br><span class="line">img_previewImage.enabled = IsDialogueFragment(aObject);<span class="comment">//是否开启预览图  //背景图的显示，当当前的节点不是语段时，隐藏背景图，反之。</span></span><br><span class="line">SetCurrentProperties(aObject);<span class="comment">//刷新主要数值</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">txt_mainText.text = <span class="built_in">string</span>.Empty;<span class="comment">//清空文档</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">isStartDelay = <span class="literal">true</span>;<span class="comment">//开始执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnFlowPlayerPausedAlt</span>(<span class="params">IFlowObject aObject</span>)<span class="comment">//接口第二部分</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> modelWithText = aObject <span class="keyword">as</span> IObjectWithText;<span class="comment">//使用接口的方法获取节点对话</span></span><br><span class="line"><span class="built_in">string</span> speakerName = (aObject <span class="keyword">as</span> IObjectWithSpeaker) != <span class="literal">null</span> ? </span><br><span class="line"><span class="string">$&quot;<span class="subst">&#123;(<span class="built_in">string</span>)(aObject <span class="keyword">as</span> IObjectWithSpeaker).Speaker.getProp(<span class="string">&quot;ActorFeature.actorName&quot;</span>)&#125;</span>：\n    &quot;</span> : <span class="built_in">string</span>.Empty;</span><br><span class="line"><span class="built_in">string</span> mainText = <span class="string">$&quot;<span class="subst">&#123;speakerName&#125;</span>&lt;flow&gt;<span class="subst">&#123;modelWithText.Text&#125;</span>&lt;/flow&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (modelWithText != <span class="literal">null</span>) &#123; txt_mainText.text = mainText; &#125;<span class="comment">//将节点对话显示在UI上</span></span><br><span class="line"><span class="keyword">else</span> &#123; txt_mainText.text = <span class="built_in">string</span>.Empty; &#125;<span class="comment">//否则设为空</span></span><br><span class="line">textEffect.interval = Mapping(cur_wordSpeed, <span class="number">10</span>, <span class="number">1</span>, intervalRange.x, intervalRange.y);<span class="comment">//设置文字播放速度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateStartDelayTimer</span>()<span class="comment">//根据计时器来控制文字的显示</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (isStartDelay == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span> (startDelayTimer &lt; startDelayTimerMax)<span class="comment">//计时器</span></span><br><span class="line">&#123;</span><br><span class="line">startDelayTimer += Time.deltaTime;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">startDelayTimer = <span class="number">0</span>;</span><br><span class="line">OnFlowPlayerPausedAlt(cur_flowObject);<span class="comment">//执行接口第二部分：进入新的对话</span></span><br><span class="line">isStartDelay = <span class="literal">false</span>;<span class="comment">//退出执行</span></span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">GetIfIsLastNode</span>(<span class="params">IFlowObject aObject</span>)<span class="comment">//判断是否是一句话最后一个节点</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (IsFlowFragment(aObject))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> GetFlowFragmentProperty(aObject, <span class="string">&quot;NodeMessage.isLastNode&quot;</span>);<span class="comment">//当前节点是否为最后一个节点///</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsDialogueFragment(aObject))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> GetDialogueFragmentProperty(aObject, <span class="string">&quot;NodeMessage.isLastNode&quot;</span>);<span class="comment">//当前节点是否为最后一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsHub(aObject))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> GetHubProperty(aObject, <span class="string">&quot;NodeMessage.isLastNode&quot;</span>);<span class="comment">//当前节点是否为最后一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsCondition(aObject))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> GetConditionProperty(aObject, <span class="string">&quot;NodeMessage.isLastNode&quot;</span>);<span class="comment">//当前节点是否为最后一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsInstruction(aObject))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> GetInstructionProperty(aObject, <span class="string">&quot;NodeMessage.isLastNode&quot;</span>);<span class="comment">//当前节点是否为最后一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetCurrentProperties</span>(<span class="params">IFlowObject aObject</span>)<span class="comment">//刷新获取到的数值</span></span></span><br><span class="line">    &#123;</span><br><span class="line">cur_flowObject = aObject;</span><br><span class="line">cur_startDelay = GetUnknownFloat(aObject, <span class="string">&quot;DiaMessage.startDelay&quot;</span>);<span class="comment">//当前语段的初始延迟</span></span><br><span class="line">cur_branchDelay = GetUnknownFloat(aObject, <span class="string">&quot;DiaMessage.branchDelay&quot;</span>);<span class="comment">//当前语段的分支延迟</span></span><br><span class="line">cur_passDelay = GetUnknownFloat(aObject, <span class="string">&quot;DiaMessage.passDelay&quot;</span>);<span class="comment">//当前语段的跳过分支延迟的延迟</span></span><br><span class="line">cur_wordSpeed = GetUnknownInt(aObject, <span class="string">&quot;DiaMessage.wordSpeed&quot;</span>);<span class="comment">//当前语段的文字动画速度</span></span><br><span class="line">cur_isLastNode = GetIfIsLastNode(aObject);<span class="comment">//判断是否是一句话最后一个节点</span></span><br><span class="line">startDelayTimerMax = cur_startDelay;<span class="comment">//延迟最大值计算</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBranchesUpdated</span>(<span class="params">IList&lt;Branch&gt; aBranches</span>)<span class="comment">//必须实现的接口：当进入分支选项时</span></span></span><br><span class="line">&#123;</span><br><span class="line">ClearAllBranches();<span class="comment">//清理所有之前的分支</span></span><br><span class="line">cur_branches = aBranches;<span class="comment">//当前分支</span></span><br><span class="line">initBranchTimerMax = cur_startDelay + cur_branchDelay;<span class="comment">//延迟最大值</span></span><br><span class="line">passDelayTimerMax = cur_passDelay;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">isInitBranch = <span class="literal">true</span>;<span class="comment">//开始执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnBranchesUpdateAlt</span>(<span class="params">IList&lt;Branch&gt; aBranches</span>)<span class="comment">//接口第二部分</span></span></span><br><span class="line">    &#123;</span><br><span class="line">cur_branchButtons = <span class="keyword">new</span> List&lt;Button&gt;();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> branch <span class="keyword">in</span> aBranches)<span class="comment">//遍历所有当前分支</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!branch.IsValid &amp;&amp; !showFalseBranches) <span class="keyword">continue</span>;<span class="comment">//当分支不合法时，放弃生成该分支</span></span><br><span class="line"><span class="keyword">var</span> btn = Instantiate(branchPrefab, rTrans_branchParent);<span class="comment">//生成一个按钮</span></span><br><span class="line"><span class="keyword">var</span> branchBtn = btn.GetComponent&lt;ArticyBranch&gt;();<span class="comment">//获取按钮的ArticyDebugBranch自定义组件</span></span><br><span class="line"><span class="keyword">if</span> (branchBtn == <span class="literal">null</span>) &#123; branchBtn = btn.AddComponent&lt;ArticyBranch&gt;(); &#125;<span class="comment">//没有就加一个</span></span><br><span class="line">branchBtn.AssignBranch(flowPlayer, branch, cur_isLastNode);<span class="comment">//将按钮与分支相连</span></span><br><span class="line"><span class="keyword">if</span> (cur_isLastNode)<span class="comment">//如果是最后一个节点</span></span><br><span class="line">            &#123;</span><br><span class="line">branchBtn.GetComponent&lt;Button&gt;().onClick.AddListener(</span><br><span class="line">() =&gt; isPlaying = <span class="literal">false</span>);<span class="comment">//设置按钮点击后，isPlaying设置为false</span></span><br><span class="line">branchBtn.GetComponent&lt;Button&gt;().onClick.AddListener(</span><br><span class="line">() =&gt; gameObject.SetActive(<span class="literal">false</span>));<span class="comment">//设置按钮点击后，关闭本UI对话</span></span><br><span class="line">            &#125;</span><br><span class="line">cur_branchButtons.Add(branchBtn.GetComponent&lt;Button&gt;());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateBranchTimer</span>()<span class="comment">//根据计时器来控制选项的生成</span></span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span> (isInitBranch == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span> (passDelayTimer &lt; passDelayTimerMax) &#123; passDelayTimer += Time.deltaTime; &#125;<span class="comment">//计时器</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">passDelayTimer = <span class="number">0</span>;</span><br><span class="line">isPassDelay = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (isPassDelay)</span><br><span class="line">            &#123;</span><br><span class="line"><span class="keyword">if</span> (Input.GetKeyDown(key_forceJumpDelay))<span class="comment">//如果干预</span></span><br><span class="line">                &#123;</span><br><span class="line">initBranchTimer = initBranchTimerMax;<span class="comment">//直接跳过</span></span><br><span class="line">&#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (initBranchTimer &lt; initBranchTimerMax) &#123; initBranchTimer += Time.deltaTime; &#125;<span class="comment">//计时器</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">initBranchTimer = <span class="number">0</span>;</span><br><span class="line">OnBranchesUpdateAlt(cur_branches);<span class="comment">//执行接口第二部分：生成分支选项</span></span><br><span class="line">isInitBranch = <span class="literal">false</span>;<span class="comment">//退出执行</span></span><br><span class="line">isPassDelay = <span class="literal">false</span>;<span class="comment">//干预完毕</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    <span class="comment">//——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 原型基础函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ClearAllBranches</span>()<span class="comment">//清理所有之前的分支</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">foreach</span> (Transform child <span class="keyword">in</span> rTrans_branchParent)</span><br><span class="line">        &#123;</span><br><span class="line">Destroy(child.gameObject);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ExtractCurrentPausePreviewImage</span>(<span class="params">IFlowObject aObject</span>)<span class="comment">//显示此时的节点预览图</span></span></span><br><span class="line">&#123;</span><br><span class="line">IAsset articyAsset = <span class="literal">null</span>;<span class="comment">//声明资源文件</span></span><br><span class="line">img_previewImage.sprite = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> dlgSpeaker = aObject <span class="keyword">as</span> IObjectWithSpeaker;<span class="comment">//使用接口的方法获取节点的演讲人</span></span><br><span class="line"><span class="keyword">if</span> (dlgSpeaker != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">ArticyObject speaker = dlgSpeaker.Speaker;<span class="comment">//获取演讲人</span></span><br><span class="line"><span class="keyword">if</span> (speaker != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> speakerWithPreviewImage = speaker <span class="keyword">as</span> IObjectWithPreviewImage;<span class="comment">//使用接口的方法获取节点的演讲人的预览图</span></span><br><span class="line"><span class="keyword">if</span> (speakerWithPreviewImage != <span class="literal">null</span>)<span class="comment">//演讲人的预览图不为空时</span></span><br><span class="line">&#123;</span><br><span class="line">articyAsset = speakerWithPreviewImage.PreviewImage.Asset;<span class="comment">//为资源文件赋值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (articyAsset == <span class="literal">null</span>)<span class="comment">//资源文件为空时</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> objectWithPreviewImage = aObject <span class="keyword">as</span> IObjectWithPreviewImage;<span class="comment">//使用接口的方法获取节点的&quot;该节点&quot;的预览图，而不是演讲人的</span></span><br><span class="line"><span class="keyword">if</span> (objectWithPreviewImage != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">articyAsset = objectWithPreviewImage.PreviewImage.Asset;<span class="comment">//为资源文件赋值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (articyAsset != <span class="literal">null</span>)<span class="comment">//资源文件不为空时</span></span><br><span class="line">&#123;</span><br><span class="line">img_previewImage.sprite = articyAsset.LoadAssetAsSprite();<span class="comment">//设置预览图图片文件</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">JumpToFlow</span>(<span class="params">ArticyRef reference</span>)<span class="comment">//直接跳到某个确切的节点开始播放</span></span></span><br><span class="line">&#123;</span><br><span class="line">SetCurrentProperties(reference.GetObject());<span class="comment">//刷新主要数值</span></span><br><span class="line">flowPlayer.StartOn = reference.GetObject();</span><br><span class="line">isPlaying = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">[<span class="meta">Button(<span class="string">&quot;跳到开始（只能在运行中执行）&quot;</span>, ButtonSizes.Medium), BoxGroup(<span class="string">&quot;流程控制&quot;</span>, true, true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">JumpToStart</span>()<span class="comment">//直接跳到开始</span></span></span><br><span class="line">&#123;</span><br><span class="line">JumpToFlow(startOnFlow);<span class="comment">//设置开始节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"><span class="comment">//——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line"><span class="meta">#<span class="keyword">region</span> 获取信息Samplenarrative</span></span><br><span class="line"><span class="comment">//&quot;using Articy.Samplenarrative;&quot;需要与AD工程导入的生成代码的实际命名空间为主，需要及时修改，不然会报错</span></span><br><span class="line"><span class="comment">//是否属于FlowFragment类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsFlowFragment</span>(<span class="params">IFlowObject aObject</span>)</span> &#123; <span class="keyword">return</span> (aObject <span class="keyword">as</span> IArticyObject) <span class="keyword">as</span> FlowFragment; &#125;</span><br><span class="line"><span class="comment">//获取自动生成的FlowFragment类的物体特性属性，例如DiaMessage.startDelay</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ScriptDataProxy <span class="title">GetFlowFragmentProperty</span>(<span class="params">IFlowObject aObject, <span class="built_in">string</span> aFeatureProperty</span>)</span></span><br><span class="line">&#123; <span class="keyword">return</span> ((aObject <span class="keyword">as</span> IArticyObject) <span class="keyword">as</span> FlowFragment).getProp(aFeatureProperty); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否属于Dialogue类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsDialogue</span>(<span class="params">IFlowObject aObject</span>)</span> &#123; <span class="keyword">return</span> (aObject <span class="keyword">as</span> IArticyObject) <span class="keyword">as</span> Dialogue; &#125;</span><br><span class="line"><span class="comment">//获取自动生成的Dialogue类的物体特性属性，例如DiaMessage.startDelay</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ScriptDataProxy <span class="title">GetDialogueProperty</span>(<span class="params">IFlowObject aObject, <span class="built_in">string</span> aFeatureProperty</span>)</span></span><br><span class="line">&#123; <span class="keyword">return</span> ((aObject <span class="keyword">as</span> IArticyObject) <span class="keyword">as</span> Dialogue).getProp(aFeatureProperty); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否属于DialogueFragment类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsDialogueFragment</span>(<span class="params">IFlowObject aObject</span>)</span> &#123; <span class="keyword">return</span> (aObject <span class="keyword">as</span> IArticyObject) <span class="keyword">as</span> DialogueFragment; &#125;</span><br><span class="line"><span class="comment">//获取自动生成的DialogueFragment类的物体特性属性，例如DiaMessage.startDelay</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ScriptDataProxy <span class="title">GetDialogueFragmentProperty</span>(<span class="params">IFlowObject aObject, <span class="built_in">string</span> aFeatureProperty</span>)</span></span><br><span class="line">    &#123; <span class="keyword">return</span> ((aObject <span class="keyword">as</span> IArticyObject) <span class="keyword">as</span> DialogueFragment).getProp(aFeatureProperty); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否属于Hub类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsHub</span>(<span class="params">IFlowObject aObject</span>)</span> &#123; <span class="keyword">return</span> (aObject <span class="keyword">as</span> IArticyObject) <span class="keyword">as</span> Hub; &#125;</span><br><span class="line"><span class="comment">//获取自动生成的Hub类的物体特性属性，例如DiaMessage.startDelay</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ScriptDataProxy <span class="title">GetHubProperty</span>(<span class="params">IFlowObject aObject, <span class="built_in">string</span> aFeatureProperty</span>)</span></span><br><span class="line">&#123; <span class="keyword">return</span> ((aObject <span class="keyword">as</span> IArticyObject) <span class="keyword">as</span> Hub).getProp(aFeatureProperty); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否属于Jump类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsJump</span>(<span class="params">IFlowObject aObject</span>)</span> &#123; <span class="keyword">return</span> (aObject <span class="keyword">as</span> IArticyObject) <span class="keyword">as</span> Jump; &#125;</span><br><span class="line"><span class="comment">//获取自动生成的Jump类的物体特性属性，例如DiaMessage.startDelay</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ScriptDataProxy <span class="title">GetJumpProperty</span>(<span class="params">IFlowObject aObject, <span class="built_in">string</span> aFeatureProperty</span>)</span></span><br><span class="line">&#123; <span class="keyword">return</span> ((aObject <span class="keyword">as</span> IArticyObject) <span class="keyword">as</span> Jump).getProp(aFeatureProperty); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否属于Condition类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsCondition</span>(<span class="params">IFlowObject aObject</span>)</span> &#123; <span class="keyword">return</span> (aObject <span class="keyword">as</span> IArticyObject) <span class="keyword">as</span> Condition; &#125;</span><br><span class="line"><span class="comment">//获取自动生成的Condition类的物体特性属性，例如DiaMessage.startDelay</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ScriptDataProxy <span class="title">GetConditionProperty</span>(<span class="params">IFlowObject aObject, <span class="built_in">string</span> aFeatureProperty</span>)</span></span><br><span class="line">&#123; <span class="keyword">return</span> ((aObject <span class="keyword">as</span> IArticyObject) <span class="keyword">as</span> Condition).getProp(aFeatureProperty); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否属于Instruction类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsInstruction</span>(<span class="params">IFlowObject aObject</span>)</span> &#123; <span class="keyword">return</span> (aObject <span class="keyword">as</span> IArticyObject) <span class="keyword">as</span> Instruction; &#125;</span><br><span class="line"><span class="comment">//获取自动生成的Instruction类的物体特性属性，例如DiaMessage.startDelay</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ScriptDataProxy <span class="title">GetInstructionProperty</span>(<span class="params">IFlowObject aObject, <span class="built_in">string</span> aFeatureProperty</span>)</span></span><br><span class="line">&#123; <span class="keyword">return</span> ((aObject <span class="keyword">as</span> IArticyObject) <span class="keyword">as</span> Instruction).getProp(aFeatureProperty); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取陌生节点的属性，限制节点于FlowFragment\Dialogue\DialogueFragment\Hub\Jump\Condition\Instruction之间，其他类返回空</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">GetUnknownInt</span>(<span class="params">IFlowObject aObject, <span class="built_in">string</span> aFeatureProperty</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span> (IsFlowFragment(aObject)) &#123; <span class="keyword">return</span> GetFlowFragmentProperty(aObject, aFeatureProperty); &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsDialogue(aObject)) &#123; <span class="keyword">return</span> GetDialogueProperty(aObject, aFeatureProperty); &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsDialogueFragment(aObject)) &#123; <span class="keyword">return</span> GetDialogueFragmentProperty(aObject, aFeatureProperty); &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsHub(aObject)) &#123; <span class="keyword">return</span> GetHubProperty(aObject, aFeatureProperty); &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsJump(aObject)) &#123; <span class="keyword">return</span> GetJumpProperty(aObject, aFeatureProperty); &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsCondition(aObject)) &#123; <span class="keyword">return</span> GetConditionProperty(aObject, aFeatureProperty); &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsInstruction(aObject)) &#123; <span class="keyword">return</span> GetInstructionProperty(aObject, aFeatureProperty); &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">float</span> <span class="title">GetUnknownFloat</span>(<span class="params">IFlowObject aObject, <span class="built_in">string</span> aFeatureProperty</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span> (IsFlowFragment(aObject)) &#123; <span class="keyword">return</span> GetFlowFragmentProperty(aObject, aFeatureProperty); &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsDialogue(aObject)) &#123; <span class="keyword">return</span> GetDialogueProperty(aObject, aFeatureProperty); &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsDialogueFragment(aObject)) &#123; <span class="keyword">return</span> GetDialogueFragmentProperty(aObject, aFeatureProperty); &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsHub(aObject)) &#123; <span class="keyword">return</span> GetHubProperty(aObject, aFeatureProperty); &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsJump(aObject)) &#123; <span class="keyword">return</span> GetJumpProperty(aObject, aFeatureProperty); &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsCondition(aObject)) &#123; <span class="keyword">return</span> GetConditionProperty(aObject, aFeatureProperty); &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsInstruction(aObject)) &#123; <span class="keyword">return</span> GetInstructionProperty(aObject, aFeatureProperty); &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">GetUnknownString</span>(<span class="params">IFlowObject aObject, <span class="built_in">string</span> aFeatureProperty</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (IsFlowFragment(aObject)) &#123; <span class="keyword">return</span> GetFlowFragmentProperty(aObject, aFeatureProperty).ToString(); &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsDialogue(aObject)) &#123; <span class="keyword">return</span> GetDialogueProperty(aObject, aFeatureProperty).ToString(); &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsDialogueFragment(aObject)) &#123; <span class="keyword">return</span> GetDialogueFragmentProperty(aObject, aFeatureProperty).ToString(); &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsHub(aObject)) &#123; <span class="keyword">return</span> GetHubProperty(aObject, aFeatureProperty).ToString(); &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsJump(aObject)) &#123; <span class="keyword">return</span> GetJumpProperty(aObject, aFeatureProperty).ToString(); &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsCondition(aObject)) &#123; <span class="keyword">return</span> GetConditionProperty(aObject, aFeatureProperty).ToString(); &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (IsInstruction(aObject)) &#123; <span class="keyword">return</span> GetInstructionProperty(aObject, aFeatureProperty).ToString(); &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>.Empty;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    <span class="comment">//——————————————————————————————————————————————————————————————————————————</span></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 功能函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">float</span> <span class="title">Mapping</span>(<span class="params"><span class="built_in">float</span> val, <span class="built_in">float</span> min1, <span class="built_in">float</span> max1, <span class="built_in">float</span> min2, <span class="built_in">float</span> max2</span>)<span class="comment">//MAPPING变量映射</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ((val - min1) * (max2 - min2) + min2 * (max1 - min1)) / (max1 - min1);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="脚本ArticyBranch内容"><a href="#脚本ArticyBranch内容" class="headerlink" title="脚本ArticyBranch内容"></a>脚本ArticyBranch内容</h3><ul><li><p>脚本功能介绍：为按钮的点击接口onClick添加监听器Listener，使其在点击之后能与ArticyFlowPlayer反应。</p></li><li><p><a href="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/tree/master/docs/ArticyToUnityTemplate/ArticyBranch.cs">点击查看（如果点不开就复制下面的代码吧）</a></p></li></ul><img src="https://s2.loli.net/2023/04/23/laTp2j3OUxYK6fS.png"  width="400"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> Articy.Unity;</span><br><span class="line"><span class="keyword">using</span> Articy.Unity.Interfaces;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"><span class="keyword">using</span> TMPro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ArticyBranch</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> TextMeshProUGUI dialogText;<span class="comment">//对话显示UI</span></span><br><span class="line"><span class="keyword">private</span> Branch branch;<span class="comment">//分支</span></span><br><span class="line"><span class="keyword">private</span> ArticyFlowPlayer processor;<span class="comment">//流程播放器</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AssignBranch</span>(<span class="params">ArticyFlowPlayer aProcessor, Branch aBranch, <span class="built_in">bool</span> isLastNode</span>)<span class="comment">//被外部调用，为分支赋值</span></span></span><br><span class="line">&#123;</span><br><span class="line">GetComponentInChildren&lt;Button&gt;().onClick.AddListener(OnBranchSelected);<span class="comment">//获取该物体或其子集身上的按钮组件，实现触发接口</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">dialogText = GetComponentInChildren&lt;TextMeshProUGUI&gt;();<span class="comment">//获取该物体或其子集身上的文字组件</span></span><br><span class="line">branch = aBranch;<span class="comment">//分支信息由外部获取</span></span><br><span class="line">processor = aProcessor;<span class="comment">//流程播放器由外部获取</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> target = aBranch.Target;<span class="comment">//分支的目标</span></span><br><span class="line">dialogText.text = <span class="string">&quot;&quot;</span>;<span class="comment">//初始化文字</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> menuText = target <span class="keyword">as</span> IObjectWithMenuText;<span class="comment">//使用接口的方法获取节点分支菜单文字</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (menuText != <span class="literal">null</span>)<span class="comment">//如果菜单文字存在</span></span><br><span class="line">&#123;</span><br><span class="line">dialogText.text = menuText.MenuText;<span class="comment">//设置菜单文字</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (dialogText.text == <span class="string">&quot;&quot;</span>)<span class="comment">//如果菜单文字为空字符串</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> txtObj = menuText <span class="keyword">as</span> IObjectWithText;<span class="comment">//使用接口的方法获取节点文字</span></span><br><span class="line"><span class="keyword">if</span> (txtObj != <span class="literal">null</span>)<span class="comment">//当节点文字存在时</span></span><br><span class="line">dialogText.text = txtObj.Text;<span class="comment">//显示节点文字作为选项菜单文字</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dialogText.text = <span class="string">&quot;...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (dialogText.text == <span class="string">&quot;&quot;</span>)<span class="comment">//如果菜单文字仍然空置，显示节点名</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> dspObj = target <span class="keyword">as</span> IObjectWithDisplayName;<span class="comment">//使用接口的方法获取节点名</span></span><br><span class="line"><span class="keyword">if</span> (dspObj != <span class="literal">null</span>)<span class="comment">//当节点名不为空时</span></span><br><span class="line">dialogText.text = dspObj.DisplayName;<span class="comment">//显示节点名</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> articyObject = target <span class="keyword">as</span> IArticyObject;</span><br><span class="line"><span class="keyword">if</span> (articyObject != <span class="literal">null</span>)</span><br><span class="line">dialogText.text = articyObject.TechnicalName;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">dialogText.text = target == <span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> : target.GetType().Name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">GetComponent&lt;RectTransform&gt;().sizeDelta = <span class="keyword">new</span> Vector2(GetComponent&lt;RectTransform&gt;().sizeDelta.x, dialogText.preferredHeight + <span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBranchSelected</span>()<span class="comment">//当按钮被触发时</span></span></span><br><span class="line">&#123;</span><br><span class="line">processor.Play(branch);<span class="comment">//流程播放器播放分支，进入下一条</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="脚本ArticyInitTrigger内容"><a href="#脚本ArticyInitTrigger内容" class="headerlink" title="脚本ArticyInitTrigger内容"></a>脚本ArticyInitTrigger内容</h3><ul><li><p>脚本功能介绍：这个脚本可有可无，主要在实现当某个游戏物体(特别是玩家)进入触发器时能够从头开始播放。</p></li><li><p><a href="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/tree/master/docs/ArticyToUnityTemplate/ArticyInitTrigger.cs">点击查看（如果点不开就复制下面的代码吧）</a></p></li><li><p>flowPlayer：所绑定的ArticyFlowPlayer播放器组件</p></li><li><p>tagConstraint：触发器检测到当拥有限制的标签的碰撞箱时，开始触发流程</p></li><li><p>isDestroyWhenPlayed：当流程结束时，是否删除这一切</p></li><li><p>onTriggered：当触发的那一瞬间所执行的委托</p></li><li><p>onFinished：当播放结束的那一瞬间所执行的委托</p></li></ul><img src="https://s2.loli.net/2023/04/23/hEiRzfUr8bDg6CW.png"  width="400"><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> Sirenix.OdinInspector;</span><br><span class="line"><span class="keyword">using</span> Articy;</span><br><span class="line"><span class="keyword">using</span> Articy.Unity;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ADTriggerEvent</span> : <span class="title">UnityEvent</span>&lt;<span class="title">string</span>&gt; &#123; &#125;<span class="comment">//AD触发器事件委托</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">RequireComponent(typeof(Collider))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ArticyInitTrigger</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">BoxGroup(<span class="string">&quot;组件信息&quot;</span>, true, true)</span>]</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">public</span> ArticyFlowPlayer flowPlayer;<span class="comment">//流程播放器</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">BoxGroup(<span class="string">&quot;流程信息&quot;</span>, true, true)</span>]</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">public</span> <span class="built_in">string</span> tagConstraint = <span class="string">&quot;Player&quot;</span>;<span class="comment">//标签限制</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">BoxGroup(<span class="string">&quot;流程信息&quot;</span>, true, true)</span>]</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">public</span> <span class="built_in">bool</span> isDestroyWhenPlayed;<span class="comment">//是否在流程播放完后删除</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">BoxGroup(<span class="string">&quot;流程委托&quot;</span>, true, true)</span>]</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">public</span> <span class="built_in">bool</span> useEventOnTriggered = <span class="literal">false</span>;<span class="comment">//是否使用触发时的委托</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">BoxGroup(<span class="string">&quot;流程委托&quot;</span>, true, true)</span>]</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">public</span> <span class="built_in">bool</span> useEventOnFinished = <span class="literal">false</span>;<span class="comment">//是否使用结束时的委托</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">BoxGroup(<span class="string">&quot;流程委托&quot;</span>, true, true), ShowIf(<span class="string">&quot;useEventOnTriggered&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">public</span> ADTriggerEvent onTriggered;<span class="comment">//触发时</span></span><br><span class="line"></span><br><span class="line">    [<span class="meta">BoxGroup(<span class="string">&quot;流程委托&quot;</span>, true, true), ShowIf(<span class="string">&quot;useEventOnFinished&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">public</span> ADTriggerEvent onFinished;<span class="comment">//结束时</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArticyFlowManager flowManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> tempIsPlay = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        flowManager = flowPlayer.GetComponent&lt;ArticyFlowManager&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempIsPlay == <span class="literal">true</span> &amp;&amp; flowManager.isPlaying == <span class="literal">false</span>)<span class="comment">//当两个数值不一样时</span></span><br><span class="line">        &#123;</span><br><span class="line">            OnFinished();</span><br><span class="line">        &#125;</span><br><span class="line">        tempIsPlay = flowManager.isPlaying;<span class="comment">//暂存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnFinished</span>()<span class="comment">//当结束时</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        onFinished.Invoke(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (isDestroyWhenPlayed) &#123; Destroy(gameObject); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.CompareTag(tagConstraint))<span class="comment">//如果是玩家</span></span><br><span class="line">        &#123;</span><br><span class="line">            flowPlayer.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">            flowPlayer.GetComponent&lt;ArticyFlowManager&gt;().JumpToStart();</span><br><span class="line">            onTriggered.Invoke(<span class="string">&quot;&quot;</span>);<span class="comment">//触发</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Animatext模板（有插件的情况下）"><a href="#Animatext模板（有插件的情况下）" class="headerlink" title="Animatext模板（有插件的情况下）"></a>Animatext模板（有插件的情况下）</h3><ul><li>在Project工程目录里右键新建Animatext Preset-&gt;Transition-Word-&gt;Step-&gt;01</li><li>如下图设置，并赋予给所有AnimatextTMProOld组件上。</li></ul><img src="https://s2.loli.net/2023/04/23/9wzsjOBNterHUp6.png"  width="400">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Articy-Draft-3-与-Unity&quot;&gt;&lt;a href=&quot;#Articy-Draft-3-与-Unity&quot; class=&quot;headerlink&quot; title=&quot;Articy Draft 3 与 Unity&quot;&gt;&lt;/a&gt;Articy Draft 3 与 Uni</summary>
      
    
    
    
    <category term="unity" scheme="http://iamsleepingnow.github.io/categories/unity/"/>
    
    
    <category term="unity" scheme="http://iamsleepingnow.github.io/tags/unity/"/>
    
    <category term="Articy Draft 3" scheme="http://iamsleepingnow.github.io/tags/Articy-Draft-3/"/>
    
  </entry>
  
  <entry>
    <title>如何在PS中使用DaVinci的LUT</title>
    <link href="http://iamsleepingnow.github.io/2022/03/03/Arts/%E5%A6%82%E4%BD%95%E5%9C%A8PS%E4%B8%AD%E4%BD%BF%E7%94%A8DaVinci%E7%9A%84LUT/"/>
    <id>http://iamsleepingnow.github.io/2022/03/03/Arts/%E5%A6%82%E4%BD%95%E5%9C%A8PS%E4%B8%AD%E4%BD%BF%E7%94%A8DaVinci%E7%9A%84LUT/</id>
    <published>2022-03-03T13:36:03.000Z</published>
    <updated>2022-03-03T13:38:35.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何在PS中使用DaVinci的LUT"><a href="#如何在PS中使用DaVinci的LUT" class="headerlink" title="如何在PS中使用DaVinci的LUT"></a>如何在PS中使用DaVinci的LUT</h1><h2 id="第一步：DaVinci导出LUT"><a href="#第一步：DaVinci导出LUT" class="headerlink" title="第一步：DaVinci导出LUT"></a>第一步：DaVinci导出LUT</h2><ul><li>达芬奇新建工程，导入素材，将素材拖到剪辑窗口中（略）</li><li>点击软件下方<code>调色</code>标签页转到调色区</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/gfx/How2UseDaVinciLUTinPS/How2UseDaVinciLUTinPS_001.png" width=200><ul><li>在右方的节点编辑器中选中此<code>矫正器</code>节点（*一个矫正器节点相当于一个调色流程模块，可以叠加。最左方的绿色圆点是数据输入端，最右方的是数据输出端，矫正器节点们需要与之相连）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/gfx/How2UseDaVinciLUTinPS/How2UseDaVinciLUTinPS_002.png" width=600><ul><li>使用你的无敌调色技巧或者从左方素材库拖拉LUT预设至矫正器节点，完成调色步骤（略）</li><li>点击软件右上方<code>片段</code>，在软件界面中央展开片段窗口</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/gfx/How2UseDaVinciLUTinPS/How2UseDaVinciLUTinPS_003.png" width=500><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/gfx/How2UseDaVinciLUTinPS/How2UseDaVinciLUTinPS_004.png" width=500><ul><li>右键点击红框中完成调色的视频片段，点击<code>生成LUT</code>，选择一个<code>Cube</code>类型的LUT</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/gfx/How2UseDaVinciLUTinPS/How2UseDaVinciLUTinPS_005.png" width=600><ul><li>将LUT导出成<code>.cube</code>类型的文件</li></ul><h2 id="第二步：PS应用LUT"><a href="#第二步：PS应用LUT" class="headerlink" title="第二步：PS应用LUT"></a>第二步：PS应用LUT</h2><ul><li><p>打开PS，导入素材图片（略）</p></li><li><p>打开<code>调整</code>工具栏（点击软件左上方<code>窗口</code>，勾选<code>调整</code>与<code>属性</code>），将<code>颜色查找</code>应用到图像</p></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/gfx/How2UseDaVinciLUTinPS/How2UseDaVinciLUTinPS_006.png" width=700><ul><li>在属性工具栏中勾选<code>3DLUT文件</code>，点击右方下拉菜单，选择<code>载入3DLUT...</code>，选择之前导出的LUT即可</li><li>完成</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何在PS中使用DaVinci的LUT&quot;&gt;&lt;a href=&quot;#如何在PS中使用DaVinci的LUT&quot; class=&quot;headerlink&quot; title=&quot;如何在PS中使用DaVinci的LUT&quot;&gt;&lt;/a&gt;如何在PS中使用DaVinci的LUT&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="技术美术" scheme="http://iamsleepingnow.github.io/categories/%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF/"/>
    
    
    <category term="调色" scheme="http://iamsleepingnow.github.io/tags/%E8%B0%83%E8%89%B2/"/>
    
    <category term="技术美术" scheme="http://iamsleepingnow.github.io/tags/%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF/"/>
    
    <category term="记录" scheme="http://iamsleepingnow.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Unity上道秘籍</title>
    <link href="http://iamsleepingnow.github.io/2022/01/10/Unity/Unity%E4%B8%8A%E9%81%93%E7%A7%98%E7%B1%8D/"/>
    <id>http://iamsleepingnow.github.io/2022/01/10/Unity/Unity%E4%B8%8A%E9%81%93%E7%A7%98%E7%B1%8D/</id>
    <published>2022-01-10T11:16:30.000Z</published>
    <updated>2022-01-10T11:57:36.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity上道秘籍"><a href="#Unity上道秘籍" class="headerlink" title="Unity上道秘籍"></a>Unity上道秘籍</h1><ul><li>本文仅用于理解Unity的基础代码运作逻辑</li><li>能让人快速入门Unity及Unity的编程</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_000.jpg" width=200><h2 id="🔥Unity的世界观"><a href="#🔥Unity的世界观" class="headerlink" title="🔥Unity的世界观"></a>🔥Unity的世界观</h2><ul><li>本节主要介绍Unity界面与基础脚本通信</li><li>提示：强烈建议使用英文编辑器！！</li></ul><h3 id="🚩界面介绍"><a href="#🚩界面介绍" class="headerlink" title="🚩界面介绍"></a>🚩界面介绍</h3><ul><li>默认你有一点点的C#基础，因为我也只会一点点的C#基础👍</li><li>下图是Unity新项目的界面<ul><li>Unity引擎界面由许多窗口构成，窗口能够互相吸附、打开关闭</li><li>两个窗口可以像网页标签一样重叠</li><li>标签右方带锁头的窗口可以被上锁，可以固定显示某个物体的状态</li><li>在标签栏里<code>Window</code>中可以调出所有的窗口，窗口都可以多开</li><li>恢复及设置窗口布局点击界面右上角<code>Layout</code></li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_001.png" width=750><h4 id="Scene场景窗口"><a href="#Scene场景窗口" class="headerlink" title="Scene场景窗口"></a>Scene场景窗口</h4><ul><li><code>Scene窗口</code>用于显示一个<code>场景文件Scene</code>里的所有内容</li><li><code>鼠标右键拖动</code>：以自身为基准旋转（忽略X轴旋转）</li><li><code>Alt + 鼠标左键拖动</code>：以视角中场景的中轴旋转（忽略X轴旋转）</li><li><code>鼠标中键拖动</code>：以固定比率移动自身</li><li><code>鼠标中键点击</code>：若点击至物体，视角会聚焦该物体，中键拖动所移动的比率会智能变化</li><li><code>鼠标滚轮</code>：推动视角纵深</li><li>使用<code>视角辅助器</code>能将视角转换为正视角和正交视图</li></ul><h4 id="Game游戏窗口"><a href="#Game游戏窗口" class="headerlink" title="Game游戏窗口"></a>Game游戏窗口</h4><ul><li><code>Game窗口</code>以列表的形式显示<code>Scene场景</code>中<code>摄像机组件</code>内的视图</li><li><code>Game窗口</code>左上角的<code>Display序数</code>必须与此时显示的摄像机相匹配</li><li><code>Display序数</code>选项旁可以设置<code>输出视角的分辨率</code></li><li><code>Maximize On Play全屏播放选项</code>若开启，运行游戏时会使<code>Game窗口</code>最大化</li></ul><h4 id="Hierarchy大纲"><a href="#Hierarchy大纲" class="headerlink" title="Hierarchy大纲"></a>Hierarchy大纲</h4><ul><li><code>Hierarchy窗口</code>用于显示<code>Scene场景</code>中所包含的所有游戏物体</li><li>在<code>Hierarchy窗口</code>中单击右键可以新建几乎所有的Unity预设物体</li><li>拖动窗口中的物体至另外的物体上，可以设置父子集关系</li><li>一般场景物体的图标和字体显示黑色，预制体的图标和字体显示蓝色</li><li><code>Hierarchy窗口</code>中预制体的右边显示箭头，可以将场景转换为预制体编辑模式</li><li>复制物体使用<code>ctrl + D</code>，删除物体使用<code>Delete</code></li><li>多选物体时，按<code>ctrl</code>键加选减选</li><li>连选物体时，先选择首物体，按<code>shift</code>键选择尾物体</li></ul><h4 id="Project项目文件"><a href="#Project项目文件" class="headerlink" title="Project项目文件"></a>Project项目文件</h4><ul><li><code>Project窗口</code>以列表的形式显示整个项目的所有资源文件</li><li>推荐使用文件夹分类的方式进行文件管理（右键-&gt;Create-&gt;Folder）</li><li>默认的<code>Project窗口</code>有<code>Assets</code>和<code>Packages</code>两个文件夹<ul><li>在<code>Assets</code>里放入项目的所有工程文件</li><li>在<code>Packages</code>里查看该项目所拥有的所有资源包</li></ul></li><li>复制文件使用<code>ctrl + D</code>，删除文件使用<code>Delete</code></li><li>多选文件时，按<code>ctrl</code>键加选减选</li><li>连选文件时，先选择首文件，按<code>shift</code>键选择尾文件</li></ul><h4 id="Inspector细节清单"><a href="#Inspector细节清单" class="headerlink" title="Inspector细节清单"></a>Inspector细节清单</h4><ul><li><code>Inspector窗口</code>用于显示在<code>Hierarchy窗口</code>或<code>Project窗口</code>中选择的物体的内部信息</li><li>如果选择<code>Hierarchy窗口</code>中物体：（拿场景中<code>Main Camera</code>举例）<ul><li>Inspector窗口中显示三个标题字体加粗的区块：<code>Transform</code>、<code>Camera</code>和<code>Audio Listener</code></li><li>这三个区块被称为<code>组件</code></li><li>所有<code>组件</code>之上，可以设置该物体的<code>Name名称</code>、<code>Tag标签</code>、<code>Layer层级</code>和<code>Static是否静态</code></li><li>所有<code>组件</code>之下，按钮<code>Add Component</code>可以为该物体添加新<code>组件</code></li><li>几乎任何物体都拥有<code>Transform组件</code></li></ul></li><li>如果选择<code>Project窗口</code>中文件：<ul><li>如果该文件是预制体，则会显示与选择<code>Hierarchy窗口</code>中物体的显示大致一致</li><li>如果该文件是C#脚本或其他文本文件，则会显示脚本文字的预览</li><li>其他文件都有其特殊的显示</li></ul></li></ul><h4 id="Console日志窗口"><a href="#Console日志窗口" class="headerlink" title="Console日志窗口"></a>Console日志窗口</h4><ul><li>通过标签栏-&gt;Window-&gt;General-&gt;Console或<code>Ctril + Shift + C</code>打开<code>Console窗口</code></li><li><code>Console窗口</code>用于显示游戏日志，包括游戏bug、警告及玩家测试语句</li></ul><hr><h3 id="🚩脚本功能"><a href="#🚩脚本功能" class="headerlink" title="🚩脚本功能"></a>🚩脚本功能</h3><ul><li>在Project窗口里新建文件夹用来装脚本</li></ul><h4 id="新建脚本"><a href="#新建脚本" class="headerlink" title="新建脚本"></a>新建脚本</h4><ul><li>在文件夹内右键-&gt;Create-&gt;C# Script来创建脚本，同时为脚本命名</li><li>如果不命名，默认名为<code>NewBehaviourScript</code>，同时不建议在<code>Project窗口</code>里改脚本名</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_002.png" width=350><ul><li>双击打开新建的脚本（默认下载了VisualStudio并安装了Unity依赖项）</li><li>新建的脚本如下：<ul><li>如果脚本类需要改名字，则需要保证脚本内类名与<code>Project窗口</code>中脚本文件名一致</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_003.png" width=550><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;<span class="comment">//引用非泛型集合</span></span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;<span class="comment">//引用泛型集合</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;<span class="comment">//引用Unity引擎依赖项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyScript_1</span> : <span class="title">MonoBehaviour</span><span class="comment">//继承自MonoBehaviour类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//Start方法只在游戏开始时第一帧执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//Update方法在游戏开始后每一帧执行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组件挂载"><a href="#组件挂载" class="headerlink" title="组件挂载"></a>组件挂载</h4><ul><li>继承自MonoBehaviour类的脚本属于<code>组件</code>脚本，可以挂载到任何游戏物体上来作为<code>组件</code><ul><li>保存脚本后，Unity会自动编译，同时引擎右下角会转圈</li><li>在<code>Hierarchy窗口</code>中右键新建一个<code>空物体</code>（Create Empty），命名为<code>GameObject_1</code></li><li>将<code>Project窗口</code>中<code>MyScript_1</code>脚本拖到此新建游戏物体的<code>Inspector窗口</code>下方空白处</li><li>于是<code>GameObject_1</code>物体就拥有了<code>MyScript_1</code>脚本<code>组件</code></li><li>右键组件标题栏-&gt;Remove Component用于移除该组件</li></ul></li><li>一个物体可以添加多个组件，组件与组件之间是平行关系，没有顺序限制</li><li>预制体也可以重载添加组件，但重载的组件不允许放置在已预置组件之前</li><li>物体身上的多个相同组件默认以放置的顺序来排序</li><li>如果组件拥有像<code>Start()</code>或<code>Update()</code>类似的线程函数，在<code>Inspector窗口</code>会显示对勾<ul><li><code>Inspector窗口</code>左上角的对勾用于控制该物体是否显示</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_004.png" width=750><h4 id="Mono类的生命周期"><a href="#Mono类的生命周期" class="headerlink" title="Mono类的生命周期"></a>Mono类的生命周期</h4><ul><li>在继承自MonoBehaviour类的脚本中，内置了许多线程函数，它们的调用拥有先后顺序（生命周期）<ul><li>官方绘制的周期图：<a href="https://docs.unity3d.com/uploads/Main/monobehaviour_flowchart.svg">网页</a></li><li>在下图（不完整）中，蓝色标注的是常用函数，粉色标注的是事件函数</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_005.png" width=250><hr><h3 id="🚩脚本通信"><a href="#🚩脚本通信" class="headerlink" title="🚩脚本通信"></a>🚩脚本通信</h3><ul><li>游戏是由许许多多逻辑回圈构成的，这种逻辑回圈被称为<code>系统</code><ul><li>如数值系统、动画系统、联机系统、界面系统等</li></ul></li><li>上述系统都属于功能较为完整单一的逻辑回圈，各司其职、相互访问数值，从而构成游戏</li><li>逻辑回圈中最重要的就是脚本通信</li><li>最基本的脚本通信逻辑即<code>获取（Get）</code>到其他脚本内部的数值，或直接<code>设置（Set）</code>它们</li></ul><h4 id="Get和Set"><a href="#Get和Set" class="headerlink" title="Get和Set"></a>Get和Set</h4><ul><li>Get和Set的来历：<ul><li>在类定义时，<code>私有private</code>或<code>受保护protected</code>的变量无法被外部脚本直接获取</li><li>这时就需要设置<code>公开public</code>成员函数来间接进行GetSet操作</li></ul></li></ul><h4 id="组件访问"><a href="#组件访问" class="headerlink" title="组件访问"></a>组件访问</h4><ul><li><p>在Unity中，对于相对静态的物体身上脚本组件的访问大致拥有几种类型：</p><ul><li><p>一：在Inspector窗口拖拽</p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_006.png" width=450></li><li><p>二：先获取物体，再获取脚本组件</p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_007.png" width=600><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_008.png" width=750></li></ul></li><li><p>如何查看组件的真实类名：</p><ul><li>在任何不熟悉的组件的标题栏上右键-&gt;如果没有<code>Edit Script</code>选项：<ul><li>此组件为Unity官方组件</li><li>此组件类的类名与该加粗标题名一致</li></ul></li><li>因<code>Camera</code>组件没有<code>Edit Script</code>选项，所以可判断该组件类名为<code>Camera</code></li><li>因<code>TextMeshPro-Text(UI)</code>组件有<code>Edit Script</code>选项，查看其类名为<code>TextMeshProUGUI</code></li></ul></li></ul><h4 id="物体组件访问函数"><a href="#物体组件访问函数" class="headerlink" title="物体组件访问函数"></a>物体组件访问函数</h4><ul><li>因为组件都是挂到物体上的，所以需要先获取物体，再获取其身上的组件</li><li>获取语句建议写在<code>Start()</code>方法里</li><li>获取物体的方法：<ul><li>直接搜索名字，但是需要保证没有重名物体<ul><li>GameObject GameObject.Find()</li></ul></li><li>将物体设置某个标签Tag，但是需要保证只有该物体有该标签<ul><li>GameObject GameObject.FindGameObjectWithTag()</li><li>GameObject[] GameObject.FindGameObjectsWithTag()</li><li>GameObject GameObject.FindWithTag()</li></ul></li></ul></li><li>获取物体中组件的方法：<ul><li>直接获取<ul><li>&lt;Template T&gt; T GetComponent&lt;T&gt;()</li><li>&lt;Template T&gt; T[] GetComponents&lt;T&gt;()</li></ul></li><li>通过父子物体获取<ul><li>Component Component.GetComponentInChildren()</li><li>Component[] Component.GetComponentsInChildren()</li><li>Component Component.GetComponentInParent()</li><li>Component[] Component.GetComponentsInParent()</li></ul></li></ul></li></ul><h4 id="参数的访问"><a href="#参数的访问" class="headerlink" title="参数的访问"></a>参数的访问</h4><ul><li><code>print()</code>和<code>Debug.Log()</code>一样，都是输出一条消息给<code>Console窗口</code></li><li>比如说要获取和控制摄像机组件身上的视场角<ul><li>需要先获取场景中的摄像机物体，这里使用拖拽的方法</li><li>查看摄像机组件里的参数<ul><li>注意，这里的参数是被<code>界面脚本</code>加工过的，有时与脚本内部值不匹配</li><li>建议到官网API或Manual上查询</li></ul></li><li>根据代码提示找到<code>cam.fieldOfView</code>接口</li><li>尝试GetSet</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_009.png" width=450><ul><li>保存代码，运行游戏，打开<code>Console窗口</code>查看数值波动</li><li>在运行过程中修改<code>MyScript_1</code>组件暴露的<code>fov</code>参数（拖拽）<ul><li><code>Game窗口</code>显示的视场发生了变化，<code>Camera</code>组件中<code>FieldOfView</code>参数动态参与改变</li></ul></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>以上即基础的参数访问，同时也实现了两个类（<code>Camera</code>与<code>MyScript_1</code>）之间的通信</li><li>使用代码分流（if-else/switch）及以上介绍的脚本通信，足以实现基础逻辑回圈制作</li><li>脚本通信是整个Unity学习的梗概，其他的东西其实都是万变不离其宗的</li></ul><hr><h2 id="🔥组件基础"><a href="#🔥组件基础" class="headerlink" title="🔥组件基础"></a>🔥组件基础</h2><ul><li>组件的访问是在获取到装载组件的物体后，对其物体使用<code>GetComponent&lt;组件类名&gt;()</code>模板函数</li><li>组件的添加是在物体上使用<code>gameObject.AddComponent&lt;组件类名&gt;()</code>模板函数</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_010.png" width=500><h2 id="🔥属性与参数暴露"><a href="#🔥属性与参数暴露" class="headerlink" title="🔥属性与参数暴露"></a>🔥属性与参数暴露</h2><h3 id="🚩常用访问修饰符"><a href="#🚩常用访问修饰符" class="headerlink" title="🚩常用访问修饰符"></a>🚩常用访问修饰符</h3><ul><li>public公开<ul><li>公开的属性能够被其他脚本所访问，并暴露在<code>Inspector面板</code>上</li></ul></li><li>private私有<ul><li>私有的属性只能在该脚本中访问（无修饰符变量默认是私有的）</li></ul></li><li>protected保护<ul><li>保护的属性只能在该脚本和继承该脚本的脚本所访问</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_011.png" width=250><hr><h3 id="🚩常用数值属性"><a href="#🚩常用数值属性" class="headerlink" title="🚩常用数值属性"></a>🚩常用数值属性</h3><ul><li><p>这些都是Unity自带的参数属性，如果对于检视面板美化感兴趣，可以查看另一篇讲<code>Odin</code>插件的文章</p></li><li><p>携带属性：<code>[RequireComponent(typeof(脚本类名))]</code></p><ul><li>修饰类的属性，可以使物体添加该脚本时强制添加某附着脚本</li><li>如果原先有该附着脚本，则锁定该附着脚本</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_012.png" width=400><ul><li>添加到组件工具集：<code>[AddComponentMenu(&quot;分栏名&quot;)]</code><ul><li>修饰类的属性，可以使该脚本添加到Unity的组件工具集中</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_013.png" width=500><ul><li>小标题：<code>[Header(&quot;标题名&quot;)]</code><ul><li>修饰变量的属性，为其修饰的public变量及以下变量添加小标题</li><li>该属性下的第一个变量一定得是public修饰变量</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_014.png" width=350><ul><li>可序列化和于细节面板隐藏：<code>[SerializeField]</code> &amp; <code>[HideInInspector]</code><ul><li><code>SerializeField</code>能无视private修饰，直接暴露到编辑器，见下图</li><li>但由于private的缘故，无法在其他脚本内被访问</li><li><code>HideInInspector</code>能将一切被修饰变量于细节面板隐藏，无视public</li><li>但由于public的缘故，还是能够在其他脚本内被访问</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_015.png" width=350><ul><li>文本区、空白区、数值范围：<code>[TextArea()]</code> &amp; <code>[space()]</code> &amp; <code>[Range()]</code><ul><li>TextArea提供一个比较大的范围的文本输入区，可以用于查看文字</li><li>需要填入最小和最大显示行数，超过最大行数会显示滚动条</li><li>TextArea于Multiline属性相似，都是拓展文本区</li><li>Space单纯就是空白</li><li>Range为数值类型提供了限制，需要输入最小值和最大值</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_016.png" width=350><ul><li>类序列化：<code>[System.Serializable]</code><ul><li>将类序列化成结构体，同样适用于结构体序列化</li><li>暴露在细节面板中是以下拉菜单的形式存在的</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_017.png" width=400><ul><li>小提示：<code>[Tooltip()]</code><ul><li>鼠标放在细节面板的变量上，会出现小提示</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_018.png" width=350><hr><h2 id="🔥预制体"><a href="#🔥预制体" class="headerlink" title="🔥预制体"></a>🔥预制体</h2><ul><li>类似于虚幻的蓝图类，但是Unity的预制体内容较为单薄</li><li>预制体就是预先设计好的，存储成文件的，允许携带层级关系的一套物件单例</li></ul><h3 id="🚩预制体制作"><a href="#🚩预制体制作" class="headerlink" title="🚩预制体制作"></a>🚩预制体制作</h3><ul><li>将<code>Hierarchy大纲</code>里的单个物体或物体父级拖入<code>Project项目文件</code>窗口中，即可创建</li><li>只有在<code>Project窗口</code>中的才是预制体，<code>Hierarchy窗口</code>里的是预制体实例</li><li>删除预制体实例，预制体不会受影响；删除预制体，预制体实例会失联</li><li>修改预制体参数，预制体实例内的参数也会发生改变</li><li>右键预制体实例选择<code>Break Prefab</code>，即可与预制体断开连接，使实例变为普通场景物体</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_019.png" width=500><h3 id="🚩预制体实例化"><a href="#🚩预制体实例化" class="headerlink" title="🚩预制体实例化"></a>🚩预制体实例化</h3><ul><li>预制体属于文件，同样也属于物体，同样可以通过GameObject类型来获取</li><li>使用<code>GameObject.Instantiate()</code>方法在游戏一开始生成预制体实例</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_020.png" width=450><hr><h2 id="🔥方位运动"><a href="#🔥方位运动" class="headerlink" title="🔥方位运动"></a>🔥方位运动</h2><h3 id="🚩DeltaTime秒每帧"><a href="#🚩DeltaTime秒每帧" class="headerlink" title="🚩DeltaTime秒每帧"></a>🚩DeltaTime秒每帧</h3><ul><li>如果要在游戏中控制人物的移动，实现逻辑是在<code>Update()</code>方法里每帧对人物方位进行修改</li><li>假设说玩家的速度很快，达到了惊人的1米/帧</li><li>玩家的电脑性能很好，帧速率（每秒刷新次数）达到了惊人的60帧/秒</li><li>通过计算，这位玩家1秒钟就能前进60米</li><li>另一个玩家电脑性能很烂，帧速率（每秒刷新次数）达到了20帧/秒</li><li>通过计算，这位玩家1秒钟才能前进20米</li><li>在游戏人物速度一致的情况下，仅通过电脑性能就能使两个联机的玩家在速度上拉开差距</li><li>这是不可取的，所以要引入秒每帧（增量时间）<code>DeltaTime</code>的概念</li><li>尝试使用1去除帧速率，60帧/秒的玩家的增量时间为1/60，20帧/秒的玩家为1/20</li><li>然后在玩家速度上乘以这个变量</li><li>60帧/秒的玩家最终速度为60*(1/60)=1米/秒，1秒钟前进1米</li><li>20帧/秒的玩家最终速度为20*(1/20)=1米/秒，1秒钟前进1米</li><li>虽然速度大幅下降，但是两位玩家达成了速度的归一化，排除了硬件影响</li><li>所以说，DeltaTime拯救了高ping玩家</li><li>在Unity里，使用<code>Time.deltaTime</code>来获取增量时间</li></ul><hr><h3 id="🚩移动旋转缩放"><a href="#🚩移动旋转缩放" class="headerlink" title="🚩移动旋转缩放"></a>🚩移动旋转缩放</h3><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_021.png" width=550><ul><li>一般情况下，需要乘上速度和增量时间</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_022.png" width=650><hr><h2 id="🔥输入事件"><a href="#🔥输入事件" class="headerlink" title="🔥输入事件"></a>🔥输入事件</h2><ul><li>输入由<code>Input</code>接口去管理</li><li>主要有以下几种输入事件：</li></ul><h3 id="🚩鼠标事件"><a href="#🚩鼠标事件" class="headerlink" title="🚩鼠标事件"></a>🚩鼠标事件</h3><ul><li>Input.GetMouseButton()    鼠标持续按下状态</li><li>Input.GetMouseButtonDown()    鼠标按下状态</li><li>Input.GetMouseButtonUp()    鼠标抬起状态</li><li>Input.MousePosition    鼠标位置</li><li>Input.mouseScrollDelta    鼠标滚轮状态</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_023.png" width=550><hr><h3 id="🚩键盘事件"><a href="#🚩键盘事件" class="headerlink" title="🚩键盘事件"></a>🚩键盘事件</h3><ul><li>Input.GetKey()    键盘持续按下状态</li><li>Input.GetKeyDown()    键盘按下状态</li><li>Input.GetKeyUp()    键盘抬起状态</li><li>Input.anyKey    任意键持续按下状态</li><li>Input.anyKeyDown    任意键按下状态</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_024.png" width=550><hr><h3 id="🚩轴事件"><a href="#🚩轴事件" class="headerlink" title="🚩轴事件"></a>🚩轴事件</h3><ul><li>在Unity的Project Settings项目设置窗口里的Input Manager设置按键轴参数</li><li>通过轴名称的字符串来获取轴按键输入</li><li>里面的参数自行翻译，没什么好说的</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_025.png" width=650><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_026.png" width=650><ul><li>Input.GetAxis()    获取轴输入，返回浮点值</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_027.png" width=450><hr><h3 id="🚩轴按键事件"><a href="#🚩轴按键事件" class="headerlink" title="🚩轴按键事件"></a>🚩轴按键事件</h3><ul><li><p>轴输入获取的是轴的数值状态</p></li><li><p>要获取Input Manager里自定义按键的按钮事件，就得使用按键事件</p></li><li><p>Input.GetButton()    按键持续按下状态</p></li><li><p>Input.GetButtonDown()    按键按下状态</p></li><li><p>Input.GetButtonUp()    按键抬起状态</p></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_028.png" width=450><hr><h3 id="🚩手柄事件"><a href="#🚩手柄事件" class="headerlink" title="🚩手柄事件"></a>🚩手柄事件</h3><ul><li>手柄输入分为手柄按键和手柄轴两个部分：<ul><li>手柄按键：Input.GetKey/Down/Up(KeyCode.JoystickButton1~19)</li><li>手柄输入：Input.GetAxis()</li></ul></li><li>手柄按键输入具体要按照手柄品牌和型号而定，下图是Xbox版本</li><li>手柄输入需要在Project Settings里设置，主要设置：<ul><li><code>Dead</code>忽视阈值，输入不达阈值则看作没输入</li><li><code>Sensitivity</code>灵敏度，轴返回值是-1~1之间的数，再乘上灵敏度</li><li><code>Invert</code>是否翻转轴</li><li><code>Axis</code>具体哪个轴，见下图所示</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_029.png" width=450><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_030.png" width=500><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_031.png" width=500><hr><h2 id="🔥接触事件"><a href="#🔥接触事件" class="headerlink" title="🔥接触事件"></a>🔥接触事件</h2><ul><li>在场景里新建一个<code>Cube方块</code>，在Inspector面板里可以看到<code>BoxCollider箱体碰撞箱</code>组件</li><li>碰撞和触发事件就是通过此组件进行的</li><li>将我们的脚本<code>MyScript_1</code>附着在此方块上</li><li>接触事件都有2d和3d两个版本</li></ul><h3 id="🚩碰撞事件"><a href="#🚩碰撞事件" class="headerlink" title="🚩碰撞事件"></a>🚩碰撞事件</h3><ul><li>碰撞事件产生的前提条件是碰撞的双方至少有一方拥有<code>刚体Rigidbody</code>组件</li><li>产生碰撞事件需要将<code>BoxCollider</code>组件上的<code>is Trigger</code>取消勾选</li><li>碰撞事件与初始化、更新事件同级，都属于事件方法</li><li>当物体产生碰撞时会自动调用碰撞方法，并返回<code>Collision</code>类型的参数</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_032.png" width=400><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_033.png" width=600><hr><h3 id="🚩碰撞层级"><a href="#🚩碰撞层级" class="headerlink" title="🚩碰撞层级"></a>🚩碰撞层级</h3><ul><li>在<code>Project Settings</code>里找到<code>Tags and Layers</code>，添加两个自定义层级</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_034.png" width=500><ul><li>将两个需要碰撞的物体分别设置成不同的碰撞层</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_035.png" width=400><ul><li>别忘了碰撞箱组件和刚体组件</li><li>在<code>Project Settings</code>里找到<code>Physics</code>，翻到最底下的<code>Layer Collision Matrix</code></li><li>横轴纵轴之间交叉的勾选框即代表两个层级的物体之间是否能够发生碰撞</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_036.png" width=500><hr><h3 id="🚩触发事件"><a href="#🚩触发事件" class="headerlink" title="🚩触发事件"></a>🚩触发事件</h3><ul><li><p>触发事件产生的前提条件同样是是触发的双方至少有一方拥有<code>刚体Rigidbody</code>组件</p></li><li><p>与碰撞事件类似，触发事件只需将需要检测触发的BoxCollider组件的is Trigger勾选上即可</p></li><li><p>任何一方勾选is Trigger都可以触发触发事件</p></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_037.png" width=600><hr><h2 id="🔥射线检测"><a href="#🔥射线检测" class="headerlink" title="🔥射线检测"></a>🔥射线检测</h2><ul><li>射线检测就是从一个点到另一个点之间拉一条红外线，经过的物体会触发射线检测</li></ul><h3 id="🚩直线射线检测"><a href="#🚩直线射线检测" class="headerlink" title="🚩直线射线检测"></a>🚩直线射线检测</h3><ul><li>最简单的射线检测</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_038.png" width=750><ul><li>对射线做出一些限制，射线检测允许使用物体层级来区分</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_039.png" width=800><ul><li>如何检测一堆物体</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_040.png" width=750><hr><h3 id="🚩圆弧射线检测"><a href="#🚩圆弧射线检测" class="headerlink" title="🚩圆弧射线检测"></a>🚩圆弧射线检测</h3><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_041.png" width=550><hr><h2 id="🔥物理运算"><a href="#🔥物理运算" class="headerlink" title="🔥物理运算"></a>🔥物理运算</h2><h3 id="🚩刚体"><a href="#🚩刚体" class="headerlink" title="🚩刚体"></a>🚩刚体</h3><ul><li>Unity的绝大多数物理运算都与刚体组件<code>Rigidbody</code>有关</li><li>作为引导类的文章，只介绍为什么要使用刚体，以及一些基础操作</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_042.png" width=500><ul><li>在之前的碰撞检测里面以及提及了刚体在碰撞事件中的作用，所以只需要简要介绍一下其他内容：<ul><li>Mass：质量，质量越大惯性越大，推动它也需要更多的力</li><li>Drag：阻力，移动时，物体会受到一种类似空气阻力的反作用力</li><li>Angular Drag：旋转阻力，旋转时所受到的阻力</li><li>Use Gravity：是否开启重力，不开启重力会失重，凡受力之后会永远匀速运动下去</li><li>Is Kinematic：是否开启动力学，不开启时不会受力移动，适合用于一些特殊情况</li><li>Constraints：限制，允许冻结移动或旋转的轴向</li></ul></li></ul><hr><h2 id="🔥界面绑定"><a href="#🔥界面绑定" class="headerlink" title="🔥界面绑定"></a>🔥界面绑定</h2><ul><li>Unity里的界面是使用一种与三维共存的方式来运行的，在使用界面之前，需要在<code>Hierarchy大纲</code>里右键新建一个<code>Canvas</code>画布，同时会创建一个<code>EventSystem</code>物体，用来管理控制行为</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_043.png" width=350><ul><li>右键<code>Canvas</code>创建的一切物体都隐藏了其<code>Transform</code>组件，取而代之的是<code>RectTransform</code>组件</li><li>双击<code>Canvas</code>让视图居中，点击<code>Scene窗口</code>左上方的<code>2D视图按钮</code>，用来方便查看</li><li><code>Pos X</code>和<code>Pos Y</code>都指的是屏幕坐标，如果<code>Game窗口</code>里定义的大小是<code>1920*1080像素</code>，那么如果想要将物体贴于屏幕右上角，它的坐标就会是<code>（960，540）</code>，因为坐标原点是屏幕中心</li><li><code>width</code>和<code>height</code>是图像宽和高，单位像素</li><li><code>Anchors</code>是物体锚点，位于0到1之间，锚点用来规定图像的延展区间，以防由于输出分辨率的变化，界面元素显示错误的问题</li><li>锚点的用处在于：无论分辨率如何，物体与锚点之间的距离恒定</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_044.png" width=450><ul><li>点击组件左上角的锚点预设图标，允许选取锚点预设</li><li>锚点预设能将物体锚点设置在屏幕的多个位置，但不会修改物体的实际位置</li><li>在选取锚点预设时按住<code>alt</code>键，就能在修改锚点的时候修改物体位置</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_045.png" width=450><h3 id="🚩编码提示"><a href="#🚩编码提示" class="headerlink" title="🚩编码提示"></a>🚩编码提示</h3><ul><li><p>在使用Unity的界面之前，需要做上引用：<code>using UnityEngine.UI;</code></p></li><li><p>最常见的界面元素是文本，也就是<code>Text组件</code>，在代码中获取组件后，便可以修改其中<code>text</code>参数，也就是显示的文本了</p></li><li><p>图像是<code>Image组件</code>，其中图像参数是<code>sprite</code></p></li><li><p>单选框是<code>Toggle组件</code>，其中是否开启参数是<code>isOn</code></p></li><li><p>滑动条是<code>Slider组件</code>，其中滑动数值参数是<code>value</code></p></li></ul><hr><h3 id="🚩按钮与事件绑定"><a href="#🚩按钮与事件绑定" class="headerlink" title="🚩按钮与事件绑定"></a>🚩按钮与事件绑定</h3><ul><li>按钮是<code>Button组件</code>，组件最下方有一个<code>OnClick()</code>点击事件接口，点击右下方的加号用来添加函数槽</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_046.png" width=450><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_047.png" width=350><hr><h2 id="🔥美术与程序"><a href="#🔥美术与程序" class="headerlink" title="🔥美术与程序"></a>🔥美术与程序</h2><ul><li>因为美术的知识太繁杂，也不好描述，这里只讲美术与程序之间的调用</li></ul><h3 id="🚩材质与默认着色器"><a href="#🚩材质与默认着色器" class="headerlink" title="🚩材质与默认着色器"></a>🚩材质与默认着色器</h3><ul><li><p><code>着色器Shader</code>是<code>材质Material</code>的爹，一个着色器可以拥有多个材质的实例，着色器控制材质的渲染方法与参数，着色器就是材质的源码，在Unity里，官方提供了一个叫<code>Standard Shader</code>的基础着色器</p></li><li><p>将材质拖给任何携带类似<code>Renderer</code>组件的物体时，能够直接赋予上去</p></li><li><p>在Project窗口里右键新建一个材质，在<code>Inspector窗口</code>中是这样显示的</p></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_048.png" width=450><ul><li>右键<code>Inspector窗口</code>中的第一栏，选择<code>Select Shader</code>用来查看默认着色器参数</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_049.png" width=450><ul><li>在<code>Properties</code>下面，左边一栏是参数在其源码中的名称，意思是，如果在代码里调用着色器参数，只能调用这种名称</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_050.png" width=450><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_051.png" width=550><hr><h3 id="🚩粒子"><a href="#🚩粒子" class="headerlink" title="🚩粒子"></a>🚩粒子</h3><ul><li>在<code>Hierarchy窗口</code>里右键新建<code>Effects-&gt;ParticleSystem</code>创建粒子系统</li><li>其中<code>Play On Awake</code>是是否在启动时运行</li><li>太多了，这些东西需要上手去实操，其他的有时间再聊</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_052.png" width=550><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_053.png" width=300><hr><h2 id="🔥数据持久化"><a href="#🔥数据持久化" class="headerlink" title="🔥数据持久化"></a>🔥数据持久化</h2><ul><li>数据持久化就是存档，游戏不能没有存档</li><li>除了Unity自带的<code>PlayerPrefs</code>方法，还有<code>Json</code>、<code>XML</code>、<code>bit</code>等方法也能更好的存档</li></ul><h3 id="🚩PlayerPrefs"><a href="#🚩PlayerPrefs" class="headerlink" title="🚩PlayerPrefs"></a>🚩PlayerPrefs</h3><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_054.png" width=650><hr><h2 id="🔥场景跳转与退出"><a href="#🔥场景跳转与退出" class="headerlink" title="🔥场景跳转与退出"></a>🔥场景跳转与退出</h2><ul><li>点击工具栏的<code>File-&gt;BuildSettings</code>，查看游戏构建设置</li><li>将需要参与场景跳转的所有场景（就是最终输出的游戏场景）拖入<code>Scenes In Build</code>栏位里</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_055.png" width=650><ul><li>在代码中需要引用<code>using UnityEngine.SceneManagement;</code></li><li>代码比较简单</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/Unity/howToUseUnity/Unity_056.png" width=450><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity上道秘籍&quot;&gt;&lt;a href=&quot;#Unity上道秘籍&quot; class=&quot;headerlink&quot; title=&quot;Unity上道秘籍&quot;&gt;&lt;/a&gt;Unity上道秘籍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;本文仅用于理解Unity的基础代码运作逻辑&lt;/li&gt;
&lt;li&gt;能让人快速</summary>
      
    
    
    
    <category term="unity" scheme="http://iamsleepingnow.github.io/categories/unity/"/>
    
    
    <category term="多图预警" scheme="http://iamsleepingnow.github.io/tags/%E5%A4%9A%E5%9B%BE%E9%A2%84%E8%AD%A6/"/>
    
    <category term="教程" scheme="http://iamsleepingnow.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="unity" scheme="http://iamsleepingnow.github.io/tags/unity/"/>
    
    <category term="长文" scheme="http://iamsleepingnow.github.io/tags/%E9%95%BF%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Unity插件Odin简要入门</title>
    <link href="http://iamsleepingnow.github.io/2022/01/09/Unity/Unity%E6%8F%92%E4%BB%B6Odin%E7%AE%80%E8%A6%81%E5%85%A5%E9%97%A8/"/>
    <id>http://iamsleepingnow.github.io/2022/01/09/Unity/Unity%E6%8F%92%E4%BB%B6Odin%E7%AE%80%E8%A6%81%E5%85%A5%E9%97%A8/</id>
    <published>2022-01-09T09:46:20.000Z</published>
    <updated>2022-01-09T09:50:34.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity插件Odin简要入门"><a href="#Unity插件Odin简要入门" class="headerlink" title="Unity插件Odin简要入门"></a>Unity插件Odin简要入门</h1><ul><li>这几天我把Odin在Unity商城里半价买了下来，Odin真是香的一</li><li>有感而发，做出了这么一个入门教程</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_001.jpg" width=400><h2 id="一：介绍"><a href="#一：介绍" class="headerlink" title="一：介绍"></a>一：介绍</h2><ul><li>Odin是一个专门用来美化Unity的检视面板的API类插件</li><li>Odin主要是拓展了Unity里的Object的参数属性标签，例如原版的<code>[SerializeField]</code></li></ul><h2 id="二：注意事项"><a href="#二：注意事项" class="headerlink" title="二：注意事项"></a>二：注意事项</h2><ul><li>先创建一个脚本做演示，然后将此脚本挂载到某场景物体上</li><li>在调用之前，需要做引用<code>using Sirenix.OdinInspector;</code></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_002.png" width=350><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_003.png" width=400><ul><li>点击工具栏里的<code>Tools -&gt; Odin Inspector -&gt; Attribute Overview</code>可以查看Unity内嵌教程</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_004.png" width=400><h2 id="三：常用功能"><a href="#三：常用功能" class="headerlink" title="三：常用功能"></a>三：常用功能</h2><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p><code>[GUIColor()]</code>——对界面的颜色进行修改</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">GUIColor(1.0f, 0.3f, 0.6f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_1 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_005.png" width=350><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><code>[Title()]</code>——在下列参数之前做标题提示</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Title(<span class="string">&quot;Title One&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_1 = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">[<span class="meta">Title(<span class="string">&quot;Title Two&quot;</span>, <span class="string">&quot;Lil Title One&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_2 = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">[<span class="meta">Title(<span class="string">&quot;Title Three&quot;</span>, <span class="string">&quot;Lil Title One&quot;</span>, TitleAlignments.Centered)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_3 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_006.png" width=350><h3 id="只读"><a href="#只读" class="headerlink" title="只读"></a>只读</h3><p><code>[ReadOnly]</code>——在检视面板里显示，但是不能修改</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ReadOnly</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_1 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_007.png" width=350><h3 id="数值规范化"><a href="#数值规范化" class="headerlink" title="数值规范化"></a>数值规范化</h3><p><code>[ValueDropdown()]</code>——规定某数值只能选取某静态数组或枚举数中规定的数值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ValueDropdown(<span class="string">&quot;ValueGroup_1&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_1;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ValueDropdown(<span class="string">&quot;ValueGroup_2&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span>[] ValueGroup_1 = <span class="keyword">new</span> <span class="built_in">int</span>[] </span><br><span class="line">&#123; </span><br><span class="line">    <span class="number">256</span>, </span><br><span class="line">    <span class="number">512</span>, </span><br><span class="line">    <span class="number">1024</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> IEnumerable ValueGroup_2 = <span class="keyword">new</span> ValueDropdownList&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="string">&quot;Small&quot;</span>, <span class="number">256</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;Medium&quot;</span>, <span class="number">512</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;Large&quot;</span>, <span class="number">1024</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_008.png" width=350><h3 id="预制体与场景物体限定"><a href="#预制体与场景物体限定" class="headerlink" title="预制体与场景物体限定"></a>预制体与场景物体限定</h3><p><code>[AssetsOnly]</code>——只允许拖入预制体</p><p><code>[SceneObjectsOnly]</code>——只允许拖入场景物体</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AssetsOnly</span>]</span><br><span class="line"><span class="keyword">public</span> GameObject myGO_1;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SceneObjectsOnly</span>]</span><br><span class="line"><span class="keyword">public</span> GameObject myGO_2;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_009.png" width=350><h3 id="隐藏标签"><a href="#隐藏标签" class="headerlink" title="隐藏标签"></a>隐藏标签</h3><p><code>[HideLabel]</code>——隐藏参数的外部描述标签</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HideLabel</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_1;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_010.png" width=350><h3 id="标签文字修改"><a href="#标签文字修改" class="headerlink" title="标签文字修改"></a>标签文字修改</h3><p><code>[LabelText()]</code>——修改参数的标签文字</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">LabelText(<span class="string">&quot;我的整数&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_1;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_011.png" width=350><h3 id="标签文字长度"><a href="#标签文字长度" class="headerlink" title="标签文字长度"></a>标签文字长度</h3><p><code>[LabelWidth()]</code>——修改参数的标签文字长度</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">LabelWidth(250)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_1;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_012.png" width=350><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p><code>[InfoBox()]</code>——在参数前添加一个提示框</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">InfoBox(<span class="string">&quot;提示&quot;</span>, InfoMessageType.Info)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_1;</span><br><span class="line"></span><br><span class="line">[<span class="meta">InfoBox(<span class="string">&quot;警告&quot;</span>, InfoMessageType.Warning)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_2;</span><br><span class="line"></span><br><span class="line">[<span class="meta">InfoBox(<span class="string">&quot;报错&quot;</span>, InfoMessageType.Error)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_3;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_013.png" width=350><h3 id="值修改事件"><a href="#值修改事件" class="headerlink" title="值修改事件"></a>值修改事件</h3><p><code>[OnValueChanged()]</code>——当参数被修改时，触发一个函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">OnValueChanged(<span class="string">&quot;On_myInt_1_Changed&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">On_myInt_1_Changed</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;值被修改&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_014.png" width=350><h3 id="内联标签"><a href="#内联标签" class="headerlink" title="内联标签"></a>内联标签</h3><p><code>[SuffixLabel()]</code>——在参数行的末尾显示一个子标签，通常是注释或者是单位提示</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SuffixLabel(<span class="string">&quot;内部标签&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_1;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SuffixLabel(<span class="string">&quot;内部标签&quot;</span>, Overlay = true)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_2;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SuffixLabel(<span class="string">&quot;$myInt_3&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_3;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_015.png" width=350><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p><code>[Button()]</code>——修饰一个函数，将其暴露成按钮</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Button(<span class="string">&quot;按钮&quot;</span>, ButtonSizes.Large)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Slot_MyButton</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;触发按钮&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_016.png" width=350><h2 id="四：打组"><a href="#四：打组" class="headerlink" title="四：打组"></a>四：打组</h2><h3 id="盒型组"><a href="#盒型组" class="headerlink" title="盒型组"></a>盒型组</h3><p><code>[BoxGroup()]</code>——使用相同名称可以隶属于同一盒型组</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">BoxGroup(<span class="string">&quot;组1&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_1;</span><br><span class="line"></span><br><span class="line">[<span class="meta">BoxGroup(<span class="string">&quot;组1&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_2;</span><br><span class="line"></span><br><span class="line">[<span class="meta">BoxGroup(<span class="string">&quot;组2&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_3;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_017.png" width=350><h3 id="按钮组"><a href="#按钮组" class="headerlink" title="按钮组"></a>按钮组</h3><p><code>[ButtonGroup()]</code>——将多个按钮限制到同一排，根据名称不同可以放在不同排</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ButtonGroup(<span class="string">&quot;ButtonGroup1&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">Button(<span class="string">&quot;按钮1&quot;</span>, ButtonSizes.Large)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Slot_MyButton1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;触发按钮1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ButtonGroup(<span class="string">&quot;ButtonGroup1&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">Button(<span class="string">&quot;按钮2&quot;</span>, ButtonSizes.Large)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Slot_MyButton2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;触发按钮2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_018.png" width=350><h3 id="折页组"><a href="#折页组" class="headerlink" title="折页组"></a>折页组</h3><p><code>[FoldoutGroup()]</code>——使用相同名称可以隶属于同一折页组，提供折页功能</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">FoldoutGroup(<span class="string">&quot;组1&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_1;</span><br><span class="line"></span><br><span class="line">[<span class="meta">FoldoutGroup(<span class="string">&quot;组1&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_2;</span><br><span class="line"></span><br><span class="line">[<span class="meta">FoldoutGroup(<span class="string">&quot;组2&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_3;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_019.png" width=350><h3 id="横排组"><a href="#横排组" class="headerlink" title="横排组"></a>横排组</h3><p><code>[HorizontalGroup()]</code>——使用相同名称可以隶属于同一横排组</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HorizontalGroup(<span class="string">&quot;组1&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_1;</span><br><span class="line"></span><br><span class="line">[<span class="meta">HorizontalGroup(<span class="string">&quot;组1&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_2;</span><br><span class="line"></span><br><span class="line">[<span class="meta">HorizontalGroup(<span class="string">&quot;组2&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_3;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_020.png" width=350><h3 id="页面组"><a href="#页面组" class="headerlink" title="页面组"></a>页面组</h3><p><code>[TabGroup()]</code>——使用相同名称可以隶属于同一页面组，提供翻页功能</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TabGroup(<span class="string">&quot;组1&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_1;</span><br><span class="line"></span><br><span class="line">[<span class="meta">TabGroup(<span class="string">&quot;组1&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_2;</span><br><span class="line"></span><br><span class="line">[<span class="meta">TabGroup(<span class="string">&quot;组2&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_3;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_021.png" width=350><h3 id="勾选组"><a href="#勾选组" class="headerlink" title="勾选组"></a>勾选组</h3><p><code>[ToggleGroup()]</code>——使用相同名称可以隶属于同一勾选组，同一个勾选组绑定一个布尔值来控制只读</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ToggleGroup(<span class="string">&quot;toggle_1&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> toggle_1;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ToggleGroup(<span class="string">&quot;toggle_1&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_1;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ToggleGroup(<span class="string">&quot;toggle_1&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_2;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ToggleGroup(<span class="string">&quot;toggle_2&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> toggle_2;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ToggleGroup(<span class="string">&quot;toggle_2&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_3;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_022.png" width=350><h3 id="条件组"><a href="#条件组" class="headerlink" title="条件组"></a>条件组</h3><p><code>[ShowIfGroup()]</code>——使用相同名称可以隶属于同一条件组，同一个条件组绑定一个布尔值来控制显示</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> toggle_1;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ShowIfGroup(<span class="string">&quot;toggle_1&quot;</span>), BoxGroup(<span class="string">&quot;toggle_1/组1&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_1;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ShowIfGroup(<span class="string">&quot;toggle_1&quot;</span>), BoxGroup(<span class="string">&quot;toggle_1/组1&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> toggle_2;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ShowIfGroup(<span class="string">&quot;toggle_2&quot;</span>), BoxGroup(<span class="string">&quot;toggle_2/组2&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_3;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_023.png" width=350><h2 id="五：特定数值类型"><a href="#五：特定数值类型" class="headerlink" title="五：特定数值类型"></a>五：特定数值类型</h2><h3 id="数值大小限制"><a href="#数值大小限制" class="headerlink" title="数值大小限制"></a>数值大小限制</h3><p><code>[MinValue]</code>——最小值限定</p><p><code>[MaxValue]</code>——最大值限定</p><p><code>[MinMaxSlider]</code>——通过最小值与最大值限定的方式来限定二维向量，不能精准修改浮点</p><p><code>[Wrap]</code>——最小值与最大值相连</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MinValue(20), MaxValue(30)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_1;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MinMaxSlider(20, 30)</span>]</span><br><span class="line"><span class="keyword">public</span> Vector2Int myVector2Int_1;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MinMaxSlider(20.0f, 30.0f)</span>]</span><br><span class="line"><span class="keyword">public</span> Vector2 myVector2_1;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Wrap(0f, 10f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> myFloat_1;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_024.png" width=350><h3 id="滑动条"><a href="#滑动条" class="headerlink" title="滑动条"></a>滑动条</h3><p><code>[ProgressBar()]</code>——将数字转化成滑动条输入</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ProgressBar(0, 100, r:1.0f, g:0.2f, b:0.6f, Height=20)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_1;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ProgressBar(0, 10, Segmented=true)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> myInt_2;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_025.png" width=350><h3 id="调色板"><a href="#调色板" class="headerlink" title="调色板"></a>调色板</h3><ul><li>点击工具栏里的<code>Tools -&gt; Odin Inspector -&gt; Preferences -&gt; Color Palettes</code>可以查看调色板配置文件</li></ul><p><code>[ColorPalette()]</code>——使用调色板来快捷选择颜色</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ColorPalette</span>]</span><br><span class="line"><span class="keyword">public</span> Color myColor_1;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_026.png" width=350><h3 id="仅显示文字"><a href="#仅显示文字" class="headerlink" title="仅显示文字"></a>仅显示文字</h3><p><code>[DisplayAsString]</code>——将文字直截了当地显示在检视面板里</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DisplayAsString, HideLabel</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> myString_1 = <span class="string">&quot;这是一段文字。&quot;</span>;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_027.png" width=350><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p><code>[EnumPaging]</code>——提供枚举类型的一些辅助按钮</p><p><code>[EnumToggleButtons]</code>——使用按钮组的方式来显示枚举数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">EnumPaging</span>]</span><br><span class="line"><span class="keyword">public</span> MyEnum myEnum_1;</span><br><span class="line"></span><br><span class="line">[<span class="meta">EnumToggleButtons</span>]</span><br><span class="line"><span class="keyword">public</span> MyEnum myEnum_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> MyEnum</span><br><span class="line">&#123;</span><br><span class="line">    First, </span><br><span class="line">    Second, </span><br><span class="line">    Third</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_028.png" width=350><h3 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h3><p><code>[FilePath]</code>——提供文件路径搜索按钮</p><p><code>[FolderPath]</code>——提供文件夹路径搜索按钮</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">FilePath</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> myString_1;</span><br><span class="line"></span><br><span class="line">[<span class="meta">FilePath(ParentFolder = <span class="string">&quot;Assets/Resources&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> myString_2;</span><br><span class="line"></span><br><span class="line">[<span class="meta">FilePath(ParentFolder = <span class="string">&quot;Assets/Resources&quot;</span>, AbsolutePath = true)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> myString_3;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_029.png" width=350><h3 id="预览区"><a href="#预览区" class="headerlink" title="预览区"></a>预览区</h3><p><code>[PreviewField]</code>——创建物体预览区</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">PreviewField</span>]</span><br><span class="line"><span class="keyword">public</span> Object myObject_1;</span><br><span class="line"></span><br><span class="line">[<span class="meta">VerticalGroup(<span class="string">&quot;VG_1/HG_1&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> A, B, C;</span><br><span class="line"></span><br><span class="line">[<span class="meta">PreviewField(50, ObjectFieldAlignment.Right), HideLabel</span>]</span><br><span class="line">[<span class="meta">HorizontalGroup(<span class="string">&quot;VG_1&quot;</span>, 50), VerticalGroup(<span class="string">&quot;VG_1/HG_2&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> Object myObject_2;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/UnityPlugins/Odin/Odin_030.png" width=350>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity插件Odin简要入门&quot;&gt;&lt;a href=&quot;#Unity插件Odin简要入门&quot; class=&quot;headerlink&quot; title=&quot;Unity插件Odin简要入门&quot;&gt;&lt;/a&gt;Unity插件Odin简要入门&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;这几天我把Odin在Un</summary>
      
    
    
    
    <category term="unity" scheme="http://iamsleepingnow.github.io/categories/unity/"/>
    
    
    <category term="教程" scheme="http://iamsleepingnow.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
    <category term="超好用" scheme="http://iamsleepingnow.github.io/tags/%E8%B6%85%E5%A5%BD%E7%94%A8/"/>
    
    <category term="unity" scheme="http://iamsleepingnow.github.io/tags/unity/"/>
    
  </entry>
  
  <entry>
    <title>Blender模型拓补</title>
    <link href="http://iamsleepingnow.github.io/2021/08/13/Blender/Blender%E6%A8%A1%E5%9E%8B%E6%8B%93%E8%A1%A5/"/>
    <id>http://iamsleepingnow.github.io/2021/08/13/Blender/Blender%E6%A8%A1%E5%9E%8B%E6%8B%93%E8%A1%A5/</id>
    <published>2021-08-13T08:54:20.000Z</published>
    <updated>2021-08-13T08:59:39.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Blender模型拓补"><a href="#Blender模型拓补" class="headerlink" title="Blender模型拓补"></a>Blender模型拓补</h1><ul><li>一般高面数模型无法放到引擎里，这时需要去拓补一个低模</li><li>将高模上的细节信息通过材质的方法附在低模上</li></ul><h2 id="插件需求"><a href="#插件需求" class="headerlink" title="插件需求"></a>插件需求</h2><ul><li>Mesh: Auto Mirror（内置）</li><li>Mesh: F2（内置）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_001.png" width=550><h2 id="前提操作"><a href="#前提操作" class="headerlink" title="前提操作"></a>前提操作</h2><ul><li>导入高模，用来拓补</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_002.png" width=350><ul><li><code>Shift+A</code>新建面片</li><li>勾选面片-&gt;物体属性-&gt;视图显示-&gt;在前面（让面片显示在高模前面）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_003.png" width=550><ul><li><code>N</code>键呼出右方菜单，在编辑选项卡内找到Auto Mirror插件</li><li>选中<code>X</code>，点击<code>AutoMirror</code>按钮（让面片保持X轴对称）</li><li><code>N</code>键关闭右方菜单</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_004.png" width=300><ul><li>点击视图窗口正上方的吸附按钮，设置吸附为面（让面片在编辑时吸附于高模表面）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_005.png" width=400><ul><li><code>Ctrl+Tab</code>进入该面片的编辑模式</li></ul><h2 id="基础编辑"><a href="#基础编辑" class="headerlink" title="基础编辑"></a>基础编辑</h2><ul><li>点线面编辑模式：<ul><li><code>1</code>（非小键盘）点编辑模式</li><li><code>2</code>（非小键盘）线编辑模式</li><li><code>3</code>（非小键盘）面编辑模式</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_006.png" width=250><h3 id="移动（G）"><a href="#移动（G）" class="headerlink" title="移动（G）"></a>移动（G）</h3><ul><li>选中顶点，<code>G</code>移动至合适位置</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_007.png" width=400><h3 id="挤出（E）"><a href="#挤出（E）" class="headerlink" title="挤出（E）"></a>挤出（E）</h3><ul><li><p><code>要领：</code>点挤出成线，线挤出成面</p></li><li><p>选中顶点，<code>E</code>挤出</p></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_008.png" width=400><h3 id="封口（F）"><a href="#封口（F）" class="headerlink" title="封口（F）"></a>封口（F）</h3><ul><li><p><code>要领：</code>两临边封口为三角形，两对边封口为四边形</p></li><li><p>选中四边形两条对边（玫红色），<code>F</code>封口</p></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_009.png" width=400><ul><li>在开启<code>F2</code>插件之后，可以选中这两条对边的临边（玫红色），<code>F</code>封口</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_010.png" width=400><h3 id="合并-塌陷（M）"><a href="#合并-塌陷（M）" class="headerlink" title="合并/塌陷（M）"></a>合并/塌陷（M）</h3><ul><li>选中需要合并的顶点进行合并，选中需要塌陷的线或面进行塌陷</li></ul><h3 id="范围限制处理"><a href="#范围限制处理" class="headerlink" title="范围限制处理"></a>范围限制处理</h3><ul><li>在对称修改器勾选<code>范围限制</code>后，处于对称轴上的边无法分离，这时：<ul><li>使用旁敲侧击法，挤出其他三边的点，再进行封口</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_011.png" width=400><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_012.png" width=400><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_013.png" width=400><h3 id="环切（Ctrl-R）"><a href="#环切（Ctrl-R）" class="headerlink" title="环切（Ctrl+R）"></a>环切（Ctrl+R）</h3><ul><li><code>要领：</code>1：环切可能会创造多余边，2：环切有两个步骤，第一个步骤是选择环切边，滑动鼠标滚轮设置环切次数；第二个步骤是设置环切偏移，由于受吸附功能限制，环切偏移会鬼畜，这时按Esc取消偏移设置</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_014.png" width=300><h3 id="内插面（I）"><a href="#内插面（I）" class="headerlink" title="内插面（I）"></a>内插面（I）</h3><ul><li>在一个封闭形状内，若想制造内插面，则：<ul><li>按<code>Alt</code>选择循环边，<code>F</code>封闭，<code>I</code>内插面，<code>X</code>删除该多边面</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_015.png" width=300><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_016.png" width=300><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_017.png" width=300><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_018.png" width=300><h3 id="删除-融并（X）"><a href="#删除-融并（X）" class="headerlink" title="删除/融并（X）"></a>删除/融并（X）</h3><ul><li>若想消除三角面，可以将循环边融并</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_019.png" width=300><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_020.png" width=300><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_021.png" width=300><h3 id="扩展循环边"><a href="#扩展循环边" class="headerlink" title="扩展循环边"></a>扩展循环边</h3><ul><li>循环边线制作的快捷方法：<ul><li>挤出拓展点带，选择临边（玫红色），按多次<code>F</code>封闭</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_022.png" width=300><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_023.png" width=300><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_024.png" width=300><h2 id="高级编辑"><a href="#高级编辑" class="headerlink" title="高级编辑"></a>高级编辑</h2><h3 id="折角法"><a href="#折角法" class="headerlink" title="折角法"></a>折角法</h3><ul><li>在需要环切的地方，发现环切后会造成多余边过多的情况</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_025.png" width=300><ul><li>这时需要在某个地方停止环切</li><li>使用<code>折角法</code><ul><li>折角法可以使循环边拐弯</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_026.png" width=300><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_027.png" width=300><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_028.png" width=300><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_029.png" width=300><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_030.png" width=300><h3 id="分离法"><a href="#分离法" class="headerlink" title="分离法"></a>分离法</h3><ul><li>经常会出现需要加面或者减面的地方</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_031.png" width=300><ul><li>如上图，需要进行减面操作</li><li>使用<code>分离法</code><ul><li>分离法主要是将三边减为一边，或是将一边增为三边</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_032.png" width=300><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_033.png" width=300><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/blender/blender_topology/Topo_034.png" width=300>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Blender模型拓补&quot;&gt;&lt;a href=&quot;#Blender模型拓补&quot; class=&quot;headerlink&quot; title=&quot;Blender模型拓补&quot;&gt;&lt;/a&gt;Blender模型拓补&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一般高面数模型无法放到引擎里，这时需要去拓补一个低模&lt;/</summary>
      
    
    
    
    <category term="blender" scheme="http://iamsleepingnow.github.io/categories/blender/"/>
    
    
    <category term="指南" scheme="http://iamsleepingnow.github.io/tags/%E6%8C%87%E5%8D%97/"/>
    
    <category term="blender" scheme="http://iamsleepingnow.github.io/tags/blender/"/>
    
    <category term="受苦" scheme="http://iamsleepingnow.github.io/tags/%E5%8F%97%E8%8B%A6/"/>
    
  </entry>
  
  <entry>
    <title>虚幻动画序列</title>
    <link href="http://iamsleepingnow.github.io/2021/08/03/Unreal/%E8%99%9A%E5%B9%BB%E5%8A%A8%E7%94%BB%E5%BA%8F%E5%88%97/"/>
    <id>http://iamsleepingnow.github.io/2021/08/03/Unreal/%E8%99%9A%E5%B9%BB%E5%8A%A8%E7%94%BB%E5%BA%8F%E5%88%97/</id>
    <published>2021-08-03T08:44:12.000Z</published>
    <updated>2021-08-04T02:33:50.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚幻动画序列"><a href="#虚幻动画序列" class="headerlink" title="虚幻动画序列"></a>虚幻动画序列</h1><h2 id="一：用什么来制作动画"><a href="#一：用什么来制作动画" class="headerlink" title="一：用什么来制作动画"></a>一：用什么来制作动画</h2><ul><li><code>Matinee</code>已过时，关卡动画时间线使用<code>MovieScene物体</code>驱动<code>LevelSequence文件</code>来播放动画</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_001.png" width=400><ul><li>不要忘了需要在<code>MovieScene</code>物体里设置初始播放</li><li>双击<code>Level Sequence</code>文件进入<code>Sequencer窗口</code>来编辑动画</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_002.png" width=100><ul><li><code>时间轴编辑器Sequencer</code>窗口主要功能介绍：<ul><li>1：新增轨道，轨道类型在后面会详细介绍</li><li>2：当前帧设置：设置当前处于的帧数</li><li>3：播放按钮：与其他三维软件一致</li><li>4&amp;5：渲染初始帧与结束帧：拖动以设置</li><li>6：当前帧：拖动以设置</li><li>7：自动设置关键帧</li><li>8：影片吸附</li><li>9：设置影片帧速率</li><li>10：打开<code>曲线编辑器Sequencer Curves</code></li><li>11：窗口显示范围：拖动以设置</li><li>12：打开渲染输出窗口</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_003.png" width=800><ul><li>点击新增轨道按钮，以下是较常用的轨道类型：<ul><li><code>Actor To Sequencer</code>添加场景实例来作为轨道（实例轨）</li><li><code>Add Folder</code>添加文件夹来分类</li><li><code>Audio Track</code>添加音频轨</li><li><code>Event Track</code>添加事件轨</li><li><code>Camera Cut Track</code>添加切镜轨</li><li><code>Shot Track</code>添加其他相机动画序列来进行整合的轨（镜头轨）</li><li><code>Time Dilation Track</code>速度控制轨（速度轨）</li><li><code>Subscenes Track</code>添加子序列轨，用于封套（子序列轨）</li><li><code>Fade Track</code>添加黑色转场轨</li><li><code>Level Visibility Track</code>添加关卡调度轨</li><li><code>Material Parameter Collection Track</code>添加以材质参数集合文件来做材质动画的轨（材质轨）</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_004.png" width=250><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul><li>J： 倒放，K：暂停，L：正放</li><li>M：创建或删除标注</li><li>F：图表居中</li><li>I：设置选区起点，O：设置选区终点</li><li>空格：播放</li><li>回车：设置关键帧</li></ul><h2 id="二：怎样来制作动画"><a href="#二：怎样来制作动画" class="headerlink" title="二：怎样来制作动画"></a>二：怎样来制作动画</h2><h3 id="实例动画"><a href="#实例动画" class="headerlink" title="实例动画"></a>实例动画</h3><ul><li>添加场景实例轨，或将实例拖入轨道，即可创建实例轨</li><li>点击实例轨右边的<code>加号</code>，用于添加实例物体子轨，例如<code>Transform</code>就是<code>SM_Watermelon</code>的子轨</li><li>物体组件作为物体的子轨，同时也能在组件子轨中添加组件属性子轨</li><li>可供打关键帧的轨都有<code>← ＋ →</code>这三个符号，箭头用于转到下一个关键帧，加号用于添加关键帧</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_005.png" width=350><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_006.png" width=150><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_007.png" width=350><ul><li>打关键帧的方法：<ul><li>选择要打关键帧的轨，按<code>enter</code>回车，即可设置关键帧</li><li>选择要打关键帧的轨，点击轨名称右边的圆形加号，即可设置关键帧</li><li>选择要打关键帧的轨，使用鼠标中键点击需要打关键帧的位置，即可设置关键帧</li><li>开启自动关键帧，修改某一轨的数值，即可设置关键帧</li></ul></li></ul><h3 id="动画曲线"><a href="#动画曲线" class="headerlink" title="动画曲线"></a>动画曲线</h3><ul><li>例：给<code>SM_Watermelon</code>的位置数值设置关键帧</li><li>点击曲线编辑器按钮（位于工具栏右方）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_008.png" width=800><ul><li>点击曲线点，会出现曲线杠杆</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_009.png" width=800><ul><li>选择曲线点右键，设置曲线点状态</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_010.png" width=250><h3 id="影视相机"><a href="#影视相机" class="headerlink" title="影视相机"></a>影视相机</h3><ul><li>在<code>Place Actors</code>窗口中搜索<code>camera</code>，将<code>Cine Camera Actor</code>拖入场景中<ul><li><code>Camera</code>是普通游戏摄像机</li><li><code>Cine Camera Actor</code>是影视摄像机</li><li><code>Camera Rig Crane</code>是相机吊臂</li><li><code>Camera Rig Rail</code>是相机轨道</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_011.png" width=250><ul><li>相机比较重要的设置：<ul><li><code>Current Camera Settings</code>：<ul><li><code>Lookat Tracking Settings</code>物体捕捉设置</li><li><code>Filmback</code>分辨率设置</li><li><code>Lens Settings</code>镜头设置</li><li><code>Focus Settings</code>聚焦设置</li></ul></li><li><code>Post Process</code>：<ul><li><code>Lens</code>镜头特效</li><li><code>Color Grading</code>颜色矫正</li><li><code>Film</code>影视级颜色矫正</li><li><code>Global Illumination</code>全局光照设置</li><li><code>Reflections</code>反射设置</li><li><code>Rendering Features</code>特殊镜头特效</li></ul></li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_025.png" width=350><h3 id="相机动画"><a href="#相机动画" class="headerlink" title="相机动画"></a>相机动画</h3><ul><li>将此相机拖入轨道</li><li>自动创建了相机的<code>切镜轨Camera Cut Track</code>和相机的<code>实例轨</code></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_012.png" width=800><ul><li>点击相机实例轨右方的相机符号，进入相机视角，这时相机会跟随视角</li><li>这时可以为相机位移旋转设置动画关键帧</li><li>再次点击取消跟随</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_013.png" width=300><ul><li>复制相机并拖入切镜轨，点击切镜轨右方的相机符号，进入切镜视角，这时视角会被锁定</li><li>这时可以预览切镜</li><li>再次点击取消锁定</li><li>右键切镜片段-&gt;Thumbnails-&gt;Refresh刷新切镜片段预览</li><li><code>注意：</code>若要制作相机动画，切镜轨是必不可少的，没有切镜轨，虚幻无法播放相机内渲染的画面</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_014.png" width=700><h3 id="相机吊臂与相机轨道"><a href="#相机吊臂与相机轨道" class="headerlink" title="相机吊臂与相机轨道"></a>相机吊臂与相机轨道</h3><ul><li>在<code>Place Actors</code>窗口中创建相机吊臂</li><li>将相机拖到吊臂上，作为子集，重置坐标和旋转</li><li>调节吊臂的参数，并设置关键帧，即可模拟吊臂效果：<ul><li><code>Crane Pitch</code>吊臂俯仰角</li><li><code>Crane Yaw</code>吊臂偏航角</li><li><code>Crane Arm Length</code>吊臂臂长</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_022.png" width=400><hr><ul><li><p>在<code>Place Actors</code>窗口中创建相机轨道</p></li><li><p>将相机拖到轨道上，作为子集，重置旋转，将坐标设置到一个合适的位置</p></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_023.png" width=200><ul><li>轨道上有两个白色曲线点，选择一个曲线点，按<code>alt</code>键拖出新的曲线点</li><li>每一个曲线点上都有两个曲线手柄，用于修改曲线曲率</li><li>调节轨道的参数，并设置关键帧，即可模拟轨道效果：<ul><li><code>Current Position On Rail</code>当前相机位于轨道的位置（0~1）</li><li><code>Lock Orientation On Rail</code>将视角锁定于当前轨道朝向</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_024.png" width=400><h3 id="事件轨与镜头轨"><a href="#事件轨与镜头轨" class="headerlink" title="事件轨与镜头轨"></a>事件轨与镜头轨</h3><ul><li>创建一个新的<code>Level Sequence</code>文件，双击编辑</li><li>新建事件轨，会发现有<code>Trigger</code>与<code>Repeater</code>之分</li><li>将<code>Trigger</code>与<code>Repeater</code>都创建出来</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_015.png" width=350><ul><li>发现<code>Trigger触发轨</code>允许设置关键帧，<code>Repeater持续触发轨</code>允许修改轨的长度</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_016.png" width=750><ul><li>右键触发轨的关键帧-&gt;Properties-&gt;Event-&gt;Create New Endpoint新建断点事件</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_017.png" width=450><ul><li>在弹出的蓝图里修改事件名称，设置事件内容</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_018.png" width=650><ul><li>在持续触发轨中也如法炮制，右键持续触发轨，新建断点事件</li><li>在弹出的蓝图里修改事件名称，设置事件内容</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_019.png" width=400><ul><li>双击返回之前的<code>Level Sequence</code>文件，新建<code>镜头轨道Shot Track</code><ul><li>镜头轨可以将其他<code>Level Sequence</code>文件并入播放</li><li>有且只能存在一条镜头轨</li></ul></li><li>点击镜头轨右方的加号，将另外一个<code>Level Sequence</code>添加进来</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_020.png" width=350><ul><li>保存并播放，这时可以发现：<ul><li><code>Trigger触发轨</code>在某一关键帧处触发一次</li><li><code>Repeater持续触发轨</code>在某一时间区间内每帧触发一次</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_021.png" width=150><h3 id="速度轨与转场轨"><a href="#速度轨与转场轨" class="headerlink" title="速度轨与转场轨"></a>速度轨与转场轨</h3><ul><li>在主关卡序列<code>Level Sequence</code>里添加<code>Time Dilation Track</code>速度轨</li><li>首先先给相机做一个位移动画</li><li>在需要控制速度的地方设置速度关键帧</li><li>速度轨可以有效制作慢镜头画面</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_026.png" width=800><hr><ul><li>在主关卡序列<code>Level Sequence</code>里添加<code>Fade Track</code>黑色转场轨</li><li>黑色转场主要控制画面是否黑屏，做不到两个画面淡入淡出效果</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_027.png" width=800><h3 id="子序列轨"><a href="#子序列轨" class="headerlink" title="子序列轨"></a>子序列轨</h3><ul><li><code>Subscenes Track</code>子序列轨与<code>Shot Track</code>镜头轨类似，都是封装其他<code>Level Sequence</code>关卡序列文件</li><li>与镜头轨的不同点：<ul><li>子序列轨没有预览画面，镜头轨有</li><li>子序列轨可以用于封装非镜头动画，而镜头轨是特殊的子序列轨</li></ul></li><li>镜头轨同样也能封装非镜头动画</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_028.png" width=800><h3 id="材质轨"><a href="#材质轨" class="headerlink" title="材质轨"></a>材质轨</h3><ul><li>创建材质参数集合文件<code>Material Parameter Collection</code></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_029.png" width=400><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_030.png" width=100><ul><li>在文件里新建自定义常量与向量，设置默认值与名称，并保存</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_031.png" width=600><ul><li>新建材质轨<code>Material Parameter Collection Track</code>，选择刚新建的参数文件</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_032.png" width=500><ul><li>点击材质轨右边的加号，添加变量</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_033.png" width=350><ul><li>设置关键帧动画</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_034.png" width=800><ul><li>新建材质<code>Material</code></li><li>搜索<code>Collection Parameter</code>节点，设置文件与变量</li><li>使用此节点，例如设置成基础色<code>Base Color</code>，并保存</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_035.png" width=600><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_036.png" width=350><ul><li>右键此材质文件，创建材质实例，并赋给场景中物体</li><li>这时，材质颜色就会依照动画进行变化</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_037.png" width=250><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_038.png" width=450><h3 id="模型动画"><a href="#模型动画" class="headerlink" title="模型动画"></a>模型动画</h3><ul><li>导入骨骼模型与动画</li><li><code>注意：</code><ul><li>先导入一个fbx文件，取消勾选导入动画，仅导入骨骼信息文件（下图后三个）</li><li>再拖入四个携带动画的fbx模型文件，勾选导入动画，取消勾选导入模型</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_039.png" width=800><ul><li>将骨骼网格体拖入场景，再拖入关卡序列<code>Level Sequence</code></li><li>发现骨骼网格体下面有<code>Animation</code>子轨，点击轨右方的加号，添加导入的动画文件</li><li>动画片段（下图紫色）之间允许交融与淡入淡出，可以有效融合模型动画</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_040.png" width=800><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealFilms/Sequence_041.png" width=300>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;虚幻动画序列&quot;&gt;&lt;a href=&quot;#虚幻动画序列&quot; class=&quot;headerlink&quot; title=&quot;虚幻动画序列&quot;&gt;&lt;/a&gt;虚幻动画序列&lt;/h1&gt;&lt;h2 id=&quot;一：用什么来制作动画&quot;&gt;&lt;a href=&quot;#一：用什么来制作动画&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="unreal" scheme="http://iamsleepingnow.github.io/categories/unreal/"/>
    
    
    <category term="unreal" scheme="http://iamsleepingnow.github.io/tags/unreal/"/>
    
    <category term="动画" scheme="http://iamsleepingnow.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>丧心病狂虚幻C++</title>
    <link href="http://iamsleepingnow.github.io/2021/07/30/Unreal/%E4%B8%A7%E5%BF%83%E7%97%85%E7%8B%82%E8%99%9A%E5%B9%BBC++/"/>
    <id>http://iamsleepingnow.github.io/2021/07/30/Unreal/%E4%B8%A7%E5%BF%83%E7%97%85%E7%8B%82%E8%99%9A%E5%B9%BBC++/</id>
    <published>2021-07-30T05:06:40.000Z</published>
    <updated>2021-07-30T05:35:00.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="丧心病狂虚幻C"><a href="#丧心病狂虚幻C" class="headerlink" title="丧心病狂虚幻C++"></a>丧心病狂虚幻C++</h1><ul><li>天  地  玄  黄  宇  宙  洪  荒</li><li>虚幻C++绝对难得毫无廉耻</li></ul><h2 id="🔥虚幻物体类型结构"><a href="#🔥虚幻物体类型结构" class="headerlink" title="🔥虚幻物体类型结构"></a>🔥虚幻物体类型结构</h2><ul><li>虚幻<code>C++类</code>是一个代码预置，没有外部调整界面，一切设置都由代码完成，是不可视化的</li><li>通过虚幻<code>C++类</code>派生的<code>蓝图类</code>，其中的<code>蓝图成员</code>仍然能接收其虚幻<code>C++类</code>修改或变动</li><li>通过这样生成的<code>蓝图类</code>，属于虚幻<code>C++类</code>的变种，在变种中可以可视化地分别设置其组件及成员的数据</li><li>自定义类物体拥有三种类型：<ul><li><code>代码原型</code>：通过C++写成的类，需要在里面定义好其拥有的组件及其父子关系，以及定义默认参数，以及写好功能函数与所有<code>“一般化”</code>功能</li><li><code>蓝图类</code>：通过C++类派生出来的<code>预制体</code>类型，可以派生多个，拥有所有其C++原型对其暴露的参数与函数，拥有为其单个<code>预制体</code>而服务的<code>蓝图脚本区</code>（必须继承自<code>UObject</code>或其派生）以及可视化<code>三维视口区</code>（必须继承自AActor或其派生），拥有<code>“特殊化”</code>的配置能力</li><li><code>实例物体</code>：通过<code>代码原型</code>或<code>蓝图类</code>在关卡中实例化出的单个<code>物体</code>（必须继承自<code>AActor</code>或其派生），能够在游戏进程中运行线程周期函数</li></ul></li></ul><h2 id="🔥新建代码原型"><a href="#🔥新建代码原型" class="headerlink" title="🔥新建代码原型"></a>🔥新建代码原型</h2><ul><li>示例以<code>AActor</code>类为基类</li></ul><h3 id="🚩头文件介绍"><a href="#🚩头文件介绍" class="headerlink" title="🚩头文件介绍"></a>🚩头文件介绍</h3><p>GENERATED_BODY()    UE默认代码</p><p>BeginPlay()    初始化函数</p><p>Tick(DeltaTime)    运行函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Actor_1类头文件.h --------------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once<span class="comment">//此指令保证本头文件只被编译一次</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span><span class="comment">//此引用包含所有UE4新增的数据类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Actor.h&quot;</span><span class="comment">//此引用包含所有UE4封装好的代码初始继承类</span></span></span><br><span class="line"><span class="comment">//此引用包含UE4在创立本类时生成的反射机制，注意：此引用必须在所有引用的下面</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Actor_1.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()<span class="comment">//此宏用于本类被UE4识别</span></span><br><span class="line"><span class="comment">//class 项目名 类名 : 基类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOW2PLAYWITHUE4_1_API</span> AActor_1 : <span class="keyword">public</span> AActor<span class="comment">//继承自AActor类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()<span class="comment">//此宏表示UE4替开发者生成的代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//在此加入游戏物体的初始化参数</span></span><br><span class="line"><span class="built_in">AActor_1</span>();<span class="comment">//类构造函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;<span class="comment">//游戏初始函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;<span class="comment">//游戏运行函数声明</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="🚩源文件介绍"><a href="#🚩源文件介绍" class="headerlink" title="🚩源文件介绍"></a>🚩源文件介绍</h3><p>PrimaryActorTick.bCanEverTick    是否每帧调用运行函数标识符</p><p>Super::BeginPlay() / Tick(DeltaTime)    父类初始化与运行函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Actor_1类源文件.cpp --------------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Actor_1.h&quot;</span><span class="comment">//包含本类的头文件</span></span></span><br><span class="line"></span><br><span class="line">AActor_1::<span class="built_in">AActor_1</span>()<span class="comment">//构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//保证游戏运行时每帧运行Tick函数，设为false可以省资源</span></span><br><span class="line">PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AActor_1::BeginPlay</span><span class="params">()</span><span class="comment">//游戏初始函数实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Super是父类的类型别名，表示子类重写父类虚函数的多态</span></span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();<span class="comment">//在运行子类的初始函数之前，需要调用一遍父类的初始函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AActor_1::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span><span class="comment">//游戏运行函数实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Tick</span>(DeltaTime);<span class="comment">//在运行子类的运行函数之前，需要调用一遍父类的运行函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🚩类命名规则"><a href="#🚩类命名规则" class="headerlink" title="🚩类命名规则"></a>🚩类命名规则</h3><ul><li>继承或派生自<code>Actor</code>首字母为<code>A</code>，如<code>APawn</code></li><li>继承或派生自<code>Object</code>首字母为<code>U</code>，如<code>USceneComponent</code></li><li>继承或派生自<code>SWidget</code>首字母为<code>S</code>，如<code>SButton</code></li><li>继承或派生自<code>Enums</code>首字母为<code>E</code>，如<code>EInputEvent</code></li><li>继承或派生自<code>Template</code>首字母为<code>T</code>，如<code>TArray</code></li><li>其他闲散类首字母均为<code>F</code>，如<code>FVector</code></li></ul><h2 id="🔥参数属性说明符"><a href="#🔥参数属性说明符" class="headerlink" title="🔥参数属性说明符"></a>🔥参数属性说明符</h2><h3 id="🚩宏UCLASS"><a href="#🚩宏UCLASS" class="headerlink" title="🚩宏UCLASS()"></a>🚩宏UCLASS()</h3><ul><li>使类便于虚幻引擎识别并操控</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件内 -----------------------------------</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line">    <span class="keyword">class</span> 项目名 类名 : <span class="keyword">public</span> 基类名&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="🚩宏UFUNCTION"><a href="#🚩宏UFUNCTION" class="headerlink" title="🚩宏UFUNCTION()"></a>🚩宏UFUNCTION()</h3><ul><li>使成员函数便于虚幻引擎识别并操控</li></ul><p>UFUNCTION(BlueprintCallable)    函数：蓝图可调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件内 -----------------------------------</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line">        <span class="type">void</span> 函数名();</span><br><span class="line"><span class="comment">// ****************************</span></span><br><span class="line"><span class="comment">//BlueprintCallable表示能在蓝图编辑器中调用</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable)</span><br><span class="line">        <span class="type">void</span> 函数名();</span><br><span class="line"><span class="comment">// ****************************</span></span><br><span class="line"><span class="comment">//BlueprintNativeEvent表示能在蓝图类中重写</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintNativeEvent)</span><br><span class="line">        <span class="type">void</span> 函数名();</span><br><span class="line"><span class="type">void</span> 函数名_Implementation();</span><br></pre></td></tr></table></figure><h3 id="🚩宏UPROPERTY"><a href="#🚩宏UPROPERTY" class="headerlink" title="🚩宏UPROPERTY()"></a>🚩宏UPROPERTY()</h3><ul><li>使成员属性便于虚幻引擎识别并操控</li><li><a href="https://docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/GameplayArchitecture/Properties/">官网</a> </li></ul><p>UPROPERTY(VisibleAnywhere)    属性：所有环境可见</p><p>UPROPERTY(EditAnywhere)    属性：所有环境可编辑</p><p>UPROPERTY(VisibleDefaultsOnly)    属性：仅蓝图类可见</p><p>UPROPERTY(EditDefaultsOnly)    属性：仅蓝图类可编辑</p><p>UPROPERTY(VisibleInstanceOnly)    属性：仅实例可见</p><p>UPROPERTY(EditInstanceOnly)    属性：仅实例可编辑</p><p>UPROPERTY(BlueprintReadOnly)    属性：蓝图类与蓝图只读</p><p>UPROPERTY(BlueprintReadWrite)    属性：蓝图类与蓝图可读写</p><p>UPROPERTY(EditAnywhere, Category=”Category_1|SubCategory”)    属性：设置组件内分栏</p><p>UPROPERTY(EditAnywhere, Meta=(Bitmask, BitmaskEnum=”EColorType”))    属性：枚举下拉菜单</p><p>UPROPERTY(EditAnywhere, Meta=(ClampMin = -1, ClampMax = 1, UIMin = -1, UIMax = 1))    属性：钳制数值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件内 -----------------------------------</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//UPROPERTY()宏用来给参数添加属性</span></span><br><span class="line"><span class="comment">// ****************************</span></span><br><span class="line"><span class="comment">//VisibleAnywhere表示在编辑器中显示并只读</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">        int32 num1 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ****************************</span></span><br><span class="line"><span class="comment">//EditAnywhere表示在编辑器中显示并可编辑</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">        int32 num2 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ****************************</span></span><br><span class="line"><span class="comment">//Category赋值表示可在编辑器中显示分栏，以“|”为多级分栏</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category=<span class="string">&quot;Category_1|SubCategory&quot;</span>)</span><br><span class="line">        int32 num3 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ****************************</span></span><br><span class="line"><span class="comment">//VisibleDefaultsOnly表示只在蓝图编辑器中显示并只读</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleDefaultsOnly)</span><br><span class="line">        int32 num4 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ****************************</span></span><br><span class="line"><span class="comment">//EditDefaultsOnly表示在蓝图编辑器中显示并可编辑</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditDefaultsOnly)</span><br><span class="line">        int32 num4 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ****************************</span></span><br><span class="line"><span class="comment">//EditInstanceOnly表示只在蓝图编辑器中显示并只读，当实例化到场景中才可编辑</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditInstanceOnly)</span><br><span class="line">        int32 num4 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ****************************</span></span><br><span class="line"><span class="comment">//EditAnywhere不建议赋给指针组件，不然就没有好果汁吃</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">        UStaticMeshComponent* mesh;<span class="comment">//不建议！！！</span></span><br><span class="line"><span class="comment">//一：如果能够保证该指针能在游戏开始前被赋值，则可以使用EditAnywhere，比如说固有组件</span></span><br><span class="line"><span class="comment">//二：如果该物体是可动态实例化物体，则不建议，因为虚幻检测到空指针会崩溃</span></span><br><span class="line"><span class="comment">// ****************************</span></span><br><span class="line"><span class="comment">//Meta赋值表示设置位掩码</span></span><br><span class="line"><span class="comment">//如果有一个枚举定义名为EColorType，则可以在编辑器内设置选择下拉框</span></span><br><span class="line"><span class="comment">//UENUM() enum class EColorType &#123; RED, GREEN, YELLOW &#125;;</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, </span><br><span class="line">              Meta=(Bitmask, BitmaskEnum=<span class="string">&quot;EColorType&quot;</span>))</span><br><span class="line">        EColorType color = EColorType::RED;</span><br><span class="line"><span class="comment">// ****************************</span></span><br><span class="line"><span class="comment">//Meta同时也可以对数值做限制</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, </span><br><span class="line">              Meta=(ClampMin = <span class="number">-500</span>, ClampMax = <span class="number">500</span>, UIMin = <span class="number">-500</span>, UIMax = <span class="number">500</span>))</span><br><span class="line">        FVector vect = <span class="built_in">FVector</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="🔥组件"><a href="#🔥组件" class="headerlink" title="🔥组件"></a>🔥组件</h2><ul><li>在虚幻里，任何可以拖入场景里的物件都是<code>Actor</code>，并且继承自<code>AActor</code>类</li><li>组件<code>Component</code>只能依附于<code>Actor</code>才能存在</li><li><code>Actor</code>都是以A开头的，<code>Component</code>都是以U开头的</li><li><code>Actor</code>的方位矩阵信息记录在<code>AActor</code>里的<code>RootComponent</code>根组件上，默认Nullptr</li></ul><h3 id="🚩物体类添加组件"><a href="#🚩物体类添加组件" class="headerlink" title="🚩物体类添加组件"></a>🚩物体类添加组件</h3><p>USceneComponent    场景组件类，是所有可放入场景的组件的基类</p><p>UStaticMeshComponent    静态网格组件类</p><p>UObject::CreateDefaultSubobject&lt;&gt;()    物体添加组件</p><p>RootComponent    物体的根组件</p><p>USceneComponent::SetupAttachment()    将组件作为其他组件的子集</p><p>FindComponentByClass&lt;class …&gt;()    通过组件类名获取物体内组件的模板类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件内 -----------------------------------</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere, Category = <span class="string">&quot;OBJScene&quot;</span>)</span><br><span class="line">USceneComponent* objScene;<span class="comment">//场景物体组件声明（必须是指针）</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere, Category = <span class="string">&quot;MyMesh&quot;</span>)</span><br><span class="line">UStaticMeshComponent* mesh1;<span class="comment">//静态网格组件声明（必须是指针）</span></span><br><span class="line"><span class="comment">// 源文件内构造函数内 ---------------------------</span></span><br><span class="line"><span class="comment">//场景物体组件实现</span></span><br><span class="line">objScene = CreateDefaultSubobject&amp;lt;USceneComponent&amp;gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;objScene&quot;</span>));</span><br><span class="line">RootComponent = objScene;<span class="comment">//设置根组件</span></span><br><span class="line"><span class="comment">//静态网格组件实现</span></span><br><span class="line">mesh1 = CreateDefaultSubobject&amp;lt;UStaticMeshComponent&amp;gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;myMesh1&quot;</span>));</span><br><span class="line">mesh1-&gt;<span class="built_in">SetupAttachment</span>(objScene);<span class="comment">//组件层级附加</span></span><br></pre></td></tr></table></figure><h3 id="🚩组件类"><a href="#🚩组件类" class="headerlink" title="🚩组件类"></a>🚩组件类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在组件类中的操作与物体类差不多一致</span></span><br><span class="line"><span class="comment">//不同点是组件类影响其附着的物体需要借助GetOwner()方法</span></span><br><span class="line"><span class="built_in">GetOwner</span>()-&gt;<span class="built_in">SetActorLocation</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//像组件使用的函数方法能直接使用</span></span><br><span class="line"><span class="built_in">SetupAttachment</span>(...);</span><br></pre></td></tr></table></figure><h2 id="🔥测试"><a href="#🔥测试" class="headerlink" title="🔥测试"></a>🔥测试</h2><h3 id="🚩打印"><a href="#🚩打印" class="headerlink" title="🚩打印"></a>🚩打印</h3><p>GEngine-&gt;AddOnScreenDebugMessage()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在屏幕上打印一行字</span></span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;HelloWorld!&quot;</span>));</span><br></pre></td></tr></table></figure><p>UE_LOG()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在日志窗口打印一行字</span></span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;HelloWorld&quot;</span>));</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;HelloWorld&quot;</span>));</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;HelloWorld&quot;</span>));</span><br><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;HelloWorld %i&quot;</span>), *num);</span><br><span class="line"><span class="comment">//int = %i, float = %f, string = %s, vector = %v</span></span><br></pre></td></tr></table></figure><h3 id="🚩绘图"><a href="#🚩绘图" class="headerlink" title="🚩绘图"></a>🚩绘图</h3><p>DrawDebugLine    画线</p><p>DrawDebugPoint    画点</p><p>DrawDebugDirectionalArrow    画箭头</p><p>DrawDebugBox/Frustum/SolidBox/SolidPlane    画方</p><p>DrawDebugSphere/Capsule/Cylinder/Cone    画球</p><p>DrawDebugCircle/2DDonut    画面</p><p>DrawDebugCoordinateSystem    画坐标系</p><p>DrawDebugString    写字</p><p>DrawDebugCamera    摄像机</p><p>DrawDebugMesh    网格</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绘图调试需要使用DrawDebugHelpers类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DrawDebugHelpers.h&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="🔥基本数值类型"><a href="#🔥基本数值类型" class="headerlink" title="🔥基本数值类型"></a>🔥基本数值类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int32<span class="comment">//32位整型</span></span><br><span class="line">int64<span class="comment">//64位整型</span></span><br><span class="line"><span class="type">float</span><span class="comment">//单精度浮点</span></span><br><span class="line"><span class="type">double</span><span class="comment">//双精度浮点</span></span><br><span class="line"><span class="type">bool</span><span class="comment">//布尔是非值</span></span><br><span class="line">TArray<span class="comment">//动态数组</span></span><br><span class="line">Set<span class="comment">//集</span></span><br><span class="line">Map<span class="comment">//映射</span></span><br><span class="line">FVector<span class="comment">//三维向量</span></span><br><span class="line">FVector2D<span class="comment">//二维向量</span></span><br><span class="line">FRotator<span class="comment">//三维旋矩</span></span><br><span class="line">FQuat<span class="comment">//四元数</span></span><br><span class="line">FTransform<span class="comment">//方位量</span></span><br><span class="line">FColor<span class="comment">//颜色量</span></span><br><span class="line">FString<span class="comment">//字符串</span></span><br><span class="line">FName<span class="comment">//微字符串，不区分大小写</span></span><br><span class="line">FText<span class="comment">//长字符串</span></span><br></pre></td></tr></table></figure><h2 id="🔥类型转换"><a href="#🔥类型转换" class="headerlink" title="🔥类型转换"></a>🔥类型转换</h2><h3 id="🚩转字符串"><a href="#🚩转字符串" class="headerlink" title="🚩转字符串"></a>🚩转字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------------------------------</span></span><br><span class="line"><span class="comment">//int</span></span><br><span class="line"><span class="comment">//int32/int64转FString</span></span><br><span class="line">int32 i32 = <span class="number">0</span>;</span><br><span class="line">int64 i64 = <span class="number">0</span>;</span><br><span class="line">FString s = FString::<span class="built_in">FromInt</span>(i32);</span><br><span class="line">FString s = FString::<span class="built_in">FromInt</span>(i64);</span><br><span class="line"><span class="comment">//FString转int32/int64</span></span><br><span class="line">FString s = <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">int32 i = FCString::<span class="built_in">Atoi</span>(s);</span><br><span class="line">int64 i = FCString::<span class="built_in">Atoi64</span>(s);</span><br><span class="line"><span class="comment">// ----------------------------------------</span></span><br><span class="line"><span class="comment">//float</span></span><br><span class="line"><span class="comment">//float/double转FString</span></span><br><span class="line"><span class="type">float</span> f = <span class="number">0.0f</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="number">0.0</span>;</span><br><span class="line">FString s = FString::<span class="built_in">SanitizeFloat</span>(f);</span><br><span class="line">FString s = FString::<span class="built_in">SanitizeFloat</span>(d);</span><br><span class="line"><span class="comment">//FString转float/double</span></span><br><span class="line">FString s = <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="type">float</span> f = FCString::<span class="built_in">Atof</span>(f);</span><br><span class="line"><span class="type">double</span> f = FCString::<span class="built_in">Atod</span>(f);</span><br><span class="line"><span class="comment">// ----------------------------------------</span></span><br><span class="line"><span class="comment">//FName和FText</span></span><br><span class="line"><span class="comment">//FName/FText转FString</span></span><br><span class="line">FName n = <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">FText t = <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">FString s = n.<span class="built_in">ToString</span>();</span><br><span class="line">FString s = t.<span class="built_in">ToString</span>();</span><br><span class="line"><span class="comment">//FString转FName/FText</span></span><br><span class="line">FString s = <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">FName n = <span class="built_in">FName</span>(*s);</span><br><span class="line">FText t = FText::<span class="built_in">FromString</span>(s);</span><br><span class="line"><span class="comment">//FName转FText（FText不允许转FName）</span></span><br><span class="line">FName n = <span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">FText t = FText::<span class="built_in">FromName</span>(n);</span><br></pre></td></tr></table></figure><h3 id="🚩整型与浮点"><a href="#🚩整型与浮点" class="headerlink" title="🚩整型与浮点"></a>🚩整型与浮点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有两种转换方法：</span></span><br><span class="line"><span class="comment">//构造转换</span></span><br><span class="line">int32 i = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">float</span>(i);</span><br><span class="line"><span class="comment">//强转</span></span><br><span class="line">int32 i = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> f = (<span class="type">float</span>)i; </span><br></pre></td></tr></table></figure><h3 id="🚩保留小数"><a href="#🚩保留小数" class="headerlink" title="🚩保留小数"></a>🚩保留小数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用int()来强制转换会彻底丢掉小数位，所以要加上0.5，来保证其第一位小数大于5时会进1</span></span><br><span class="line"><span class="type">float</span> f = <span class="number">3.14159</span>;</span><br><span class="line">FString s = FString::<span class="built_in">SanitizeFloat</span>(<span class="built_in">int</span>(f * <span class="number">100</span> + <span class="number">0.5</span>) / <span class="number">100.0</span>);</span><br></pre></td></tr></table></figure><h2 id="🔥实例化"><a href="#🔥实例化" class="headerlink" title="🔥实例化"></a>🔥实例化</h2><h3 id="🚩ConstructorHelpers类"><a href="#🚩ConstructorHelpers类" class="headerlink" title="🚩ConstructorHelpers类"></a>🚩ConstructorHelpers类</h3><ul><li><code>ConstructorHelpers类</code>用于在C++中获取资源文件</li></ul><h4 id="FClassFinder寻找类"><a href="#FClassFinder寻找类" class="headerlink" title="FClassFinder寻找类"></a>FClassFinder寻找类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---------------------------</span></span><br><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Runtime/CoreUObject/Public/UObject/ConstructorHelpers.h&quot;</span></span></span><br><span class="line">TSubclassOf&amp;lt;AActor&amp;gt; actorToSpawn;<span class="comment">//创建UClass*实例</span></span><br><span class="line"><span class="comment">// ---------------------------</span></span><br><span class="line"><span class="comment">// 源文件</span></span><br><span class="line"><span class="comment">// 一：必须在构造函数内定义</span></span><br><span class="line"><span class="comment">// 二：获取类地址时，掐头去尾，还要在后面添加“_C”来表示获取的是个类</span></span><br><span class="line"><span class="type">static</span> ConstructorHelpers::FClassFinder&amp;lt;AActor&amp;gt; <span class="built_in">actorResource</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;/Game/类地址_C&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (actorResource.<span class="built_in">Succeeded</span>())<span class="comment">//如果正确获取类</span></span><br><span class="line">&#123;</span><br><span class="line">actorToSpawn = actorResource.Class;<span class="comment">//将资源类赋予给UClass*实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FObjectFinder寻找资源"><a href="#FObjectFinder寻找资源" class="headerlink" title="FObjectFinder寻找资源"></a>FObjectFinder寻找资源</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---------------------------</span></span><br><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Runtime/CoreUObject/Public/UObject/ConstructorHelpers.h&quot;</span></span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">UStaticMeshComponent* mesh;</span><br><span class="line"><span class="comment">// ---------------------------</span></span><br><span class="line"><span class="comment">// 源文件</span></span><br><span class="line"><span class="comment">// 必须在构造函数内定义</span></span><br><span class="line"><span class="type">static</span> ConstructorHelpers::FObjectFinder&amp;lt;UStaticMesh&amp;gt; <span class="built_in">meshResource</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;/Game/资源地址&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (meshResource.<span class="built_in">Succeeded</span>())<span class="comment">//如果正确获取资源</span></span><br><span class="line">&#123;</span><br><span class="line">mesh-&gt;<span class="built_in">SetStaticMesh</span>(meshResource.Object);<span class="comment">//将资源赋予给UStaticMeshComponent*实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🚩类实例化"><a href="#🚩类实例化" class="headerlink" title="🚩类实例化"></a>🚩类实例化</h3><p>UWorld    场景类</p><p>TSubclassOf&lt;class …&gt;()    表示UClass类型的模板类（强制选择该类下的派生）</p><p>FActorSpawnParameters    物体生成参数类型</p><p>UWorld-&gt;SpawnActor&lt;&gt;()    生成实例模板函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TSubclassOf&amp;lt;<span class="keyword">class</span> <span class="title class_">AActor</span>&amp;gt; ActorClass;<span class="comment">//生成物体类</span></span><br><span class="line">FActorSpawnParameters SpawnParams;<span class="comment">//物体生成参数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">AActor* actor = World-&gt;SpawnActor&amp;lt;AActor&amp;gt;(<span class="comment">//SpawnActor&amp;lt;生成物体类&gt;</span></span><br><span class="line">ActorClass, <span class="comment">//生成物体是什么类</span></span><br><span class="line"><span class="built_in">FVector</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="comment">//生成位置</span></span><br><span class="line"><span class="built_in">FRotator</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="comment">//生成方向旋转</span></span><br><span class="line">SpawnParams);<span class="comment">//生成参数</span></span><br><span class="line"><span class="comment">//---------精简版：</span></span><br><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditDefaultsOnly)</span><br><span class="line">TSubclassOf&amp;lt;<span class="keyword">class</span> <span class="title class_">AActor</span>&amp;gt; ActorClass;<span class="comment">//此变量可在蓝图类中快速赋值</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">AActor* actor = <span class="built_in">GetWorld</span>()-&gt;SpawnActor&amp;lt;AActor&amp;gt;(</span><br><span class="line">    TSubclassOf&amp;lt;<span class="keyword">class</span> AActor&amp;gt;(), <span class="built_in">FVector</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="built_in">FRotator</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><h2 id="🔥时间"><a href="#🔥时间" class="headerlink" title="🔥时间"></a>🔥时间</h2><h3 id="🚩游戏时间"><a href="#🚩游戏时间" class="headerlink" title="🚩游戏时间"></a>🚩游戏时间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> time = <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetTimeSeconds</span>();<span class="comment">//获取游戏时间</span></span><br></pre></td></tr></table></figure><h2 id="🔥数学"><a href="#🔥数学" class="headerlink" title="🔥数学"></a>🔥数学</h2><h3 id="🚩数值映射"><a href="#🚩数值映射" class="headerlink" title="🚩数值映射"></a>🚩数值映射</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本函数功能与FMath::GetMappedRangeValue()功能一致，但是更简单</span></span><br><span class="line"><span class="comment">//将数值val，从min1至max1的范围，映射至min2至max2的范围</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">Mapping</span><span class="params">(<span class="type">float</span> val, <span class="type">float</span> min1, <span class="type">float</span> max1, <span class="type">float</span> min2, <span class="type">float</span> max2)</span><span class="comment">//MAPPING变量映射</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((val - min1) * (max2 - min2) + min2 * (max1 - min1)) / (max1 - min1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🚩UE坐标轴"><a href="#🚩UE坐标轴" class="headerlink" title="🚩UE坐标轴"></a>🚩UE坐标轴</h3><ul><li>虚幻采用的是左手坐标系</li><li>X为前方向，Y为右方向，Z为上方向</li><li>XYZ旋转对应欧拉角为<code>Roll</code>，<code>Pitch</code>，<code>Yaw</code></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealCPP/RollPitchYaw.png" width=350><ul><li>在此需要强调一下：<ul><li>SceneComponent提供的Detail面板中Rotation的顺序为<code>Roll(X)</code>、<code>Pitch(Y)</code>、<code>Yaw(Z)</code></li><li>而FRotator结构体的构造方法顺序为<code>Pitch(Y)</code>、<code>Yaw(Z)</code>、<code>Roll(X)</code></li></ul></li></ul><h3 id="🚩FMath类常用函数"><a href="#🚩FMath类常用函数" class="headerlink" title="🚩FMath类常用函数"></a>🚩FMath类常用函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FMath::<span class="built_in">Clamp</span>()<span class="comment">//钳制</span></span><br><span class="line">FMath::<span class="built_in">DegreesToRadians</span>()<span class="comment">//角转弧</span></span><br><span class="line">FMath::<span class="built_in">RadiansToDegrees</span>()<span class="comment">//弧转角</span></span><br><span class="line">FMath::<span class="built_in">DivideAndRoundUp</span>()<span class="comment">//除后五入</span></span><br><span class="line">FMath::<span class="built_in">GetMappedRangeValue</span>()<span class="comment">//数值映射（参数需要传入FVector2D）</span></span><br><span class="line">FMath::Lerp/<span class="built_in">LerpStable</span>()<span class="comment">//插值运算</span></span><br><span class="line">FMath::PointDistToLine/<span class="built_in">SphereDistToLine</span>()<span class="comment">//到线段之间的直线距离</span></span><br><span class="line">FMath::<span class="built_in">SmoothStep</span>()<span class="comment">//平滑阶梯</span></span><br><span class="line">FMath::Square/<span class="built_in">Pow</span>()<span class="comment">//指数</span></span><br><span class="line">FMath::Log2/Loge/<span class="built_in">LogX</span>()<span class="comment">//对数</span></span><br><span class="line">FMath::Sin/Cos/Tan/ASin/ACos/<span class="built_in">ATan</span>()<span class="comment">//三角函数</span></span><br></pre></td></tr></table></figure><h2 id="🔥C-通信"><a href="#🔥C-通信" class="headerlink" title="🔥C++通信"></a>🔥C++通信</h2><h3 id="🚩C-与类实例通信"><a href="#🚩C-与类实例通信" class="headerlink" title="🚩C++与类实例通信"></a>🚩C++与类实例通信</h3><ul><li>虚幻场景中一切实例都属于类（包括C++实例和蓝图实例）</li><li>与静态实例通信时：<ul><li>使用暴露和细节面板拖拽的方法，且确保没有空指针</li></ul></li><li>与动态实例通信时：<ul><li>使用查找法，如下</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kismet/GameplayStatics.h&quot;</span></span></span><br><span class="line">TArray&amp;lt;AActor*&amp;gt; Actors;<span class="comment">//存储场景中所有物体</span></span><br><span class="line"><span class="comment">//通过标签查找物体</span></span><br><span class="line">UGameplayStatics::<span class="built_in">GetAllActorsWithTag</span>(</span><br><span class="line">    <span class="built_in">GetWorld</span>(), <span class="built_in">TEXT</span>(<span class="string">&quot;myTag&quot;</span>), Actors);</span><br><span class="line"><span class="comment">//通过类查找物体</span></span><br><span class="line">UGameplayStatics::<span class="built_in">GetAllActorsOfClass</span>(</span><br><span class="line">    <span class="built_in">GetWorld</span>(), TSubclassOf&amp;lt;AActor&amp;gt;(), Actors);</span><br><span class="line"><span class="comment">//通过标签和类查找物体</span></span><br><span class="line">UGameplayStatics::<span class="built_in">GetAllActorsOfClassWithTag</span>(</span><br><span class="line">    <span class="built_in">GetWorld</span>(), TSubclassOf&amp;lt;AActor&amp;gt;(), <span class="built_in">TEXT</span>(<span class="string">&quot;myTag&quot;</span>), Actors);</span><br><span class="line"><span class="comment">//遍历返回到的物体数组</span></span><br><span class="line"><span class="keyword">for</span> (AActor* Actor: Actors)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Cast&amp;lt;APawn&amp;gt;(Actor))<span class="comment">//Cast用于监测并过滤掉与APawn类无关的类型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🚩C-与派生蓝图类通信"><a href="#🚩C-与派生蓝图类通信" class="headerlink" title="🚩C++与派生蓝图类通信"></a>🚩C++与派生蓝图类通信</h3><ul><li>派生蓝图类获取C++成员变量，见下图</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadWrite, Category = <span class="string">&quot;Props&quot;</span>)</span><br><span class="line"><span class="type">float</span> myFloat;</span><br></pre></td></tr></table></figure><ul><li>派生蓝图类获取C++成员方法，见下图</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Functions&quot;</span>)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span></span>;<span class="comment">//别忘了实现</span></span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealCPP/BlueprintCalling1.png" width=400><ul><li>派生蓝图类重写C++类方法（C++调用其派生蓝图类的方法）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件内 -----------------------------------</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintNativeEvent, Category = <span class="string">&quot;Game&quot;</span>)<span class="comment">//设置反射蓝图可重写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyEventFunction</span><span class="params">()</span></span>;<span class="comment">//主方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyEventFunction_Implementation</span><span class="params">()</span></span>;<span class="comment">//主方法实现体（一个字都不能少）</span></span><br><span class="line"><span class="comment">// 源文件内 -----------------------------------</span></span><br><span class="line"><span class="type">void</span> 类名::<span class="built_in">MyEventFunction_Implementation</span>() &#123;&#125;<span class="comment">//主方法实现体实现</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> 类名::<span class="built_in">BeginPlay</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">MyEventFunction</span>();<span class="comment">//在代码内调用此方法，这时如果其派生蓝图类中已有重写，则调用重写方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealCPP/BlueprintCalling2.png" width=500><h3 id="🚩C-与材质通信"><a href="#🚩C-与材质通信" class="headerlink" title="🚩C++与材质通信"></a>🚩C++与材质通信</h3><h3 id="🚩C-蓝图脚本库"><a href="#🚩C-蓝图脚本库" class="headerlink" title="🚩C++蓝图脚本库"></a>🚩C++蓝图脚本库</h3><ul><li>创建C++类继承自<code>UBlueprintFunctionLibrary</code>类</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件内 -----------------------------------</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PROJECTFORBLUEPRINT_API</span> UMyBPLib : <span class="keyword">public</span> UBlueprintFunctionLibrary</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="comment">//在下面写功能性方法</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Functions&quot;</span>)</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">MyBPFunction</span><span class="params">()</span></span>;<span class="comment">//必须静态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 源文件内 -----------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMyBPLib::MyBPFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Blue, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealCPP/BlueprintCalling3.png" width=650><h2 id="🔥GamePlay基础框架"><a href="#🔥GamePlay基础框架" class="headerlink" title="🔥GamePlay基础框架"></a>🔥GamePlay基础框架</h2><h3 id="🚩游戏模式GameMode"><a href="#🚩游戏模式GameMode" class="headerlink" title="🚩游戏模式GameMode"></a>🚩游戏模式GameMode</h3><ul><li><code>游戏模式GameMode</code>用于构建实现游戏和规则</li><li><code>游戏模式类AGameModeBase</code>的作用是存储一些与游戏规则相关的配置</li><li>项目设置中的游戏规则用于默认，世界设置中用于重载</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealCPP/GamePlayFramework_1.png" width=800><h3 id="🚩基础游戏框架"><a href="#🚩基础游戏框架" class="headerlink" title="🚩基础游戏框架"></a>🚩基础游戏框架</h3><ul><li>游戏模式GameMode<code>AGameModeBase</code><ul><li>游戏状态GameState<code>AGameStateBase</code></li><li>玩家控制器playerController<code>APlayerController</code><ul><li>玩家相机控制器playerCameraController<code>APlayerCameraManager</code></li></ul></li><li>玩家状态PlayerState<code>APlayerState</code></li><li>用户界面HUD<code>AHUD</code></li><li>默认玩家DefaultPawn<code>APawn</code></li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealCPP/GamePlayFramework_2.png" width=600><h3 id="🚩生成体Pawn"><a href="#🚩生成体Pawn" class="headerlink" title="🚩生成体Pawn"></a>🚩生成体Pawn</h3><ul><li>Pawn是所有玩家与AI生成体的基类</li><li>DefaultPawn指默认玩家</li><li>默认玩家需要通过控制器进行控制，才能接收输入</li></ul><h3 id="🚩GameplayStatics类"><a href="#🚩GameplayStatics类" class="headerlink" title="🚩GameplayStatics类"></a>🚩GameplayStatics类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kismet/GameplayStatics.h&quot;</span><span class="comment">//游戏信息类</span></span></span><br><span class="line"><span class="comment">// ---------------------------------</span></span><br><span class="line">APlayerController* PlayerController = </span><br><span class="line">    UGameplayStatics::<span class="built_in">GetPlayerController</span>(GWorld, <span class="number">0</span>);<span class="comment">//此类可以方便获取游戏信息</span></span><br></pre></td></tr></table></figure><h2 id="🔥界面UMG"><a href="#🔥界面UMG" class="headerlink" title="🔥界面UMG"></a>🔥界面UMG</h2><h3 id="🚩界面绘制"><a href="#🚩界面绘制" class="headerlink" title="🚩界面绘制"></a>🚩界面绘制</h3><ul><li>通常不使用代码的方式来添加游戏UI，而是使用编辑器</li></ul><p>UTexture2D    2D贴图类</p><p>AHUD::DrawHUD()    绘制界面函数</p><p>FCanvasItem    界面物体基类</p><p>AHUD::Canvas.DrawItem()    将界面物体绘制到界面上函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HUD派生头文件内 -----------------------------------</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditDefaultsOnly)</span><br><span class="line">UTexture2D* tex;<span class="comment">//声明贴图文件</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawHUD</span><span class="params">()</span> <span class="keyword">override</span></span>;<span class="comment">//界面绘制函数</span></span><br><span class="line"><span class="comment">// HUD派生源文件内 -----------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSHUD::DrawHUD</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">DrawHUD</span>();<span class="comment">//父类调用</span></span><br><span class="line">    <span class="keyword">if</span> (tex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">FVector2D <span class="title">Center</span><span class="params">(<span class="comment">//画布中心点</span></span></span></span><br><span class="line"><span class="params"><span class="function">            Canvas-&gt;ClipX * <span class="number">0.5f</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">            Canvas-&gt;ClipY * <span class="number">0.5f</span>)</span></span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="function">FVector2D <span class="title">Pos</span><span class="params">(<span class="comment">//图像对齐，默认以图像左上角为原点生成</span></span></span></span><br><span class="line"><span class="params"><span class="function">            Center.X - (tex-&gt;GetSurfaceWidth() * <span class="number">0.5f</span>), </span></span></span><br><span class="line"><span class="params"><span class="function">            Center.Y - (tex-&gt;GetSurfaceHeight() * <span class="number">0.5f</span>))</span></span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="function">FCanvasTileItem <span class="title">TileItem</span><span class="params">(<span class="comment">//绘制界面</span></span></span></span><br><span class="line"><span class="params"><span class="function">            Pos, <span class="comment">//位置</span></span></span></span><br><span class="line"><span class="params"><span class="function">            tex-&gt;Resource, <span class="comment">//资源</span></span></span></span><br><span class="line"><span class="params"><span class="function">            FLinearColor::White)</span></span>;<span class="comment">//颜色覆盖</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        TileItem.BlendMode = SE_BLEND_Translucent;<span class="comment">//混合模式</span></span><br><span class="line">        Canvas-&gt;<span class="built_in">DrawItem</span>(TileItem);<span class="comment">//绘制到Canvas上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🚩界面装配"><a href="#🚩界面装配" class="headerlink" title="🚩界面装配"></a>🚩界面装配</h3><ul><li>界面装配使用蓝图</li><li>创建<code>UMG可视化UI生成器</code>并制作UI</li><li>在HUD类里使用节点<code>BeginPlay</code>-&gt;<code>CreateWidget</code>-&gt;<code>AddToViewport</code>进行装配</li></ul><h3 id="🚩界面绑定"><a href="#🚩界面绑定" class="headerlink" title="🚩界面绑定"></a>🚩界面绑定</h3><ul><li>使用蓝图来绑定</li><li>在UI绑定函数节点里使用GetAllActorsOfClass-&gt;Get(0)-&gt;CastTo-&gt;获取C++暴露的成员变量或方法</li></ul><h2 id="🔥标签Tag"><a href="#🔥标签Tag" class="headerlink" title="🔥标签Tag"></a>🔥标签Tag</h2><h3 id="🚩标签设置"><a href="#🚩标签设置" class="headerlink" title="🚩标签设置"></a>🚩标签设置</h3><ul><li>标签有两种：<ul><li>物体<code>Actor标签</code></li><li>组件<code>Component标签</code></li></ul></li><li>设置物体Actor标签：<ul><li>所有<code>场景物体Actor</code>自身<code>self</code>都有<code>Actor模块</code>，在<code>Actor模块</code>最下方设置标签</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealCPP/ActorTags.png" width=400><ul><li>设置组件Component标签：<ul><li>所有<code>组件Component</code>都有<code>Tags模块</code>，可以直接设置标签</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealCPP/ComponentTags.png" width=400><h3 id="🚩标签判断"><a href="#🚩标签判断" class="headerlink" title="🚩标签判断"></a>🚩标签判断</h3><ul><li>物体Actor</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AActor* act;<span class="comment">//需要判断标签的物体</span></span><br><span class="line"><span class="keyword">for</span> (FName tag : act-&gt;Tags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag == <span class="built_in">FName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;tagged&quot;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;is tagged&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>组件Component</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">USceneComponent* comp;<span class="comment">//需要判断标签的组件</span></span><br><span class="line"><span class="keyword">for</span> (FName tag : comp-&gt;ComponentTags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag == <span class="built_in">FName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;tagged&quot;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;is tagged&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🔥输入映射"><a href="#🔥输入映射" class="headerlink" title="🔥输入映射"></a>🔥输入映射</h2><ul><li>虚幻的输入系统由<code>ActionMapping</code>和<code>AxisMapping</code>组成</li><li><code>ActionMapping</code>包含所有瞬间输入</li><li><code>AxisMapping</code>包含所有持续输入</li><li><code>SpeechMapping</code>是新加的语音识别映射</li><li>所有输入映射需要先在项目设置里设置好，并设置缩放权衡值（Scale）</li><li>依此输入系统，自定义类必须继承自<code>APawn</code>类，因为需要重写的绑定函数是<code>APawn</code>类成员</li><li><code>工程设置Project Settings</code>的<code>输入Input</code>中的第一栏是<code>绑定Bindings</code>设置</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealCPP/InputSettings.png" width=500><h3 id="🚩绑定函数"><a href="#🚩绑定函数" class="headerlink" title="🚩绑定函数"></a>🚩绑定函数</h3><p>SetupPlayerInputComponent()    玩家输入绑定函数</p><p>UInputComponent::BindAxis()    轴输入绑定函数</p><p>UInputComponent::BindAction()    动作输入绑定函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --------------------- 类APlayerManager头文件</span></span><br><span class="line"><span class="comment">//若要进行输入绑定，则需要声明实现“SetupPlayerInputComponent”函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span></span></span><br><span class="line"><span class="function"><span class="params">(<span class="keyword">class</span> UInputComponent* InputCom)</span> <span class="keyword">override</span></span>;<span class="comment">//重写绑定函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> value)</span></span>;<span class="comment">//轴传递需要传一个参，用于接收数据，动作传递不需要</span></span><br><span class="line"><span class="comment">// --------------------- 类APlayerManager源文件</span></span><br><span class="line"><span class="comment">//具体实现需要使用UInputComponent::BindAxis/BindAction函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APlayerManager::SetupPlayerInputComponent</span><span class="params">(UInputComponent* InputCom)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">SetupPlayerInputComponent</span>(InputCom);</span><br><span class="line">InputCom-&gt;<span class="built_in">BindAxis</span></span><br><span class="line">        (<span class="string">&quot;MoveForward&quot;</span>, <span class="comment">//在项目设置的Input里设置的值的名称</span></span><br><span class="line">         <span class="keyword">this</span>, <span class="comment">//本类实例指针</span></span><br><span class="line">         &amp;APlayerManager::MoveForward);<span class="comment">//执行函数地址：&amp;类名::函数名</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    InputCom-&gt;<span class="built_in">BindAction</span></span><br><span class="line">        (<span class="string">&quot;Jump&quot;</span>, <span class="comment">//在项目设置的Input里设置的值的名称</span></span><br><span class="line">         EInputEvent::IE_Pressed, <span class="comment">//触发事件类型：按下、松开等</span></span><br><span class="line">         <span class="keyword">this</span>, <span class="comment">//本类实例指针</span></span><br><span class="line">         &amp;APlayerManager::StartJump);<span class="comment">//执行函数地址：&amp;类名::函数名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APlayerManager::MoveForward</span><span class="params">(<span class="type">float</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🚩输入绑定案例"><a href="#🚩输入绑定案例" class="headerlink" title="🚩输入绑定案例"></a>🚩输入绑定案例</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PlayerManager.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TESTFORUE5_1_API</span> APlayerManager : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">APlayerManager</span>();<span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SetupPlayerInputComponent输入绑定函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span></span></span><br><span class="line"><span class="function"><span class="params">(<span class="keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span>;<span class="comment">//前后移动</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span>;<span class="comment">//左右移动</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartJump</span><span class="params">()</span></span>;<span class="comment">//按下键时，设置跳跃标记</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StopJump</span><span class="params">()</span></span>;<span class="comment">//释放键时，清除跳跃标记</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PlayerManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">APlayerManager::<span class="built_in">APlayerManager</span>()<span class="comment">//构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;<span class="comment">//是否调用Tick函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APlayerManager::BeginPlay</span><span class="params">()</span><span class="comment">//初始化函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();<span class="comment">//父类先调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APlayerManager::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span><span class="comment">//运行函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Tick</span>(DeltaTime);<span class="comment">//父类先调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APlayerManager::SetupPlayerInputComponent</span><span class="params">(UInputComponent* InputCom)</span><span class="comment">//输入绑定函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">SetupPlayerInputComponent</span>(InputCom);<span class="comment">//父类先调用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//轴绑定BindAxis(&quot;外部设置值&quot;,本类实例指针,执行函数);</span></span><br><span class="line"><span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">InputCom-&gt;<span class="built_in">BindAxis</span></span><br><span class="line">        (<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;APlayerManager::MoveForward);</span><br><span class="line">InputCom-&gt;<span class="built_in">BindAxis</span></span><br><span class="line">        (<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;APlayerManager::MoveRight);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 设置&quot;视角&quot;绑定。</span></span><br><span class="line">InputCom-&gt;<span class="built_in">BindAxis</span></span><br><span class="line">        (<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;APlayerManager::AddControllerYawInput);<span class="comment">//父类函数继承</span></span><br><span class="line">InputCom-&gt;<span class="built_in">BindAxis</span></span><br><span class="line">        (<span class="string">&quot;LookUp&quot;</span>, <span class="keyword">this</span>, &amp;APlayerManager::AddControllerPitchInput);<span class="comment">//父类函数继承</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//动作绑定BindAction(&quot;外部设置值&quot;,触发事件枚举,本类实例指针,执行函数);</span></span><br><span class="line"><span class="comment">// 设置&quot;跳跃&quot;绑定。</span></span><br><span class="line">InputCom-&gt;<span class="built_in">BindAction</span></span><br><span class="line">        (<span class="string">&quot;Jump&quot;</span>, EInputEvent::IE_Pressed, <span class="keyword">this</span>, &amp;APlayerManager::StartJump);</span><br><span class="line">InputCom-&gt;<span class="built_in">BindAction</span></span><br><span class="line">        (<span class="string">&quot;Jump&quot;</span>, EInputEvent::IE_Released, <span class="keyword">this</span>, &amp;APlayerManager::StopJump);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APlayerManager::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span><span class="comment">//玩家前后移动</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FVector Direction = \</span><br><span class="line"><span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line"><span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APlayerManager::MoveRight</span><span class="params">(<span class="type">float</span> Value)</span><span class="comment">//玩家左右移动</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FVector Direction = \</span><br><span class="line"><span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::Y);</span><br><span class="line"><span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APlayerManager::StartJump</span><span class="params">()</span><span class="comment">//玩家开始跳跃</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bPressedJump = <span class="literal">true</span>;<span class="comment">//注意：该标识符定义于ACharacter类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APlayerManager::StopJump</span><span class="params">()</span><span class="comment">//玩家结束跳跃</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bPressedJump = <span class="literal">false</span>;<span class="comment">//注意：该标识符定义于ACharacter类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🔥事件与委托"><a href="#🔥事件与委托" class="headerlink" title="🔥事件与委托"></a>🔥事件与委托</h2><h3 id="🚩常用蓝图交互事件"><a href="#🚩常用蓝图交互事件" class="headerlink" title="🚩常用蓝图交互事件"></a>🚩常用蓝图交互事件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明动态多投射委托</span></span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE</span>(FMyEvent);<span class="comment">//在头文件类的上面注宏</span></span><br><span class="line"><span class="comment">// -----------------------------</span></span><br><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable)<span class="comment">//蓝图可指定</span></span><br><span class="line">FMyEvent OnMyEvent_1;</span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable)<span class="comment">//蓝图可指定</span></span><br><span class="line">FMyEvent OnMyEvent_2;</span><br><span class="line"><span class="comment">// -----------------------------</span></span><br><span class="line"><span class="comment">// 源文件</span></span><br><span class="line">OnMyEvent_1.<span class="built_in">Broadcast</span>();<span class="comment">//广播（触发事件）</span></span><br><span class="line">OnMyEvent_2.<span class="built_in">Broadcast</span>();<span class="comment">//广播（触发事件）</span></span><br></pre></td></tr></table></figure><ul><li>在此物体类蓝图中，可以找到在C++中声明的事件</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealCPP/DelegateBlueprint.png" width=450><h2 id="🔥碰撞"><a href="#🔥碰撞" class="headerlink" title="🔥碰撞"></a>🔥碰撞</h2><ul><li><p><code>AActor</code>是所有物体碰撞事件的父类，此物体类携带<code>Collision</code>模块</p></li><li><p><code>UPrimitiveComponent</code>是所有组件碰撞事件的父类，此组件类携带<code>Collision</code>模块</p></li></ul><h3 id="🚩碰撞通道"><a href="#🚩碰撞通道" class="headerlink" title="🚩碰撞通道"></a>🚩碰撞通道</h3><ul><li><code>工程设置Project Settings</code>的<code>碰撞Collision</code>中的第一栏是<code>物体通道Object Channels</code>设置</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealCPP/ObjectChannels.png" width=650><ul><li>点击<code>New Object Channel</code>来新建物体通道</li><li>设置物体通道默认值为<code>无视Ignore</code>，在预设中有需要的情况下再做改动</li></ul><h3 id="🚩物体碰撞需求"><a href="#🚩物体碰撞需求" class="headerlink" title="🚩物体碰撞需求"></a>🚩物体碰撞需求</h3><h4 id="要求一：物理模拟"><a href="#要求一：物理模拟" class="headerlink" title="要求一：物理模拟"></a>要求一：物理模拟</h4><ul><li>至少有一方开启<code>物理模拟Simulate Physics</code></li></ul><h4 id="要求二：功能开关"><a href="#要求二：功能开关" class="headerlink" title="要求二：功能开关"></a>要求二：功能开关</h4><ul><li>在网格组件中的<code>碰撞模块Collision</code>里进行以下设置</li><li>当信息接收方<code>碰撞事件检测Simulate Generates Hit Events</code>开启时，若至少一方物理模拟开启，则能接收碰撞事件</li><li>当必须双方<code>覆盖事件检测Generates Overlap Events</code>开启时，才能接收覆盖事件</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealCPP/SimulateGeneratesHitEvents.png" width=400><h4 id="要求三：碰撞方法"><a href="#要求三：碰撞方法" class="headerlink" title="要求三：碰撞方法"></a>要求三：碰撞方法</h4><ul><li><code>碰撞方法Collision Enabled</code>：<ul><li>此方法的<code>产生碰撞覆盖信息</code>仅对于该物体自身起作用，对于其他物体无效</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealCPP/CollisionEnabled.png" width=450><table><thead><tr><th>碰撞方法</th><th>产生碰撞覆盖信息</th><th>产生物理效果</th></tr></thead><tbody><tr><td>无碰撞  NoCollision</td><td>否</td><td>否</td></tr><tr><td>仅信息  QueryOnly</td><td>是</td><td>否</td></tr><tr><td>仅物理  PhysicsOnly</td><td>否</td><td>是</td></tr><tr><td>有碰撞  CollisionEnable</td><td>是</td><td>是</td></tr></tbody></table><h4 id="要求四：通道设置"><a href="#要求四：通道设置" class="headerlink" title="要求四：通道设置"></a>要求四：通道设置</h4><ul><li><code>碰撞响应Collision Responses</code>:<ul><li>凡一方对另一方<code>碰撞通道</code>设置<code>无视Ignore</code>，则双方相互穿过，双方不发生任何响应</li><li>以上条为基准，凡一方对另一方<code>碰撞通道</code>设置<code>覆盖Overlap</code>，则双方相互穿过，双方发生<code>覆盖</code>响应</li><li>只有双方对对方<code>碰撞通道</code>设置<code>碰撞Block</code>，则双方相互碰撞，双方发生碰撞响应</li></ul></li><li>在<code>物体类型Object Type</code>中为该物体赋予用户自定义类型，自定义类型会出现在<code>物体响应Object Responses</code>下</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealCPP/Collision Responses.png" width=400><table><thead><tr><th>碰撞响应</th><th>B_Ignore</th><th>B_Overlap</th><th>B_Block</th></tr></thead><tbody><tr><td>A_Ignore</td><td>AB_Ignore</td><td>AB_Ignore</td><td>AB_Ignore</td></tr><tr><td>A_Overlap</td><td>AB_Ignore</td><td>AB_Overlap</td><td>AB_Overlap</td></tr><tr><td>A_Block</td><td>AB_Ignore</td><td>AB_Overlap</td><td>AB_Block</td></tr></tbody></table><ul><li>以上是物体碰撞四大要求</li></ul><h3 id="🚩碰撞与覆盖检测"><a href="#🚩碰撞与覆盖检测" class="headerlink" title="🚩碰撞与覆盖检测"></a>🚩碰撞与覆盖检测</h3><h4 id="物体，函数重写"><a href="#物体，函数重写" class="headerlink" title="物体，函数重写"></a>物体，函数重写</h4><ul><li><p>以下是采用物体类的函数重写法来检测碰撞，缺点是无法定位碰撞组件</p></li><li><p>物体Actor进入覆盖：<code>AActor::NotifyActorBeginOverlap</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件中--------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NotifyActorBeginOverlap</span><span class="params">(AActor* Other)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">// 源文件中--------------------------</span></span><br><span class="line"><span class="comment">// 触发进入检测（物体）函数重写</span></span><br><span class="line"><span class="type">void</span> 自定义类名::<span class="built_in">NotifyActorBeginOverlap</span>(AActor* Other)</span><br><span class="line">&#123;</span><br><span class="line">Super::<span class="built_in">NotifyActorBeginOverlap</span>(Other);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (Cast&amp;lt;AActor&amp;gt;(Other))<span class="comment">//Cast用于监测并过滤掉与AActor类无关的类型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;---begin %s&quot;</span>), *(Other-&gt;<span class="built_in">GetName</span>()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>物体Actor离开覆盖：<code>AActor::NotifyActorEndOverlap</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件中--------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NotifyActorEndOverlap</span><span class="params">(AActor* Other)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">// 源文件中--------------------------</span></span><br><span class="line"><span class="comment">// 触发离开检测（物体）函数重写</span></span><br><span class="line"><span class="type">void</span> 自定义类名::<span class="built_in">NotifyActorEndOverlap</span>(AActor* Other)</span><br><span class="line">&#123;</span><br><span class="line">Super::<span class="built_in">NotifyActorEndOverlap</span>(Other);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (Cast&amp;lt;AActor&amp;gt;(Other))<span class="comment">//Cast用于监测并过滤掉与AActor类无关的类型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;---end %s&quot;</span>), *(Other-&gt;<span class="built_in">GetName</span>()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>物体Actor碰撞：<code>AActor::NotifyHit</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件中--------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NotifyHit</span><span class="params">(<span class="keyword">class</span> UPrimitiveComponent* MyComp, AActor* Other, </span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">class</span> UPrimitiveComponent* OtherComp, <span class="type">bool</span> bSelfMoved, </span></span></span><br><span class="line"><span class="params"><span class="function">               FVector HitLocation, FVector HitNormal, </span></span></span><br><span class="line"><span class="params"><span class="function">               FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">// 源文件中--------------------------</span></span><br><span class="line"><span class="comment">// 碰撞（物体）函数重写</span></span><br><span class="line"><span class="type">void</span> 自定义类名::<span class="built_in">NotifyHit</span>(UPrimitiveComponent* MyComp, AActor* Other, </span><br><span class="line">                      UPrimitiveComponent* OtherComp, <span class="type">bool</span> bSelfMoved, </span><br><span class="line">                      FVector HitLocation, FVector HitNormal, </span><br><span class="line">                      FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span><br><span class="line">&#123;</span><br><span class="line">Super::<span class="built_in">NotifyHit</span>(MyComp, Other, OtherComp, bSelfMoved, </span><br><span class="line">                     HitLocation, HitNormal, NormalImpulse, Hit);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (Cast&amp;lt;AActor&amp;gt;(Other))<span class="comment">//Cast用于监测并过滤掉与AActor类无关的类型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;---hit %s&quot;</span>), *(Other-&gt;<span class="built_in">GetName</span>()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组件与物体，委托"><a href="#组件与物体，委托" class="headerlink" title="组件与物体，委托"></a>组件与物体，委托</h4><ul><li>以下是采用委托法来检测碰撞，缺点是复杂</li></ul><ul><li>组件Component进入覆盖：<code>UPrimitiveComponent::OnComponentBeginOverlap</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件中--------------------------</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BoxOverlapBegin</span><span class="params">(<span class="keyword">class</span> UPrimitiveComponent* HitComp, <span class="keyword">class</span> AActor* OtherActor, </span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">class</span> UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, </span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">bool</span> bFromSweep, <span class="type">const</span> FHitResult&amp; SweepResult)</span></span>;</span><br><span class="line"><span class="comment">// 源文件中--------------------------</span></span><br><span class="line"><span class="type">void</span> 自定义类名::<span class="built_in">BeginPlay</span>()<span class="comment">//委托需要在BeginPlay中设置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// -----委托法</span></span><br><span class="line">    FScriptDelegate dele_Begin;<span class="comment">//委托体</span></span><br><span class="line">dele_Begin.<span class="built_in">BindUFunction</span>(<span class="keyword">this</span>, <span class="string">&quot;BoxOverlapBegin&quot;</span>);<span class="comment">//委托体绑定函数</span></span><br><span class="line">boxCollision-&gt;OnComponentBeginOverlap.<span class="built_in">Add</span>(dele_Begin);<span class="comment">//组件事件绑定委托体</span></span><br><span class="line">    <span class="comment">// -----动态委托法</span></span><br><span class="line">    boxCollision-&gt;OnComponentBeginOverlap.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;自定义类名::BoxOverlapBegin);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 触发进入检测（组件）委托</span></span><br><span class="line"><span class="type">void</span> 自定义类名::<span class="built_in">BoxOverlapBegin</span>(<span class="keyword">class</span> UPrimitiveComponent* HitComp, <span class="keyword">class</span> AActor* OtherActor, </span><br><span class="line">                            <span class="keyword">class</span> UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, </span><br><span class="line">                            <span class="type">bool</span> bFromSweep, <span class="type">const</span> FHitResult&amp; SweepResult)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (OtherActor == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;---begin %s&quot;</span>), *OtherActor-&gt;<span class="built_in">GetName</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>组件Component离开覆盖：<code>UPrimitiveComponent::OnComponentEndOverlap</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件中--------------------------</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BoxOverlapEnd</span><span class="params">(<span class="keyword">class</span> UPrimitiveComponent* HitComp, <span class="keyword">class</span> AActor* OtherActor, </span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">class</span> UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)</span></span>;</span><br><span class="line"><span class="comment">// 源文件中--------------------------</span></span><br><span class="line"><span class="type">void</span> 自定义类名::<span class="built_in">BeginPlay</span>()<span class="comment">//委托需要在BeginPlay中设置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// -----委托法</span></span><br><span class="line">    FScriptDelegate dele_End;<span class="comment">//委托体</span></span><br><span class="line">dele_End.<span class="built_in">BindUFunction</span>(<span class="keyword">this</span>, <span class="string">&quot;BoxOverlapEnd&quot;</span>);<span class="comment">//委托体绑定函数</span></span><br><span class="line">boxCollision-&gt;OnComponentEndOverlap.<span class="built_in">Add</span>(dele_End);<span class="comment">//组件事件绑定委托体</span></span><br><span class="line">    <span class="comment">// -----动态委托法</span></span><br><span class="line">    boxCollision-&gt;OnComponentEndOverlap.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;自定义类名::BoxOverlapEnd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 触发离开检测（组件）委托</span></span><br><span class="line"><span class="type">void</span> 自定义类名::<span class="built_in">BoxOverlapEnd</span>(<span class="keyword">class</span> UPrimitiveComponent* HitComp, <span class="keyword">class</span> AActor* OtherActor, </span><br><span class="line">                   <span class="keyword">class</span> UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (OtherActor == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;---end %s&quot;</span>), *OtherActor-&gt;<span class="built_in">GetName</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>组件Component碰撞：<code>UPrimitiveComponent::OnComponentHit</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件中--------------------------</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BoxHit</span><span class="params">(<span class="keyword">class</span> UPrimitiveComponent* HitComponent, <span class="keyword">class</span> AActor* OtherActor, </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">class</span> UPrimitiveComponent* OtherComp, FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span></span>;</span><br><span class="line"><span class="comment">// 源文件中--------------------------</span></span><br><span class="line"><span class="type">void</span> 自定义类名::<span class="built_in">BeginPlay</span>()<span class="comment">//委托需要在BeginPlay中设置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// -----委托法</span></span><br><span class="line">    FScriptDelegate dele_Hit;<span class="comment">//委托体</span></span><br><span class="line">dele_Hit.<span class="built_in">BindUFunction</span>(<span class="keyword">this</span>, <span class="string">&quot;BoxHit&quot;</span>);<span class="comment">//委托体绑定函数</span></span><br><span class="line">boxCollision-&gt;OnComponentHit.<span class="built_in">Add</span>(dele_Hit);<span class="comment">//组件事件绑定委托体</span></span><br><span class="line">    <span class="comment">// -----动态委托法</span></span><br><span class="line">    boxCollision-&gt;OnComponentHit.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;自定义类名::BoxHit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 触发离开检测（组件）委托</span></span><br><span class="line"><span class="type">void</span> 自定义类名::<span class="built_in">BoxHit</span>(<span class="keyword">class</span> UPrimitiveComponent* HitComponent, <span class="keyword">class</span> AActor* OtherActor, </span><br><span class="line">            <span class="keyword">class</span> UPrimitiveComponent* OtherComp, FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (OtherActor == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;---hit %s&quot;</span>), *OtherActor-&gt;<span class="built_in">GetName</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>物体Actor进入覆盖：<code>AActor::OnActorBeginOverlap</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件中--------------------------</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BoxOverlapBegin</span><span class="params">(<span class="keyword">class</span> AActor* OverlappedActor, <span class="keyword">class</span> AActor* OtherActor)</span></span>;</span><br><span class="line"><span class="comment">// 源文件中--------------------------</span></span><br><span class="line"><span class="type">void</span> 自定义类名::<span class="built_in">BeginPlay</span>()<span class="comment">//委托需要在BeginPlay中设置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// -----委托法</span></span><br><span class="line">    FScriptDelegate dele_Begin;<span class="comment">//委托体</span></span><br><span class="line">dele_Begin.<span class="built_in">BindUFunction</span>(<span class="keyword">this</span>, <span class="string">&quot;BoxOverlapBegin&quot;</span>);<span class="comment">//委托体绑定函数</span></span><br><span class="line">boxCollision-&gt;OnActorBeginOverlap.<span class="built_in">Add</span>(dele_Begin);<span class="comment">//组件事件绑定委托体</span></span><br><span class="line">    <span class="comment">// -----动态委托法</span></span><br><span class="line">    boxCollision-&gt;OnActorBeginOverlap.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;自定义类名::BoxOverlapBegin);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 触发离开检测（组件）委托</span></span><br><span class="line"><span class="type">void</span> 自定义类名::<span class="built_in">BoxOverlapBegin</span>(<span class="keyword">class</span> AActor* OverlappedActor, <span class="keyword">class</span> AActor* OtherActor)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (OtherActor == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;---begin %s&quot;</span>), *OtherActor-&gt;<span class="built_in">GetName</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>物体Actor离开覆盖：<code>AActor::OnActorEndOverlap</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件中--------------------------</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BoxOverlapEnd</span><span class="params">(<span class="keyword">class</span> AActor* OverlappedActor, <span class="keyword">class</span> AActor* OtherActor)</span></span>;</span><br><span class="line"><span class="comment">// 源文件中--------------------------</span></span><br><span class="line"><span class="type">void</span> 自定义类名::<span class="built_in">BeginPlay</span>()<span class="comment">//委托需要在BeginPlay中设置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// -----委托法</span></span><br><span class="line">    FScriptDelegate dele_End;<span class="comment">//委托体</span></span><br><span class="line">dele_End.<span class="built_in">BindUFunction</span>(<span class="keyword">this</span>, <span class="string">&quot;BoxOverlapEnd&quot;</span>);<span class="comment">//委托体绑定函数</span></span><br><span class="line">boxCollision-&gt;OnActorEndOverlap.<span class="built_in">Add</span>(dele_End);<span class="comment">//组件事件绑定委托体</span></span><br><span class="line">    <span class="comment">// -----动态委托法</span></span><br><span class="line">    boxCollision-&gt;OnActorEndOverlap.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;自定义类名::BoxOverlapEnd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 触发离开检测（组件）委托</span></span><br><span class="line"><span class="type">void</span> 自定义类名::<span class="built_in">BoxOverlapEnd</span>(<span class="keyword">class</span> AActor* OverlappedActor, <span class="keyword">class</span> AActor* OtherActor)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (OtherActor == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;---end %s&quot;</span>), *OtherActor-&gt;<span class="built_in">GetName</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>物体Actor碰撞：<code>AActor::OnActorHit</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件中--------------------------</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BoxHit</span><span class="params">(<span class="keyword">class</span> AActor* SelfActor, <span class="keyword">class</span> AActor* OtherActor, </span></span></span><br><span class="line"><span class="params"><span class="function">            FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span></span>;</span><br><span class="line"><span class="comment">// 源文件中--------------------------</span></span><br><span class="line"><span class="type">void</span> 自定义类名::<span class="built_in">BeginPlay</span>()<span class="comment">//委托需要在BeginPlay中设置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// -----委托法</span></span><br><span class="line">    FScriptDelegate dele_Hit;<span class="comment">//委托体</span></span><br><span class="line">dele_Hit.<span class="built_in">BindUFunction</span>(<span class="keyword">this</span>, <span class="string">&quot;BoxHit&quot;</span>);<span class="comment">//委托体绑定函数</span></span><br><span class="line">boxCollision-&gt;OnActorHit.<span class="built_in">Add</span>(dele_Hit);<span class="comment">//组件事件绑定委托体</span></span><br><span class="line">    <span class="comment">// -----动态委托法</span></span><br><span class="line">    boxCollision-&gt;OnActorHit.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;自定义类名::BoxHit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 触发离开检测（组件）委托</span></span><br><span class="line"><span class="type">void</span> 自定义类名::<span class="built_in">BoxHit</span>(<span class="keyword">class</span> AActor* OverlappedActor, <span class="keyword">class</span> AActor* OtherActor)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (OtherActor == <span class="literal">nullptr</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="built_in">UE_LOG</span>(LogTemp, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;---hit %s&quot;</span>), *OtherActor-&gt;<span class="built_in">GetName</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🚩鼠标进入检测"><a href="#🚩鼠标进入检测" class="headerlink" title="🚩鼠标进入检测"></a>🚩鼠标进入检测</h3><ul><li>使用鼠标检测功能，必须设置鼠标可视和允许检测</li><li>在创建的玩家控制器里<code>鼠标接口栏MouseInterface</code>中设置</li></ul><p>UPrimitiveComponent::OnBeginCursorOver</p><p>UPrimitiveComponent::OnEndCursorOver</p><p>UPrimitiveComponent::OnClicked</p><p>UPrimitiveComponent::OnReleased</p><p>UPrimitiveComponent::OnInputTouchBegin</p><p>UPrimitiveComponent::OnInputTouchEnd</p><p>UPrimitiveComponent::OnInputTouchEnter</p><p>UPrimitiveComponent::OnInputTouchLeave</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//鼠标进入事件可以类似碰撞检测，可以用上述碰撞检测的委托法来写</span></span><br></pre></td></tr></table></figure><h2 id="🔥射线检测"><a href="#🔥射线检测" class="headerlink" title="🔥射线检测"></a>🔥射线检测</h2><h3 id="🚩射线通道"><a href="#🚩射线通道" class="headerlink" title="🚩射线通道"></a>🚩射线通道</h3><ul><li><code>工程设置Project Settings</code>的<code>碰撞Collision</code>中的第二栏是<code>射线通道Trace Channels</code>设置</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealCPP/TraceChannels.png" width=650><ul><li>点击<code>New Trace Channel</code>来新建射线通道</li><li>设置射线通道默认值为<code>无视Ignore</code>，在预设中有需要的情况下再做改动</li><li>射线通道与物体通道一样无法直接赋给某个网格物体，需要新建预设，将预设赋给需要被射线检测到的网格体</li><li>如果实在不想新建预设，也可以在物体的碰撞预设里选<code>自定义Custom</code></li><li>这里演示如何创建预设：在<code>碰撞Collision</code>中的第三栏<code>预设Preset</code>里新建碰撞预设</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealCPP/CollisionTracePresets.png" width=650><ul><li>填入<code>预设名称</code>，设置<code>允许碰撞</code>，设置<code>物体类型</code></li><li>选中该物体预设允许检测到的射线通道，将其设置为<code>Block碰撞</code>，确认新建预设</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealCPP/EditCollisionTracePresets.png" width=300><ul><li>将需要接受射线检测的物体网格中的<code>碰撞预设Collision Presets</code>设为刚新建的预设</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealCPP/TracingCollisionSetting.png" width=400><h3 id="🚩射线参数"><a href="#🚩射线参数" class="headerlink" title="🚩射线参数"></a>🚩射线参数</h3><ul><li>在触发射线检测行为的物体或组件中设置触发事件</li><li>射线通道最多有18个（ECC_GameTraceChannel1~18）</li></ul><p>FHitResult    碰撞信息接收器</p><p>DrawDebugLine    画线测试</p><p>GetWorld()-&gt;LineTraceSingleByChannel    单线通道射线检测</p><p>GetWorld()-&gt;LineTraceSingleByObjectType    单线物体类型射线检测</p><p>GetWorld()-&gt;LineTraceSingleByProfile    单线配置文件射线检测</p><p>GetWorld()-&gt;LineTraceMultiByChannel    多线通道射线检测</p><p>GetWorld()-&gt;LineTraceMultiByObjectType    多线物体类型射线检测</p><p>GetWorld()-&gt;LineTraceMultiByProfile    多线配置文件射线检测</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DrawDebugHelpers.h&quot;</span><span class="comment">//测试画线需要此类的引用</span></span></span><br><span class="line"><span class="comment">// -----------------------------------------------------</span></span><br><span class="line">FHitResult hit; <span class="comment">//碰撞信息接收器，接收碰撞信息的参数</span></span><br><span class="line">FVector startLocation; <span class="comment">//射线起始点位置</span></span><br><span class="line">FRotator startRotation; <span class="comment">//射线起始点旋转方向</span></span><br><span class="line"><span class="comment">//获取玩家当前的位置和朝向，并赋给起始点信息</span></span><br><span class="line"><span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetFirstPlayerController</span>()-&gt;<span class="built_in">GetPlayerViewPoint</span>(startLocation, startRotation);</span><br><span class="line"><span class="comment">//通过起始点位置和朝向归一化，算出结束点位置（归一化是一厘米）</span></span><br><span class="line">FVector endLocation = startLocation + startRotation.<span class="built_in">Vector</span>() * <span class="number">100</span>;</span><br><span class="line"><span class="comment">//画一条测试线，无关紧要</span></span><br><span class="line"><span class="built_in">DrawDebugLine</span>(<span class="built_in">GetWorld</span>(), startLocation, endLocation, FColor::Blue);</span><br><span class="line"><span class="comment">//开始射线检测</span></span><br><span class="line"><span class="built_in">GetWorld</span>()-&gt;<span class="built_in">LineTraceSingleByChannel</span>(</span><br><span class="line">hit, <span class="comment">//碰撞信息接收器</span></span><br><span class="line">    startLocation, <span class="comment">//起始位置</span></span><br><span class="line">    endLocation, <span class="comment">//结束位置</span></span><br><span class="line">ECollisionChannel::ECC_GameTraceChannel1, <span class="comment">//指用户创建的第一个射线通道Trace Channels</span></span><br><span class="line"><span class="built_in">FCollisionQueryParams</span>(<span class="built_in">FName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;&quot;</span>)), <span class="literal">false</span>, <span class="built_in">GetOwner</span>()), <span class="comment">//碰撞问询参数（可选参数）</span></span><br><span class="line"><span class="built_in">FCollisionResponseParams</span>(ECollisionResponse::ECR_Block)); <span class="comment">//碰撞响应信息（可选参数）</span></span><br><span class="line"><span class="keyword">if</span> (hit.<span class="built_in">GetActor</span>() != <span class="literal">nullptr</span>)<span class="comment">//若接收器拥有碰撞信息</span></span><br><span class="line">&#123;</span><br><span class="line">    GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">1.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;hit&quot;</span>));<span class="comment">//输出提示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;丧心病狂虚幻C&quot;&gt;&lt;a href=&quot;#丧心病狂虚幻C&quot; class=&quot;headerlink&quot; title=&quot;丧心病狂虚幻C++&quot;&gt;&lt;/a&gt;丧心病狂虚幻C++&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;天  地  玄  黄  宇  宙  洪  荒&lt;/li&gt;
&lt;li&gt;虚幻C++绝对难</summary>
      
    
    
    
    <category term="unreal" scheme="http://iamsleepingnow.github.io/categories/unreal/"/>
    
    
    <category term="受苦" scheme="http://iamsleepingnow.github.io/tags/%E5%8F%97%E8%8B%A6/"/>
    
    <category term="unreal" scheme="http://iamsleepingnow.github.io/tags/unreal/"/>
    
    <category term="C++" scheme="http://iamsleepingnow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>穷凶极恶虚幻蓝图</title>
    <link href="http://iamsleepingnow.github.io/2021/07/20/Unreal/%E7%A9%B7%E5%87%B6%E6%9E%81%E6%81%B6%E8%99%9A%E5%B9%BB%E8%93%9D%E5%9B%BE/"/>
    <id>http://iamsleepingnow.github.io/2021/07/20/Unreal/%E7%A9%B7%E5%87%B6%E6%9E%81%E6%81%B6%E8%99%9A%E5%B9%BB%E8%93%9D%E5%9B%BE/</id>
    <published>2021-07-20T12:15:15.000Z</published>
    <updated>2021-07-30T05:37:21.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="穷凶极恶虚幻蓝图"><a href="#穷凶极恶虚幻蓝图" class="headerlink" title="穷凶极恶虚幻蓝图"></a>穷凶极恶虚幻蓝图</h1><ul><li>坦  白  从  宽  抗  拒  从  严</li><li>蓝图是傻逼，我也是傻逼</li></ul><h2 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h2><ul><li>实例：所有在<code>场景Level</code>里实际存在的物体个体，如：“小明”，意义是所指</li><li>类/蓝图类：封装到内容浏览器里的抽象的概念，如：“学生”，意义是能指</li><li>实例永远是类/蓝图类的派生，“小明”永远是“学生”的派生</li></ul><h2 id="蓝图种类"><a href="#蓝图种类" class="headerlink" title="蓝图种类"></a>蓝图种类</h2><h3 id="关卡蓝图"><a href="#关卡蓝图" class="headerlink" title="关卡蓝图"></a>关卡蓝图</h3><ul><li>关卡蓝图相当于<code>面向过程（POP）</code>式的编程</li><li>一个<code>关卡Level</code>只能有一个关卡蓝图</li><li>关卡蓝图可以对场景里的<code>物体实例（包括蓝图类）</code>进行操纵</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Type_1.png" width=500><h3 id="蓝图类"><a href="#蓝图类" class="headerlink" title="蓝图类"></a>蓝图类</h3><ul><li>蓝图类相当于<code>面向个体（OOP）</code>式的编程</li><li>蓝图类可以在<code>Content内容浏览器</code>里右键创建（Blueprint Class）</li><li>创建时需要选择一个父类，如果要放在场景里，至少要继承自Actor</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Type_2.png" width=500><ul><li>蓝图类也可以通过C++类派生</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Type_3.png" width=350><ul><li>蓝图类也可以通过实例（包括蓝图实例）转换：<ul><li>1：先选择所有需要封装到蓝图类的实例</li><li>2：点击<code>Details窗口</code>右上角的构建蓝图按钮</li><li>3：在弹出的窗口里编辑蓝图名称与路径</li><li>4：选择<code>Harvest Component封装组件</code>，将所有选中实例转换为蓝图的组件</li><li>5：选择继承的父类</li><li>6：确定</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Type_4.png" width=650><h2 id="蓝图基础"><a href="#蓝图基础" class="headerlink" title="蓝图基础"></a>蓝图基础</h2><ul><li>蓝图节点的数据与执行是从左至右进行的，节点的左边是输入区，右边是输出区</li></ul><h3 id="MyBlueprint窗口"><a href="#MyBlueprint窗口" class="headerlink" title="MyBlueprint窗口"></a>MyBlueprint窗口</h3><ul><li><code>MyBlueprint窗口</code>是最重要的窗口，在这可以创建一些基本蓝图结构：<ul><li>Garph图表<ul><li>图表下会显示其包含的事件</li></ul></li><li>Function方法（函数）</li><li>Macro宏</li><li>Variable变量</li><li>Event Dispatcher事件与委托</li></ul></li><li>在蓝图里按右键呼出<code>Palette节点菜单</code>，也可以在<code>Window窗口</code>里打开菜单窗口</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Basic_1.png" width=300><h4 id="Garph图表"><a href="#Garph图表" class="headerlink" title="Garph图表"></a>Garph图表</h4><ul><li>图表就是蓝图片段，不过是将蓝图拆开，能够方便查看和管理罢了</li></ul><h4 id="Variable变量"><a href="#Variable变量" class="headerlink" title="Variable变量"></a>Variable变量</h4><ul><li>在给新建的变量设置初始值时，需要编译一次才能设置</li><li>在<code>Details细节面板</code>里的Variable Type变量类型里可以更改类型</li><li>在<code>MyBlueprint窗口</code>里，变量最右边的眼睛可以点击，睁眼暴露闭眼不暴露</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Basic_2.png" width=500><ul><li>变量拖入蓝图中会选择<code>Get</code>还是<code>Set</code></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Basic_2_1.png" width=150><h4 id="Function方法"><a href="#Function方法" class="headerlink" title="Function方法"></a>Function方法</h4><ul><li>方法有方法自身的蓝图，蓝图里必须有<code>方法节点</code>和<code>返回节点</code>，可以设置参数与返回值</li><li>带返回值的方法没有执行引脚，无返回值的方法有执行引脚</li><li>在<code>MyBlueprint窗口</code>里，默认的<code>ConstructionScript</code>就是<code>构造函数</code></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Basic_3.png" width=800><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Basic_3_1.png" width=350><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul><li><code>alt</code>切断连接</li><li><code>ctrl</code>桥接引脚</li><li><code>ctrl + W</code>复制节点</li></ul><h3 id="引脚类型"><a href="#引脚类型" class="headerlink" title="引脚类型"></a>引脚类型</h3><ul><li><p>白色箭头引脚：执行引脚</p><ul><li>白色流程线由一个执行引脚引出</li><li>后面会跟上一大串<code>void</code>无返回值的方法，这些方法的执行受执行顺序的影响</li><li>一个节点只能连一个输入执行，但可以输出多个执行</li></ul></li><li><p>彩色圆形引脚：数据引脚</p><ul><li>布尔型：深红色</li><li>整型：青色</li><li>浮点型：草绿色</li><li>字符串：玫红色</li><li>一般结构体：深蓝色</li><li>三维向量结构体：黄色</li><li>三维旋矩结构体：浅紫色</li><li>方位矩阵结构体：橙色</li><li>物体类型：湖蓝色</li><li>枚举类型与字节类型：深绿色</li></ul></li></ul><p><b><font color="#AA0000" size=5>Boolean</font></b>    <b><font color="#00DDDD" size=5>Integer</font></b>    <b><font color="#88DD00" size=5>Float</font></b>    <b><font color="#FF33AA" size=5>String</font></b>    <b><font color="#0066FF" size=5>Structure</font></b></p><p><b><font color="#EECC00" size=5>Vector</font></b>    <b><font color="#BBCCFF" size=5>Rotator</font></b>    <b><font color="#FF8800" size=5>Transform</font></b>    <b><font color="#33AAFF" size=5>Actor</font></b>    <b><font color="#33AA88" size=5>Enumeration</font></b></p><ul><li><p>彩色菱形引脚：引用引脚</p></li><li><p>红色方形引脚：事件引脚</p></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Basic_4.png" width=600><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Basic_5_1.png" width=250><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Basic_5.png" width=500><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><ul><li>蓝图内的数据类型转换是自动完成的，例如下列转换节点</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Basic_6.png" width=500><h3 id="测试节点"><a href="#测试节点" class="headerlink" title="测试节点"></a>测试节点</h3><ul><li><code>Print String</code>打印字符串节点</li><li>相当于<code>GEngine-&gt;AddOnScreenDebugMessage()</code>方法</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Basic_7.png" width=250><h3 id="事件节点"><a href="#事件节点" class="headerlink" title="事件节点"></a>事件节点</h3><ul><li>搜索关键词：<code>Event</code></li><li>节点菜单里搜索<code>Event</code>可以快速放置事件节点</li><li>事件节点题头是红色的，没有输入的执行引脚，只有输出的</li><li>事件节点在不同蓝图中有所限制，渊源是c++代码里的事件方法</li><li>事件节点是指令的发起者</li><li>常用的事件节点有：<ul><li><code>BeginPlay</code>初始化事件，游戏开始后第一帧调用一次</li><li><code>Tick</code>更新事件，游戏开始后每一帧都调用</li><li><code>EndPlay</code>结束事件，游戏结束那一帧调用一次</li><li><code>Destroyed</code>销毁事件，实例被销毁时调用一次</li><li><code>Input</code>输入事件，事件名为按键名<ul><li>在蓝图类中输入，必须要争取到player controller玩家控制器的同意（Enable Input）</li></ul></li><li><code>Collision</code>碰撞事件，有碰撞与覆盖之分</li><li><code>Mouse Input</code>鼠标交互事件</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Basic_8.png" width=550><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ul><li>搜索关键词：<code>Flow Control</code></li></ul><h3 id="Delay延时"><a href="#Delay延时" class="headerlink" title="Delay延时"></a>Delay延时</h3><ul><li>执行到<code>Delay</code>节点时会将执行阻塞<code>Duration</code>秒钟</li><li>快捷键：<code>D+鼠标左键</code></li><li><code>Delay</code>有两种版本：</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_FlowControl_1.png" width=550><h3 id="Branch分流"><a href="#Branch分流" class="headerlink" title="Branch分流"></a>Branch分流</h3><ul><li>根据布尔值<code>Condition</code>来判断执行<code>True</code>还是执行<code>False</code></li><li>快捷键：<code>B+鼠标左键</code></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_FlowControl_2.png" width=550><h3 id="Do-X次数限制"><a href="#Do-X次数限制" class="headerlink" title="Do X次数限制"></a>Do X次数限制</h3><ul><li><code>Do X</code>能限制执行的次数，通过<code>Reset</code>来重置限制</li><li>快捷键：<code>O+鼠标左键</code>（Do Once）<code>N+鼠标左键</code>（Do N）</li><li><code>Do X</code>系列有三种：</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_FlowControl_3.png" width=550><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_FlowControl_3_1.png" width=550><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_FlowControl_3_2.png" width=550><h3 id="FlipFlop开关式"><a href="#FlipFlop开关式" class="headerlink" title="FlipFlop开关式"></a>FlipFlop开关式</h3><ul><li>能让执行信号折返于<code>A</code>和<code>B</code>之间</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_FlowControl_4.png" width=550><h3 id="Gate门限"><a href="#Gate门限" class="headerlink" title="Gate门限"></a>Gate门限</h3><ul><li><code>Gate</code>能通过多个执行引脚控制总执行的通过与否</li><li><code>MultiGate</code>则类似于更加灵活的<code>Flip Flop</code></li><li>快捷键：<code>G+鼠标左键</code>（Gate）<code>M+鼠标左键</code>（MultiGate）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_FlowControl_5.png" width=550><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_FlowControl_5_1.png" width=550><h3 id="Sequence拆分"><a href="#Sequence拆分" class="headerlink" title="Sequence拆分"></a>Sequence拆分</h3><ul><li>将一条执行线拆成多条，并按顺序执行</li><li>快捷键：<code>S+鼠标左键</code></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_FlowControl_6.png" width=550><h3 id="Loop循环"><a href="#Loop循环" class="headerlink" title="Loop循环"></a>Loop循环</h3><ul><li>循环有三种：For循环、带Break的For循环、While循环</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_FlowControl_7.png" width=550><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_FlowControl_7_1.png" width=550><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_FlowControl_7_2.png" width=550><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>搜索关键词：<code>Array</code></li></ul><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><ul><li>Get有两种，区别是输出的引脚形状不同</li><li>对值的引用的修改可以忽视形参实参的限制</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Array_1.png" width=350><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><ul><li>重要的方法有：<ul><li><code>Length</code>获取长度</li><li><code>Is Empty</code>是否为空</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Array_2.png" width=650><h3 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h3><ul><li>重要的方法有：<ul><li><code>Add</code>添加元素</li><li><code>Clear</code>清除元素</li><li><code>Insert</code>插入元素</li><li><code>Remove</code>移除元素</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Array_3.png" width=650><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Array_3_1.png" width=350><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><ul><li>两种方法来遍历数组：</li><li>快捷键：<code>F+鼠标左键</code>（For Each Loop）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Array_4.png" width=650><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><ul><li>结构体可以在<code>Content内容浏览器</code>里右键创建（Structure）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Structure_1.png" width=450><ul><li>在设置窗口里添加并设置结构体里的元素与初始值</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Structure_2.png" width=550><h3 id="拆开与重组"><a href="#拆开与重组" class="headerlink" title="拆开与重组"></a>拆开与重组</h3><ul><li>所有的结构体都适用<code>Break</code>方法与<code>Make</code>方法</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Structure_3.png" width=300><h2 id="蓝图与访问"><a href="#蓝图与访问" class="headerlink" title="蓝图与访问"></a>蓝图与访问</h2><h3 id="关卡蓝图获取关卡实例"><a href="#关卡蓝图获取关卡实例" class="headerlink" title="关卡蓝图获取关卡实例"></a>关卡蓝图获取关卡实例</h3><ul><li>先在场景中选择一个<code>Actor</code>实例（假设叫“BP_Test_1”）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Call_1.png" width=300><ul><li>到关卡蓝图里右键选择<code>Create a Reference</code>创建实例引用</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Call_2.png" width=400><ul><li>进行各种Get和Set操作</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Call_3.png" width=650><h3 id="蓝图类获取关卡实例"><a href="#蓝图类获取关卡实例" class="headerlink" title="蓝图类获取关卡实例"></a>蓝图类获取关卡实例</h3><ul><li>当然是使用<code>Get All</code>系列了</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Call_4.png" width=650><ul><li><code>Get All</code>系列成员：</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Call_5.png" width=550><ul><li>还可以在蓝图类中创建某类型的变量，暴露后在场景实例中指认</li><li>如果不指认就使用此变量造成空指针异常，蓝图不会崩溃会报错，而C++会崩溃</li></ul><h2 id="碰撞"><a href="#碰撞" class="headerlink" title="碰撞"></a>碰撞</h2><h3 id="关卡蓝图中（实例）碰撞事件引用"><a href="#关卡蓝图中（实例）碰撞事件引用" class="headerlink" title="关卡蓝图中（实例）碰撞事件引用"></a>关卡蓝图中（实例）碰撞事件引用</h3><ul><li>使用实例引用时可以选择创建基于该引用的事件</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Collide_1.png" width=350><h3 id="蓝图类中（组件）碰撞事件引用"><a href="#蓝图类中（组件）碰撞事件引用" class="headerlink" title="蓝图类中（组件）碰撞事件引用"></a>蓝图类中（组件）碰撞事件引用</h3><ul><li>对组件右键可以获取其委托的事件，并放到蓝图中</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Collide_1_1.png" width=550><h3 id="碰撞事件"><a href="#碰撞事件" class="headerlink" title="碰撞事件"></a>碰撞事件</h3><ul><li><code>On(Actor/Component)BeginOverlap</code>进入覆盖（触发）</li><li><code>On(Actor/Component)EndOverlap</code>离开覆盖（触发）</li><li><code>On(Actor/Component)Hit</code>碰撞</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Collide_2.png" width=600><h2 id="射线"><a href="#射线" class="headerlink" title="射线"></a>射线</h2><ul><li>射线通道在ProjectSettings里的Collision里设置</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Trace_2.png" width=600><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Trace_1.png" width=800><ul><li><p>常用射线函数有：</p><ul><li>TraceByChannel通道检测</li><li>TraceByProfile文件检测</li><li>TraceForObjects物体组检测</li></ul></li><li><p>套用上面的常用函数，射线检测还有形状之分：</p><ul><li>Line线型</li><li>Box盒型</li><li>Capsure胶囊体型</li><li>Sphere球型</li></ul></li><li><p>套用前面两者，射线检测还有数量之分：</p><ul><li>Single单射线检测（省略Single）</li><li>Multi多射线检测</li></ul></li><li><p>套用前面三者，打个比方：多射线球形文件检测 = MultiSphereTraceByProfile</p></li></ul><h2 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h2><ul><li><code>Timeline</code>节点能创建一个可编辑的时间轴节点</li><li>双击该节点进入编辑界面</li><li>在编辑界面中可以新建多个不同类型的轨道，轨道名对应节点输出类型</li><li>同时时间轴能在<code>My Blueprint窗口</code>找到</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Timeline_1.png" width=600><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Timeline_2.png" width=800><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Timeline_3.png" width=300><h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><ul><li>创建一个UI文件<code>Widget Blueprint</code></li><li>在任何蓝图里都能将UI文件加入到视口显示</li><li>多个UI文件可以互相覆盖显示</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_UI_1.png" width=100><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_UI_2.png" width=800><h2 id="类降级"><a href="#类降级" class="headerlink" title="类降级"></a>类降级</h2><ul><li>通过<code>Cast</code>方法进行类的临时降级处理（俗称“做儿子”）</li><li>这里做个示例：<ul><li>新建<code>BP_ActorParent</code>类继承自<code>Actor</code></li><li>新建<code>BP_ActorSon1</code>和<code>BP_ActorSon2</code>都继承自<code>BP_ActorParent</code></li><li>假使<code>BP_ActorParent</code>是游戏的底层类</li><li>若蓝图类<code>Son1</code>中定义一个<code>Son2</code>类型的暴露变量来访问场景中的<code>Son2</code>类型实例</li><li>不如直接定义一个<code>parent</code>类型的变量来直接赋值</li><li>但是父类无法直接调用子类的成员或重写方法，这时就使用<code>类降级Cast</code>的方法来做</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Cast_1.png" width=300><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Cast_2.png" width=800><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><h3 id="自定义事件定义"><a href="#自定义事件定义" class="headerlink" title="自定义事件定义"></a>自定义事件定义</h3><ul><li>在蓝图中右键搜索<code>Add Custom Event</code>来定义事件</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Event_1.png" width=350><h3 id="自定义事件调用"><a href="#自定义事件调用" class="headerlink" title="自定义事件调用"></a>自定义事件调用</h3><ul><li>输入<code>Call</code>关键字来调用触发事件的方法</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Event_2.png" width=700><ul><li>使用Execute Console Command指令行能远程调用事件</li><li>蓝图类可以通过此方式调用关卡蓝图内逻辑</li><li>但是关卡蓝图不能通过此方式调用蓝图类内逻辑</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Event_3.png" width=400><h2 id="委托机"><a href="#委托机" class="headerlink" title="委托机"></a>委托机</h2><ul><li>在<code>My Blueprint窗口</code>里可以新建<code>委托机Event Dispatcher</code></li><li>委托机的作用是同时控制多个事件的执行</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Dispatcher_1.png" width=300><h3 id="委托机命令"><a href="#委托机命令" class="headerlink" title="委托机命令"></a>委托机命令</h3><ul><li>委托机拖入场景中有几种命令：<ul><li><code>Call</code>触发委托机</li><li><code>Bind</code>将事件绑定到委托机</li><li><code>Unbind</code>事件解绑</li><li><code>Unbind All</code>解绑所有</li><li><code>Event</code>快速创建一个自定义事件</li><li><code>Assign</code>在创建一个自定义事件的同时，绑定到委托机</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Dispatcher_2.png" width=150><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Dispatcher_3.png" width=600><h3 id="委托机触发"><a href="#委托机触发" class="headerlink" title="委托机触发"></a>委托机触发</h3><ul><li>委托机就能解决关卡蓝图调用蓝图类逻辑的问题</li><li>下图即在关卡蓝图里调用蓝图类实例的委托机的方法</li><li>UI按钮响应也能通过委托机来做</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Dispatcher_4.png" width=400><h3 id="委托机绑定函数"><a href="#委托机绑定函数" class="headerlink" title="委托机绑定函数"></a>委托机绑定函数</h3><ul><li>使用<code>CreateEvent</code>来更灵活地绑定委托机</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Dispatcher_5.png" width=450><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h3><ul><li>创建蓝图接口文件<code>Blueprint Interface</code></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Interface_1.png" width=100><ul><li>在接口里定义函数</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Interface_2.png" width=300><h3 id="蓝图类实现接口"><a href="#蓝图类实现接口" class="headerlink" title="蓝图类实现接口"></a>蓝图类实现接口</h3><ul><li>在需要调用的类里的<code>Class Settings</code>里添加接口调用</li><li>判断一个类是否实现了接口，使用<code>Does Implement Interface</code>节点</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Interface_3.png" width=400><h3 id="使用接口"><a href="#使用接口" class="headerlink" title="使用接口"></a>使用接口</h3><ul><li>通过搜索<code>Call</code>来呼出接口函数和事件</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Interface_4.png" width=300><ul><li>在其他蓝图内调用此蓝图类里实现接口的方法</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Interface_5.png" width=800><ul><li>在该实现接口的蓝图类的<code>My Blueprint窗口</code>里能发现可重写的接口方法事件，见下图</li><li>双击重写方法，或者右键该方法选择<code>Convert Function To Event</code>转换成事件</li><li>重写方法是局部的，而转换的事件不是</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Interface_6.png" width=250><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Interface_6_1.png" width=450><ul><li>可以在任何地方调用此函数</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unreal/unrealBlueprint/BP_Interface_7.png" width=400><ul><li><p>当其他蓝图类访问该蓝图类身上的接口方法事件时，该蓝图类内的事件就会执行</p></li><li><p>多个蓝图类实现同一个接口，每个蓝图中可执行不同的方法</p></li></ul><h3 id="委托机与接口的差异"><a href="#委托机与接口的差异" class="headerlink" title="委托机与接口的差异"></a>委托机与接口的差异</h3><ul><li>委托机只能在一个蓝图类中被定义使用，其他蓝图类可以调用该蓝图类的委托机中绑定的事件</li><li>接口能跨蓝图类使用，其他蓝图类可以调用实现接口的任意蓝图类中的接口事件</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;穷凶极恶虚幻蓝图&quot;&gt;&lt;a href=&quot;#穷凶极恶虚幻蓝图&quot; class=&quot;headerlink&quot; title=&quot;穷凶极恶虚幻蓝图&quot;&gt;&lt;/a&gt;穷凶极恶虚幻蓝图&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;坦  白  从  宽  抗  拒  从  严&lt;/li&gt;
&lt;li&gt;蓝图是傻逼，我也</summary>
      
    
    
    
    <category term="unreal" scheme="http://iamsleepingnow.github.io/categories/unreal/"/>
    
    
    <category term="受苦" scheme="http://iamsleepingnow.github.io/tags/%E5%8F%97%E8%8B%A6/"/>
    
    <category term="unreal" scheme="http://iamsleepingnow.github.io/tags/unreal/"/>
    
    <category term="blueprint" scheme="http://iamsleepingnow.github.io/tags/blueprint/"/>
    
  </entry>
  
  <entry>
    <title>C++试水</title>
    <link href="http://iamsleepingnow.github.io/2021/07/03/CPP/C++%E8%AF%95%E6%B0%B4/"/>
    <id>http://iamsleepingnow.github.io/2021/07/03/CPP/C++%E8%AF%95%E6%B0%B4/</id>
    <published>2021-07-03T12:43:15.000Z</published>
    <updated>2021-07-03T13:18:49.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-试水"><a href="#C-试水" class="headerlink" title="C++试水"></a>C++试水</h1><ul><li>稍微学了一点c++，然后放弃了。。。</li><li>这里是学习笔记</li><li><a href="https://www.bilibili.com/video/BV12x411D7xr?from=search&seid=7267883766994740468">学习平台在此</a></li></ul><h2 id="大门"><a href="#大门" class="headerlink" title="大门"></a>大门</h2><ul><li>下载安装MinGW，并设置环境变量<ul><li><a href="http://c.biancheng.net/view/8077.html">MinGW下载和安装教程 (biancheng.net)</a></li></ul></li><li>下载Code::Block软件</li><li>Code::Block-&gt;设置-&gt;编译器-&gt;可执行工具链-&gt;自动侦测编译器的安装目录</li></ul><h3 id="使用旧方法创建工程"><a href="#使用旧方法创建工程" class="headerlink" title="使用旧方法创建工程"></a>使用旧方法创建工程</h3><ul><li>使用Code::Blocks运行C++文件<ul><li>在新建路径内创建<code>.cpp</code>文件</li><li>为了生成执行文件exe，于是使用控制台cmd，在该文件目录内：<ul><li><code>g++ -o 执行文件名 代码文件名.cpp</code></li></ul></li></ul></li><li>运行Code::Block</li></ul><h3 id="使用新方法创建工程"><a href="#使用新方法创建工程" class="headerlink" title="使用新方法创建工程"></a>使用新方法创建工程</h3><ul><li>Code::Block-&gt;文件-&gt;新建-&gt;项目-&gt;ConsoleApplication</li></ul><h2 id="（一）你好世界"><a href="#（一）你好世界" class="headerlink" title="（一）你好世界"></a>（一）你好世界</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt; <span class="comment">//预处理器指令</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 引用&quot;标准&quot;命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//cout即输出，&lt;&lt;即将字符串插入cout中，endl即\n并清空缓冲区</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;HelloWorld!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="（二）C-文件结构"><a href="#（二）C-文件结构" class="headerlink" title="（二）C++文件结构"></a>（二）C++文件结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件(.h)的内容与源文件(.cpp)中的内容一致，都是 C++ 的源代码。</span></span><br><span class="line"><span class="comment">//但头文件不用被编译。</span></span><br><span class="line"><span class="comment">//将所有的函数声明全部放进一个头文件中，当源文件需要时，通过 &quot;#include&quot; 将头文件传入。</span></span><br></pre></td></tr></table></figure><h2 id="（三）数据类型"><a href="#（三）数据类型" class="headerlink" title="（三）数据类型"></a>（三）数据类型</h2><h3 id="主要类型"><a href="#主要类型" class="headerlink" title="主要类型"></a>主要类型</h3><table><thead><tr><th align="center">数据类型</th><th align="center">字符</th><th align="center">位数</th><th align="center">取值范围</th></tr></thead><tbody><tr><td align="center">整型</td><td align="center">int</td><td align="center">32</td><td align="center">-2^31~2^31-1</td></tr><tr><td align="center">短整型</td><td align="center">short</td><td align="center">16</td><td align="center">-2^15_2^15-1</td></tr><tr><td align="center">长整型</td><td align="center">long long</td><td align="center">64</td><td align="center">-2^63~2^63-1</td></tr><tr><td align="center">单精度浮点</td><td align="center">float</td><td align="center">32</td><td align="center">-3.4e-38~3.4e+38</td></tr><tr><td align="center">双精度浮点</td><td align="center">double</td><td align="center">64</td><td align="center">1.7e-308~1.7e308</td></tr><tr><td align="center">字符</td><td align="center">char</td><td align="center">8</td><td align="center">-128~127</td></tr></tbody></table><h3 id="强制转型"><a href="#强制转型" class="headerlink" title="强制转型"></a>强制转型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a = <span class="number">10.5</span>;</span><br><span class="line"><span class="type">int</span> b = (<span class="type">int</span>)a;</span><br></pre></td></tr></table></figure><h3 id="常量与宏定义"><a href="#常量与宏定义" class="headerlink" title="常量与宏定义"></a>常量与宏定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HELLOWORLD <span class="string">&quot;HelloWorld&quot;</span> <span class="comment">//宏定义</span></span></span><br><span class="line"><span class="type">const</span> string HelloWorld = <span class="string">&quot;HelloWorld&quot;</span>; <span class="comment">//常量</span></span><br></pre></td></tr></table></figure><h2 id="（四）运算符"><a href="#（四）运算符" class="headerlink" title="（四）运算符"></a>（四）运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">++ -- 递增 递减</span><br><span class="line">+ - * / % 加 减 乘 除 余</span><br></pre></td></tr></table></figure><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">= 赋值运算符</span><br><span class="line">+= -= *= /= %= 复合运算符</span><br><span class="line">&gt; &lt; &gt;= &lt;= == != 关系运算符</span><br><span class="line">&amp;&amp; || ! 逻辑运算符</span><br><span class="line">&amp; | ~ ^ &lt;&lt; &gt;&gt; 位运算符</span><br></pre></td></tr></table></figure><h2 id="（五）条件"><a href="#（五）条件" class="headerlink" title="（五）条件"></a>（五）条件</h2><h3 id="如果、就、否则"><a href="#如果、就、否则" class="headerlink" title="如果、就、否则"></a>如果、就、否则</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//TRUE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//FALSE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//???</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="当、就、否则"><a href="#当、就、否则" class="headerlink" title="当、就、否则"></a>当、就、否则</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span>(i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（六）循环"><a href="#（六）循环" class="headerlink" title="（六）循环"></a>（六）循环</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">50</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（七）数组"><a href="#（七）数组" class="headerlink" title="（七）数组"></a>（七）数组</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> num2[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> num3[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> num3[<span class="number">4</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> num2[<span class="number">4</span>]&#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="动态赋值"><a href="#动态赋值" class="headerlink" title="动态赋值"></a>动态赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num[<span class="number">100</span>]&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">num[i] = i * <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; num[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sizeof()函数可以用来计算数据的比特大小</span></span><br><span class="line"><span class="comment">//整型与浮点型数值都是32位，每字节有8位，所以计算数值数组长度多半需要除4</span></span><br><span class="line"><span class="type">int</span> num[]&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(num)/<span class="number">4</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nums[]&#123;<span class="number">10</span>, <span class="number">47</span>, <span class="number">8</span>, <span class="number">25</span>, <span class="number">20</span>, <span class="number">54</span>, <span class="number">61</span>, <span class="number">40</span>&#125;;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span><span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">8</span><span class="number">-1</span>-i;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &gt; nums[j+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            temp = nums[j];</span><br><span class="line">            nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">            nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; nums[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nums[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> tick = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : nums)</span><br><span class="line">&#123;</span><br><span class="line">    i = tick;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    tick++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（八）向量-动态数组"><a href="#（八）向量-动态数组" class="headerlink" title="（八）向量(动态数组)"></a>（八）向量(动态数组)</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&amp;lt;<span class="type">float</span>&amp;gt; vect1;</span><br><span class="line">vector&amp;lt;<span class="type">float</span>&amp;gt; <span class="built_in">vect2</span>(<span class="number">5</span>); <span class="comment">//向量内有五个元素</span></span><br><span class="line">vector&amp;lt;<span class="type">float</span>&amp;gt; <span class="built_in">vect3</span>(<span class="number">10</span>, <span class="number">1</span>); <span class="comment">//向量内有十个1</span></span><br></pre></td></tr></table></figure><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vect1.<span class="built_in">clear</span>(); <span class="comment">//移除所有数据</span></span><br><span class="line">cout &lt;&lt; vect1.<span class="built_in">empty</span>(); <span class="comment">//判断是否为空</span></span><br><span class="line">cout &lt;&lt; vect1.<span class="built_in">size</span>(); <span class="comment">//返回数据个数</span></span><br><span class="line">cout &lt;&lt; vect1[<span class="number">1</span>] &lt;&lt; vect1.<span class="built_in">at</span>(<span class="number">1</span>); <span class="comment">//返回索引后的数</span></span><br><span class="line">vect1.<span class="built_in">erase</span>(<span class="number">1</span>); <span class="comment">//删除指定数据</span></span><br><span class="line">vect1.<span class="built_in">erase</span>(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">//删除指定区间数据</span></span><br><span class="line">cout &lt;&lt; vect1.<span class="built_in">front</span>(); <span class="comment">//返回第一个元素</span></span><br><span class="line">vect1.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="number">3.14</span>); <span class="comment">//插入元素</span></span><br><span class="line">vect1.<span class="built_in">pop_back</span>(); <span class="comment">//删除最后一个元素</span></span><br><span class="line">vect1.<span class="built_in">push_back</span>(<span class="number">3.14</span>); <span class="comment">//末尾插入</span></span><br><span class="line">vect1.<span class="built_in">resize</span>(<span class="number">10</span>); <span class="comment">//重设大小</span></span><br></pre></td></tr></table></figure><h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&amp;lt;<span class="type">int</span>&amp;gt; vect;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    vect.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : vect)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（九）指针与引用"><a href="#（九）指针与引用" class="headerlink" title="（九）指针与引用"></a>（九）指针与引用</h2><h3 id="指针定义"><a href="#指针定义" class="headerlink" title="指针定义"></a>指针定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * p_num;</span><br><span class="line">string * p_name;</span><br><span class="line"><span class="comment">//p_num1与*p_num2的区别</span></span><br><span class="line"><span class="type">int</span>* p_num1; <span class="comment">//星偏向地址，则p_num1表地址</span></span><br><span class="line"><span class="type">int</span> *p_num2; <span class="comment">//星偏向数值，则*p_num2表数值</span></span><br></pre></td></tr></table></figure><h3 id="指针赋值"><a href="#指针赋值" class="headerlink" title="指针赋值"></a>指针赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p_num = &amp;num;</span><br></pre></td></tr></table></figure><h3 id="指针调用"><a href="#指针调用" class="headerlink" title="指针调用"></a>指针调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p_num = &amp;num;</span><br><span class="line">cout &lt;&lt; *p_num &lt;&lt; endl;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&amp;num表地址</span></span><br><span class="line"><span class="comment">//*p_num表数值</span></span><br></pre></td></tr></table></figure><h3 id="任意指针、空指针、野指针"><a href="#任意指针、空指针、野指针" class="headerlink" title="任意指针、空指针、野指针"></a>任意指针、空指针、野指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span>* p_num = &amp;num; <span class="comment">//void* 即任意类型指针</span></span><br><span class="line"><span class="type">int</span>* ptr1 = <span class="literal">nullptr</span>; <span class="comment">//空指针</span></span><br><span class="line"><span class="type">int</span>* ptr2; <span class="comment">//野指针(一定要避免野指针)</span></span><br></pre></td></tr></table></figure><h3 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与const</h3><ul><li>当只有一个const时，如果const位于星的左侧，表示指针所指的数据是常量，无法通过该指针修改此数值，但指针本身是变量，可以指向其他数值</li><li>当只有一个const时，如果const位于星的右侧，表示指针本身是常量，不能指向其他数值，但指针所指的数据是常量，可以通过该指针修改数值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p1_num = &amp;num;<span class="comment">//变量指针，常量数值</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p2_num = &amp;num;<span class="comment">//常量指针，变量数值</span></span><br></pre></td></tr></table></figure><h3 id="指针特殊情况"><a href="#指针特殊情况" class="headerlink" title="指针特殊情况"></a>指针特殊情况</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;c&#x27;</span>; <span class="comment">//char型指针默认为字符串</span></span><br><span class="line"><span class="type">char</span>* p_ch = &amp;ch;</span><br><span class="line">cout &lt;&lt; (<span class="type">void</span> *)p_ch &lt;&lt; *p_ch &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针用法：在运行阶段分配未命名的内存以存储值</span></span><br><span class="line"><span class="comment">//在此情况下，只能通过指针来访问内存</span></span><br><span class="line"><span class="comment">//通过“new”来分配内存</span></span><br><span class="line"><span class="comment">//1，在运行阶段为一个int值分配未命名的内存</span></span><br><span class="line"><span class="type">int</span>* p_int = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="comment">//使用“*p_int”来访问数值</span></span><br><span class="line"><span class="comment">//2，释放由“new”分配的内存</span></span><br><span class="line"><span class="keyword">delete</span> p_int;</span><br><span class="line"><span class="comment">//不要使用delete释放不是new分配的内存</span></span><br><span class="line"><span class="comment">//数组稍有不同(delete[])</span></span><br><span class="line"><span class="type">int</span>* p_intArray1 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">4</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">delete</span>[] p_intArray1;</span><br></pre></td></tr></table></figure><h3 id="指针数组与数组指针"><a href="#指针数组与数组指针" class="headerlink" title="指针数组与数组指针"></a>指针数组与数组指针</h3><h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><ul><li>指针数组是由多个单个指针构成的数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr[<span class="number">3</span>]&#123;<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="数组名指针"><a href="#数组名指针" class="headerlink" title="数组名指针"></a>数组名指针</h4><ul><li>数组名都是指针，都是指向数组中第一个元素的常量指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> num1[<span class="number">10</span>];</span><br><span class="line"><span class="type">float</span>* p_num1;</span><br><span class="line">p_num1 = num1;<span class="comment">//p_num1即数组第一个元素指针</span></span><br><span class="line">cout &lt;&lt; p_num1 &lt;&lt; &amp;(num1[<span class="number">0</span>]) &lt;&lt; endl;<span class="comment">//p_num1 = &amp;(num1[0])</span></span><br><span class="line"><span class="comment">//通过数组名指针来获取数组里的其他值</span></span><br><span class="line"><span class="type">float</span> num2[<span class="number">3</span>]&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"><span class="type">float</span>* p_num2 = num2;</span><br><span class="line">cout &lt;&lt; *(p_num2 + <span class="number">1</span>) &lt;&lt; endl;<span class="comment">//通过自增来渐进（输出20）</span></span><br><span class="line"><span class="comment">//上面使用数组名作为常量指针是合法的，因此，num2[2] = *(num + 2)</span></span><br></pre></td></tr></table></figure><h4 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h4><ul><li>数组指针是一个数组的指针，可以是“指针数组”的指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array1[<span class="number">3</span>]&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> (*ptr)[<span class="number">3</span>] = &amp;array1;<span class="comment">//(*ptr)[3]作为一个指针指向了array1数组</span></span><br><span class="line">cout &lt;&lt; ptr &lt;&lt; &amp;(array1[<span class="number">0</span>]) &lt;&lt; endl;<span class="comment">//相等</span></span><br><span class="line">cout &lt;&lt; (*ptr)[<span class="number">3</span>] &lt;&lt; &amp;(array1[<span class="number">0</span>]) &lt;&lt; endl;<span class="comment">//不等</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//int (*ptr)[3]可以看成：</span></span><br><span class="line"><span class="comment">//倘若小括号没有，就成了int* ptr[3]，星的优先级在于int了，就成了指针数组</span></span><br><span class="line"><span class="comment">//加上了小括号，星的优先级就成了ptr</span></span><br><span class="line"><span class="comment">//星在这里成了地址取值符而不是指针类型符，所以新声明的ptr必然是一个指针</span></span><br><span class="line"><span class="comment">//ptr单独拎出来还是数组第一个元素的地址</span></span><br></pre></td></tr></table></figure><h4 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// --------------------------------------</span></span><br><span class="line"><span class="type">int</span>* ptr1 = &amp;num;<span class="comment">//有误</span></span><br><span class="line"><span class="type">int</span>* ptr2 = num;<span class="comment">//正确</span></span><br><span class="line"><span class="built_in">int</span> (*ptr3)[<span class="number">3</span>] = &amp;num;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure><h3 id="引用定义"><a href="#引用定义" class="headerlink" title="引用定义"></a>引用定义</h3><ul><li>引用即为对象起另外一个名字</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span>&amp; refNum1 = num;<span class="comment">//正确，num可以被refNum1调用</span></span><br><span class="line"><span class="type">int</span>&amp; refNum2;<span class="comment">//错误，引用必须初始化(不可直接引用常量，引用常量需要const一下)</span></span><br></pre></td></tr></table></figure><h2 id="（十）函数"><a href="#（十）函数" class="headerlink" title="（十）函数"></a>（十）函数</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul><li>函数需要<code>定义原型</code>与<code>定义实现体</code>后才能使用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">function_int</span><span class="params">(<span class="type">float</span>)</span></span>;<span class="comment">//函数原型声明</span></span><br><span class="line"><span class="comment">// ----------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span><span class="comment">//主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">function_int</span>(<span class="number">0.58851</span>) &lt;&lt; endl;<span class="comment">//函数调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------------------------------------</span></span><br><span class="line"><span class="comment">//返回值类型 函数名 （参数列表）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">function_int</span><span class="params">(<span class="type">float</span> f)</span><span class="comment">//实现体</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)f;<span class="comment">//函数体</span></span><br><span class="line">    <span class="comment">//返回值不能为数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果<code>函数实现体</code>在主函数<code>之前</code>声明，则可以不用声明<code>函数原型</code>（最好是要写）</li><li>如果<code>函数实现体</code>在主函数<code>之后</code>声明，则必须在主函数前声明<code>函数原型</code></li><li><code>函数原型</code>的存在目的就是为了在主函数前通知编译器函数的存在</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">function_int</span><span class="params">(<span class="type">float</span> f)</span><span class="comment">//实现体</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)f;<span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span><span class="comment">//主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">function_int</span>(<span class="number">0.58851</span>) &lt;&lt; endl;<span class="comment">//函数调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="形参改变实参值值不变"><a href="#形参改变实参值值不变" class="headerlink" title="形参改变实参值值不变"></a>形参改变实参值值不变</h3><ul><li>形参是实参的复制品，不会逆影响</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addSelf</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; m &lt;&lt; endl; <span class="comment">//10</span></span><br><span class="line">    <span class="built_in">addSelf</span>(m);</span><br><span class="line">    cout &lt;&lt; m &lt;&lt; endl; <span class="comment">//10不变</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addSelf</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用引用形参来修改实参"><a href="#使用引用形参来修改实参" class="headerlink" title="使用引用形参来修改实参"></a>使用引用形参来修改实参</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selfAdd1</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">//变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selfAdd2</span><span class="params">(<span class="type">int</span>*)</span></span>;<span class="comment">//指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selfAdd3</span><span class="params">(<span class="type">int</span>&amp;)</span></span>;<span class="comment">//引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">selfAdd1</span>(num1);</span><br><span class="line">    cout &lt;&lt; num1 &lt;&lt; endl;<span class="comment">//输出10，不变</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">selfAdd2</span>(&amp;num2);</span><br><span class="line">    cout &lt;&lt; num2 &lt;&lt; endl;<span class="comment">//输出10，不变</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> num3 = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">selfAdd3</span>(num3);</span><br><span class="line">    cout &lt;&lt; num3 &lt;&lt; endl;<span class="comment">//输出11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selfAdd1</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//变量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selfAdd2</span><span class="params">(<span class="type">int</span>* pi)</span><span class="comment">//指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pi++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selfAdd3</span><span class="params">(<span class="type">int</span>&amp; ri)</span><span class="comment">//引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ri++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><ul><li>函数的地址是存储其机器语言代码的内存开始地址</li></ul><h4 id="函数指针声明"><a href="#函数指针声明" class="headerlink" title="函数指针声明"></a>函数指针声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;<span class="comment">//函数原型声明</span></span><br><span class="line"><span class="built_in">int</span> (*pSum)(<span class="type">int</span>, <span class="type">int</span>);<span class="comment">//函数指针声明</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">pSum</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;<span class="comment">//错误方法</span></span><br><span class="line"><span class="keyword">auto</span> pSum = sum;<span class="comment">//自动声明法(需要初始一个默认值)</span></span><br></pre></td></tr></table></figure><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><ul><li>函数可以通过<code>函数指针</code>的方法来作为其他函数的传参</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;<span class="comment">//函数原型声明</span></span><br><span class="line"><span class="built_in">int</span> (*pSum)(<span class="type">int</span>, <span class="type">int</span>);<span class="comment">//函数指针声明</span></span><br><span class="line"><span class="comment">//将“int (*)(int, int)”作为一个函数指针参数传入函数中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printRes</span><span class="params">(<span class="type">int</span> (*)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span>, <span class="type">int</span>)</span></span>;<span class="comment">//用于调用的void函数</span></span><br><span class="line"><span class="comment">// -----------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//函数本体</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printRes</span><span class="params">(<span class="type">int</span> (*pSum)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//调用函数的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">pSum</span>(a, b);<span class="comment">//pSum是函数指针</span></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -----------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span><span class="comment">//主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pSum = sum;<span class="comment">//指针指向函数</span></span><br><span class="line">    <span class="built_in">printRes</span>(pSum, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><ul><li>编译器调用<code>普通函数</code>时，需要去查找函数地址去执行函数</li><li>而调用<code>内联函数</code>时，只需要复制插入函数语句去执行即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数与引用"><a href="#函数与引用" class="headerlink" title="函数与引用"></a>函数与引用</h3><h4 id="引用返回值"><a href="#引用返回值" class="headerlink" title="引用返回值"></a>引用返回值</h4><ul><li>不要返回局部变量的引用，因为不干净</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">selfAdd</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">selfAdd</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>&amp; refNum = num;</span><br><span class="line">    <span class="keyword">return</span> refNum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">selfAdd</span>(<span class="number">10</span>) &lt;&lt; endl;<span class="comment">//不建议</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数左右值与引用"><a href="#函数左右值与引用" class="headerlink" title="函数左右值与引用"></a>函数左右值与引用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">sum1</span><span class="params">(<span class="type">int</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">sum1</span><span class="params">(<span class="type">int</span>&amp; num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -----------------------------------</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">sum2</span><span class="params">(<span class="type">int</span>&amp;)</span></span>;<span class="comment">//加入const，不允许左右值互换</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">sum2</span><span class="params">(<span class="type">int</span>&amp; num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -----------------------------------</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>&amp; res1 = <span class="built_in">sum1</span>(a);</span><br><span class="line">    <span class="built_in">sum</span>(a) = <span class="number">20</span>;<span class="comment">//引用函数允许放在左值</span></span><br><span class="line">    cout &lt;&lt; res1 &lt;&lt; endl;<span class="comment">//输出20</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>&amp; res2 = <span class="built_in">sum2</span>(b);</span><br><span class="line">    <span class="built_in">sum</span>(b) = <span class="number">20</span>;<span class="comment">//直接报错</span></span><br><span class="line">    cout &lt;&lt; res2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h3><ul><li>可以在<code>定义原型</code>或者<code>定义实现体</code>时给函数的参数一个默认值</li><li>但是不允许在两个地方同时赋值</li><li>当有多个参数时，赋默认值的参数后的所有参数也必须得有默认值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> = <span class="number">10</span>)</span></span>;<span class="comment">//在定义原型时赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">5</span>, <span class="type">int</span> c = <span class="number">10</span>, <span class="type">int</span> d = <span class="number">15</span>)</span><span class="comment">//多个默认值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a + b + c + d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------------------------</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">print2</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">print2</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><ul><li>重载指可以有多个同名的函数</li><li>这些函数名称相同，但参数列表不同</li><li>引用作为传参属于相同参数类型</li><li>传参时不区分const标</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(string)</span></span>;<span class="comment">//print函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(string, string)</span></span>;<span class="comment">//print函数重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(string str1, string str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; str1 &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(string&amp;)</span></span>;<span class="comment">//print函数错误重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(string&amp; rstr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; rstr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------------------</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;HelloWorld!&quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(str);</span><br><span class="line">    <span class="built_in">print</span>(str, str);</span><br><span class="line">    string&amp; rstr = str;</span><br><span class="line">    <span class="built_in">print</span>(rstr);<span class="comment">//出错，引用作为传参属于相同参数类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h3><ul><li>函数模板即建立一个通用函数</li><li>函数定义时不指定具体的数据类型</li><li><code>模板函数</code>的意义是在函数内声明一个虚拟的数据类型</li><li>编译器会自动推断<code>模板函数</code>虚拟数据类型的数据类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="type">void</span> <span class="title">print</span><span class="params">(T1, T2, T1)</span></span>;<span class="comment">//T1和T2是虚拟数据类型</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt; <span class="type">void</span> <span class="title">print</span><span class="params">(T1 a, T2 b, T1 c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">int</span> int1 = <span class="number">10</span>;</span><br><span class="line">    string str2 = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(str1, int1, str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（十一）类"><a href="#（十一）类" class="headerlink" title="（十一）类"></a>（十一）类</h2><h3 id="面向个体（面向对象）"><a href="#面向个体（面向对象）" class="headerlink" title="面向个体（面向对象）"></a>面向个体（面向对象）</h3><ul><li>“个体（对象）”在程序中是由数据和方法组成的封装体，并基于模拟现实来做对应</li><li>类是概念的抽象，个体（对象）是类的实例</li></ul><h4 id="头文件-h"><a href="#头文件-h" class="headerlink" title="头文件.h"></a>头文件.h</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//.h或.hpp文件里一般包含实现的内联函数</span></span><br><span class="line"><span class="comment">//在头文件中定义中，如果直接实现某成员函数，无论是否加inline，都是内联函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:<span class="comment">//私有访问修饰符</span></span><br><span class="line">    string _name;<span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">//公有访问修饰符</span></span><br><span class="line">    <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">Student</span>();<span class="comment">//构造函数</span></span><br><span class="line">        ~<span class="built_in">Student</span>();<span class="comment">//析构函数</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">function1</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">//成员函数</span></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">function2</span><span class="params">(string str)</span><span class="comment">//内联函数</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:<span class="comment">//保护访问修饰符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="源文件-cpp"><a href="#源文件-cpp" class="headerlink" title="源文件.cpp"></a>源文件.cpp</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Student.h&quot;</span><span class="comment">//引用头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//::作用域解析运算符</span></span><br><span class="line">Student::<span class="built_in">Student</span>()<span class="comment">//构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Student::~<span class="built_in">Student</span>()<span class="comment">//析构函数</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::function1</span><span class="params">(<span class="type">int</span> num)</span><span class="comment">//成员函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主函数调用"><a href="#主函数调用" class="headerlink" title="主函数调用"></a>主函数调用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Student.h&quot;</span><span class="comment">//引用头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stu</span><span class="params">()</span></span>;<span class="comment">//生成实例</span></span><br><span class="line">    stu.<span class="built_in">function1</span>(<span class="number">12</span>);</span><br><span class="line">    stu.<span class="built_in">function2</span>(<span class="string">&quot;HelloWorld!&quot;</span>);</span><br><span class="line">    cout &lt;&lt; stu._name &lt;&lt; endl;<span class="comment">//报错，无法获取私有变量</span></span><br><span class="line">    cout &lt;&lt; stu.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:<span class="comment">//修饰的成员在任意地方都可以访问</span></span><br><span class="line"><span class="keyword">private</span>:<span class="comment">//修饰的成员只能在类中或者友元函数中才可访问</span></span><br><span class="line"><span class="keyword">protected</span>:<span class="comment">//修饰的成员能在类中、子类中或者友元函数中访问</span></span><br></pre></td></tr></table></figure><h3 id="类与结构体"><a href="#类与结构体" class="headerlink" title="类与结构体"></a>类与结构体</h3><ul><li>类的<code>默认成员</code>是私有的private</li><li>结构体<code>默认成员</code>是公有的public</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Teacher</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="面向个体之封装"><a href="#面向个体之封装" class="headerlink" title="面向个体之封装"></a>面向个体之封装</h3><ul><li>外部访问类中私有成员变量，使用封装函数</li><li>当某个值确实需要私有化，且允许获取与设置时，使用自定义Get和Set函数进行封装</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 --------------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _score;<span class="comment">//私有变量推荐加上下划线或其他做区分</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Teacher</span>();</span><br><span class="line">    ~<span class="built_in">Teacher</span>();</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getScore</span><span class="params">()</span><span class="comment">//获取Get</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _score;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">setScore</span><span class="params">(<span class="type">int</span> score)</span><span class="comment">//设置Set</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            _score = score;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主函数 --------------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;头文件.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Teacher <span class="title">teacher</span><span class="params">()</span></span>;</span><br><span class="line">    teacher.<span class="built_in">setScore</span>(<span class="number">100</span>);<span class="comment">//设置</span></span><br><span class="line">    cout &lt;&lt; teacher.<span class="built_in">getScore</span>() &lt;&lt; endl;<span class="comment">//获取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li>构造函数以类名作为函数名，且构造函数没有返回值</li><li>构造函数在实例被构造时会调用</li><li>构造函数一般用于进行成员变量的初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 -------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _playerID = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>();<span class="comment">//构造函数定义</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">setPlayerID</span><span class="params">(<span class="type">int</span> playerID)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            _playerID = playerID;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 源文件 -------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;头文件.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">Player::<span class="built_in">Player</span>()&#123;&#125;<span class="comment">//默认构造函数实现</span></span><br><span class="line">Player::<span class="built_in">Player</span>(<span class="type">int</span> playerID)<span class="comment">//带参构造函数实现</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;实例被构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    _playerID = playerID;</span><br><span class="line">&#125;</span><br><span class="line">Player::<span class="built_in">Player</span>(<span class="type">int</span> playerID, <span class="type">int</span> adder)</span><br><span class="line">    : _playerID(playerID)&#123;&#125;<span class="comment">//初始化参数列表写法，使用“,”间隔</span></span><br><span class="line"><span class="comment">// 主函数 -------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;头文件.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Player <span class="title">player1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Player <span class="title">player2</span><span class="params">(<span class="number">1001</span>)</span></span>;</span><br><span class="line">    Player* p_player3 = <span class="keyword">new</span> <span class="built_in">player</span>(<span class="number">1002</span>);<span class="comment">//使用指针来分配内存</span></span><br><span class="line">    p_player3-&gt;<span class="built_in">setPlayerID</span>(<span class="number">1003</span>);<span class="comment">//对于指针而言，获取其原数据下的内容使用“-&gt;”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul><li>析构函数以“~”与类名作为函数名，且构造函数没有参数</li><li>析构函数在实例过期时会调用</li><li>析构函数一般用于进行成员变量的清理</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 -------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _playerID = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>();</span><br><span class="line">    <span class="built_in">Player</span>(<span class="type">int</span>);</span><br><span class="line">    ~<span class="built_in">Player</span>();<span class="comment">//析构函数定义</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 源文件 -------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;头文件.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">Player::<span class="built_in">Player</span>()&#123;&#125;</span><br><span class="line">Player::<span class="built_in">Player</span>(<span class="type">int</span> playerID)</span><br><span class="line">&#123;</span><br><span class="line">    _playerID = playerID;</span><br><span class="line">&#125;</span><br><span class="line">Player::~<span class="built_in">Player</span>(<span class="type">int</span> playerID)<span class="comment">//析构函数实现</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> _playerID;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主函数 -------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;头文件.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Player <span class="title">player2</span><span class="params">(<span class="number">1001</span>)</span></span>;<span class="comment">//占用栈内存，直接释放</span></span><br><span class="line">    Player* p_player3 = <span class="keyword">new</span> <span class="built_in">player</span>(<span class="number">1002</span>);<span class="comment">//占用堆内存，手动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><ul><li>包括构造与析构，类中每一个<code>成员函数</code>都有一个this指针</li><li>this指针指向当前调用个体（对象）</li><li>可以通过<code>this-&gt;</code>或<code>(*this).</code>来获取当前个体（对象）的成员</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 -------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _playerID = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>();</span><br><span class="line">    ~<span class="built_in">Player</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 源文件 -------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;头文件.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">Player::<span class="built_in">Player</span>()&#123;&#125;</span><br><span class="line">Player::<span class="built_in">Player</span>(<span class="type">int</span> playerID)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_playerID = playerID;<span class="comment">//this表示本地本物体</span></span><br><span class="line">&#125;</span><br><span class="line">Player::~<span class="built_in">Player</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_playerID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><ul><li>友元函数不是任何类的成员函数，却可以访问被允许类的私有数据</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件 -------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">SetPlayerID</span><span class="params">(Player player, <span class="type">int</span>)</span></span>;<span class="comment">//友元函数声明</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _playerID = <span class="number">1000</span>;</span><br><span class="line">    <span class="type">int</span>&amp; r_playerID = _playerID;<span class="comment">//形参只有指针或引用时才能被修改</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getPlayerID</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_playerID;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 源文件 -------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;头文件.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">Player::<span class="built_in">Player</span>()&#123;&#125;</span><br><span class="line">Player::~<span class="built_in">Player</span>()&#123;&#125;</span><br><span class="line"><span class="comment">// 主函数 -------------------------------</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;头文件.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetPlayerID</span><span class="params">(Player player, <span class="type">int</span> playerID)</span><span class="comment">//友元函数实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    player.r_playerID = playerID;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Player <span class="title">player</span><span class="params">()</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">getPlayerID</span>() &lt;&lt; endl;<span class="comment">//输出1000</span></span><br><span class="line">    <span class="built_in">SetPlayerID</span>(player, <span class="number">2000</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">getPlayerID</span>() &lt;&lt; endl;<span class="comment">//输出2000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面向个体之继承"><a href="#面向个体之继承" class="headerlink" title="面向个体之继承"></a>面向个体之继承</h3><ul><li>继承即在一个已经存在的类的基础上再新建一个类，子类共用父类成员</li><li>继承可以是<code>公有继承</code>、<code>私有继承</code>以及<code>受保护继承</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Human头文件 -------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Human</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    string _name;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Human</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span></span>;<span class="comment">//子类可访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Teacher头文件 -------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> : <span class="keyword">public</span> Human</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string teacherWork _twork;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Teacher</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Teaching</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Student头文件 -------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Human</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string studentWork _swork;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Student</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Learning</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> string <span class="title">getStudentName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _name;<span class="comment">//调用父类成员</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面向个体之多态"><a href="#面向个体之多态" class="headerlink" title="面向个体之多态"></a>面向个体之多态</h3><ul><li>多态性包括不同个体共用同一个函数调用，不同的个体在接收时会产生不同的行为</li></ul><h4 id="构成多态的条件"><a href="#构成多态的条件" class="headerlink" title="构成多态的条件"></a>构成多态的条件</h4><ul><li>必须存在类的<code>继承</code>关系</li><li>必须有派生类<code>重写</code>基类的<code>成员虚函数</code></li><li>在外部使用基类的<code>类指针</code>来调用虚函数</li></ul><h4 id="多态多么变态"><a href="#多态多么变态" class="headerlink" title="多态多么变态"></a>多态多么变态</h4><ul><li>当派生类重写基类中的成员函数时，将基类中被重写的函数设为虚函数<code>virtual</code></li><li>如果不添加<code>virtual</code>关键字，编译器就会根据当前个体类型调用其类型的成员方法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> &amp;lt;iostream&amp;gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// Parent头文件 -------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//该基类方法已被其他派生类重写，所以需要加virtual关键字</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eat</span><span class="params">()</span><span class="comment">//Parent基类的eat方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Parent eat&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Child头文件 -------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">override</span><span class="comment">//Child类的eat方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child eat&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// OtherChild头文件 -------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OtherChild</span> : <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">override</span><span class="comment">//OtherChild类的eat方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;OtherChild eat&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 主函数 -------------------------------</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parent parent;</span><br><span class="line">    Child child;</span><br><span class="line">    OtherChild otherchild;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Parent* ptr_par;<span class="comment">//创建基类类指针</span></span><br><span class="line">    ptr_par = &amp;parent;</span><br><span class="line">    ptr_par-&gt;<span class="built_in">eat</span>();<span class="comment">//调用虚函数</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    ptr_par = &amp;child;</span><br><span class="line">    ptr_par-&gt;<span class="built_in">eat</span>();<span class="comment">//调用虚函数</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    ptr_par = &amp;otherchild;</span><br><span class="line">    ptr_par-&gt;<span class="built_in">eat</span>();<span class="comment">//调用虚函数</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-试水&quot;&gt;&lt;a href=&quot;#C-试水&quot; class=&quot;headerlink&quot; title=&quot;C++试水&quot;&gt;&lt;/a&gt;C++试水&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;稍微学了一点c++，然后放弃了。。。&lt;/li&gt;
&lt;li&gt;这里是学习笔记&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="C++" scheme="http://iamsleepingnow.github.io/categories/C/"/>
    
    
    <category term="硬核" scheme="http://iamsleepingnow.github.io/tags/%E7%A1%AC%E6%A0%B8/"/>
    
    <category term="程序" scheme="http://iamsleepingnow.github.io/tags/%E7%A8%8B%E5%BA%8F/"/>
    
    <category term="C++" scheme="http://iamsleepingnow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Unity天坑VFX</title>
    <link href="http://iamsleepingnow.github.io/2021/03/03/Unity/Unity%E5%A4%A9%E5%9D%91VFX/"/>
    <id>http://iamsleepingnow.github.io/2021/03/03/Unity/Unity%E5%A4%A9%E5%9D%91VFX/</id>
    <published>2021-03-03T13:25:15.000Z</published>
    <updated>2021-07-03T13:45:24.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity天坑VFX"><a href="#Unity天坑VFX" class="headerlink" title="Unity天坑VFX"></a>Unity天坑VFX</h1><ul><li>坑多没关系，主要是香啊</li><li>可以先看看有多<a href="https://github.com/Unity-Technologies/VisualEffectGraph-Samples">香</a></li><li>这里是英文版的<a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@10.2/manual/index.html">文档</a></li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><ul><li><code>Package Manager</code> 里下载安装 <code>High Definition RP</code> 高清管线</li><li>在弹出的 <code>Wizard</code> 里 <code>Fix All</code> ，这样就能用了</li><li>在 <code>Project</code> 窗口里新建 <code>Visual Effect</code> 文件</li><li>在 <code>Hierarchy</code> 窗口里新建 <code>Visual Effect</code> 物体，将文件附上去</li><li>双击VFX的文件，打开VFX窗口</li><li>编译的按钮在VFX窗口左上角 <code>Compile</code> ，<code>Auto</code> 按钮开启自动编译</li><li>保存是 <code>ctrl + S</code></li></ul><h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><ul><li><code>VFX（VisualEffectGraph）</code> 是节点式的，就像 <code>ShaderGraph</code> 一样，使用前需要知道世界的本原</li><li>和 <code>ShaderGraph</code> 不同，世界信号是自上向下传输的</li><li>世界是由 <code>内容块Context</code> 构成的，内容块分为两种： <code>绿块（命令块）</code> 和 <code>橙块（执行块）</code> （蓝块无法链接）</li><li>绿线接绿口，橙线接橙口</li><li>一个健康的粒子需要由以下结构构成<ul><li><code>生成块Spawn（绿）</code></li><li><code>初始化块Initialize Particle（绿转橙）</code></li><li><code>更新块Update Particle（橙）</code></li><li><code>渲染块Output Particle（橙）</code></li></ul></li><li>一个 <code>初始化块</code> 链接一个 <code>更新块</code> 能够构成一个 <code>系统</code> ，并生成一个虚线框来套在系统上，可以命名</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_1.png" width=350><ul><li>上面这个粒子是没有任何效果的，因为只搭好了结构，里面内饰还没有</li><li>右键这些内容块内部，创建一些子节点，这些子节点是树状的</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_2.png" width=350><ul><li>加一点节点，就像这样</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_3.png" width=350><ul><li><p>所以，正如同老版本粒子系统一样，粒子的基本运动是需要<strong>条件</strong>的：</p><ul><li><strong>发射量</strong>【生成块】</li><li><strong>生命周期</strong>【初始化块】</li><li><strong>速度</strong>【初始化块或更新块】</li><li><strong>渲染方法</strong>【渲染块】</li></ul></li><li><p>这个效果是很多直线上升的点点</p></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_4.png" width=250><h2 id="搜索节点"><a href="#搜索节点" class="headerlink" title="搜索节点"></a>搜索节点</h2><ul><li>在寻找节点时需要输入内容搜索，因为找的话很麻烦</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_5.png" width=350><ul><li><p>但这么多的节点其实时有规律的，第一个词多半是这些：</p><ul><li>Add【添加，在原有属性的基础上添加】</li><li>Set【设置，替换原有属性或属性初始化】</li><li>Blend【混合，与原有混合】</li><li>Inherit【继承，延续父类粒子】</li><li>Multiply【相乘，在原有属性的基础上相乘】</li><li>Position【空间，在一个区块内计算】</li><li>Orient【旋转，仅渲染块】</li></ul></li><li><p>特性词也有这些：</p><ul><li>Curve【曲线映射】</li><li>Map【映射计算】</li><li>Random【随机计算】</li><li>Collide【碰撞，仅更新块】</li><li>Force【力场，仅更新块】</li><li>Kill【消隐区间，区域内粒子清除】</li></ul></li></ul><h2 id="属性类子节点"><a href="#属性类子节点" class="headerlink" title="属性类子节点"></a>属性类子节点</h2><ul><li>搜索词太多了，在里面搜索不是什么好主意</li><li>不过，在点击某一个子节点时， <code>Inspector</code> 面板会显示它的所有信息</li><li>也就是说，所有关于<strong>属性修改</strong>的节点都可以由调整Inspector面板来调出</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_6.png" width=350><ul><li>它拥有四个下拉菜单：<ul><li><code>Attribute</code> 是要调整的属性种类，实在太多了</li><li><code>Composition</code> 是调整方法，有<strong>重载</strong>、<strong>添加</strong>、<strong>相乘</strong>、<strong>混合</strong>四种</li><li><code>Source</code> 是数值类型，有<strong>具体数值</strong>和<strong>继承</strong>两种</li><li><code>Random</code> 是随机方法，有<strong>关闭随机</strong>、<strong>组件范围</strong>、<strong>全局范围</strong>三种</li></ul></li></ul><h2 id="注意项"><a href="#注意项" class="headerlink" title="注意项"></a>注意项</h2><ul><li>有一些很重要的内容不成体系，但是不知道也不行</li></ul><h3 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h3><ul><li>粒子是有 <code>世界空间world</code> 和 <code>本地空间local</code> 的，默认是本地空间</li><li>在本地空间模式下，粒子物体的移动受本地影响，反之不受影响</li><li>点击<strong>任何橙色内容块</strong>右上角来修改全局空间</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_7.png" width=350><h3 id="空间暴露"><a href="#空间暴露" class="headerlink" title="空间暴露"></a>空间暴露</h3><ul><li>有一些跟<strong>坐标相关</strong>的数值会显示一个空间符号，默认是 <code>L</code> ，点击成 <code>W</code></li><li>就能在 <code>Scene场景</code> 里动态修改，这样就不需要锻炼抽象思维了</li><li>如果点击了没反应，说明编辑器UI出bug了，重新打开一遍VFX窗口即可</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_8.png" width=350><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_9.png" width=350><h3 id="粒子边界"><a href="#粒子边界" class="headerlink" title="粒子边界"></a>粒子边界</h3><ul><li>这个东西非常重要，每个粒子的初始化块里都有粒子边界设置</li><li>当<strong>屏幕视角</strong>移出粒子边界之后，粒子就<strong>直接不显示</strong>了，非常的突兀</li><li>所以在弄粒子时，粒子边界需要经常去调</li><li>所以暴露一下坐标（指 <code>W</code> ）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_10.png" width=350><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_11.png" width=350><h3 id="发射数量"><a href="#发射数量" class="headerlink" title="发射数量"></a>发射数量</h3><ul><li><code>生成块Spawn</code> 中修改的发射数量是一秒内发射个数，是<strong>速度</strong></li><li><code>初始化块Initialize Particle</code> 中修改的发射数量是最大可显示数量，是<strong>最大数量</strong></li><li>我使用三个例子来解释<strong>粒子寿命</strong>，<strong>粒子速度</strong>，<strong>最大数量</strong>之间的关系</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_12.png" width=350><ul><li>当<strong>粒子寿命</strong>为1秒时，<strong>速度</strong>为10时，<strong>最大数量</strong>如果为5，粒子0.1秒发射一个，吐5下停5下</li><li>当<strong>粒子寿命</strong>为1秒时，<strong>速度</strong>为5时，<strong>最大数量</strong>如果为10，粒子0.2秒发射一个，持续发射</li><li>当<strong>粒子寿命</strong>为0.5秒时，<strong>速度</strong>为10时，<strong>最大数量</strong>如果为5，粒子0.1秒发射一个，持续发射</li></ul><h2 id="事件入门"><a href="#事件入门" class="headerlink" title="事件入门"></a>事件入门</h2><ul><li><p>有一个内容块比较特殊： <code>Event事件（绿）</code> 内容块</p></li><li><p>只有一个字符串属性： <code>Event Name</code> ，这里是和代码沟通的属性</p></li><li><p>实现一个小交互：左键播放，右键停止</p></li><li><p>首先需要有一个健康的粒子，至少能看到粒子发射</p></li><li><p>然后链接 <code>Spawn</code>  ，修改 <code>Event Name</code></p></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_13.png" width=650><ul><li>整一个脚本挂在粒子物体上即可</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.VFX;<span class="comment">//引用命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VisualEffectTest1</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> VisualEffect visualEffect;<span class="comment">//这里是粒子本体</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        visualEffect = GetComponent&lt;VisualEffect&gt;();<span class="comment">//获得粒子本体</span></span><br><span class="line">        visualEffect.Stop();<span class="comment">//一开始保证粒子停止播放</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))<span class="comment">//左键</span></span><br><span class="line">        &#123;</span><br><span class="line">            visualEffect.SendEvent(<span class="string">&quot;OnPlay&quot;</span>);<span class="comment">//传递事件信号</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">1</span>))<span class="comment">//右键</span></span><br><span class="line">        &#123;</span><br><span class="line">            visualEffect.SendEvent(<span class="string">&quot;OnStop&quot;</span>);<span class="comment">//传递事件信号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渲染内容块"><a href="#渲染内容块" class="headerlink" title="渲染内容块"></a>渲染内容块</h2><ul><li>VFX里提供了很多渲染块：（甚至展示不全）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_14.png" width=350><ul><li>在渲染块中，除了属性种类之外，还可以添加一些特殊效果：<ul><li><code>Camera Fade</code> 摄像机靠近自动消隐</li><li><code>Face Camera Plane</code> 始终面向摄像机</li><li><code>Subpixel Anti-Aliasing</code> 粒子抗锯齿</li><li><code>Screen Space Size</code> 始终保持视野大小（参见Superliminal游戏）</li><li><code>Tile/Wrap Positions</code> 越界粒子折返出现</li></ul></li><li>渲染块右键 <code>Convert Output</code> 可以更改渲染块类型</li></ul><h2 id="内容块外节点"><a href="#内容块外节点" class="headerlink" title="内容块外节点"></a>内容块外节点</h2><ul><li>在内容块以外右键创建节点，会是这样：</li><li><code>Context</code> 里就是<strong>内容块</strong>，带颜色（绿和黄）的那种</li><li><code>Operator</code> 即<strong>操纵器</strong>，几乎所有的数值计算方法</li><li><code>Property</code> 即<strong>自定义属性</strong>，<code>blackboard</code> 悬浮面板里新建的所有数值</li><li><code>System</code> 即内置的粒子<strong>模板</strong>，很方便</li><li><code>Misc</code> <strong>杂项</strong>里有分组器，能把一些节点放进去分类</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_15.png" width=350><h3 id="操纵器"><a href="#操纵器" class="headerlink" title="操纵器"></a>操纵器</h3><ul><li><code>Attribute</code> 即当前的<strong>总输出属性值</strong></li><li><code>Bitwise</code> 即<strong>按位运算</strong>，用的较少</li><li><code>BuiltIn</code> 即<strong>内建属性</strong>，有世界物体空间的转换以及一些系统的公有属性</li><li><code>Color</code> 即<strong>色彩模型转换</strong></li><li><code>Inline</code> 即<strong>内联属性</strong>，所有数据类型的形状都在这</li><li><code>Logic</code> 即<strong>逻辑运算</strong></li><li><code>Math</code> 即<strong>数学运算</strong>，只有你想不到的，没有我数学做不到的</li><li><code>Noise</code> 即<strong>噪音生成器</strong>，有14种</li><li><code>Random</code> 即<strong>随机生成器</strong></li><li><code>Sampling</code> 即<strong>采样</strong>，包含曲线、渐变、贴图的采样</li><li><code>Subgraph Operator</code> 即<strong>块中块</strong>，块中块得在 <code>Project</code> 里创建</li><li><code>Time</code> 即<strong>时间</strong>，时间建议直接搜索，更全面</li><li><code>Utility</code> 即<strong>实用工具</strong>，里面有点缓存加载器</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_16.png" width=350><h2 id="GPU事件"><a href="#GPU事件" class="headerlink" title="GPU事件"></a>GPU事件</h2><ul><li>在做GPU事件之前，先得勾选这个：</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_17.png" width=550><ul><li>勾选拓展包之后，有两个变化：<ul><li><code>Context</code> 中出现 <code>GPUEvent</code> 内容块</li><li><code>更新块Update Particle</code> 中能搜索 <code>Event</code> 了</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_18.png" width=350><ul><li><p>使用GPU事件可以让粒子按照时间流程来套娃</p></li><li><p>GPU事件块只能放在<strong>更新块</strong>内</p></li><li><p>拥有三种事件类型：</p><ul><li><code>Trigger Event Always</code> 始终触发</li><li><code>Trigger Event On Die</code> 销毁时触发</li><li><code>Trigger Event Rate</code> 按速率触发，其中：<ul><li><code>Over Time</code> 指每秒触发次数</li><li><code>Over Distance</code> 指粒子运动距离每超过一米之间的触发次数</li></ul></li></ul></li><li><p>在这种粒子套娃的情况下，新的粒子也许会继承之前的粒子的属性，这时可以使用 <code>Inherit</code></p></li><li><p>套娃的其他操作与之前类似</p></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_19.png" width=750><h2 id="拉丝模式"><a href="#拉丝模式" class="headerlink" title="拉丝模式"></a>拉丝模式</h2><ul><li>选择 <code>初始化块Initialize Particle（绿转橙）</code> 内容块， <code>Inspector</code> 面板里能选择一个选项： <code>Data Type</code> </li><li>将 <code>Data Type</code> 转换为 <code>Particle Strip</code> ，便开启了拉丝模式</li><li><code>初始化块Initialize Particle（绿转橙）</code> 变成了 <code>初始化块Initialize Particle Strip（绿转淡橙）</code> </li><li>初始化块链接的更新块也变成了独特的更新块</li><li>渲染块要选择独特的拉丝渲染块</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_20.png" width=350><ul><li>可以加一些独特的效果，相当于普通粒子效果里的<strong>拖尾</strong></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/unity_vfx/vfx_21.png" width=750><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>比普通粒子效果要难入门，难度可能凌驾于 <code>ShaderGraph</code> 之上</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity天坑VFX&quot;&gt;&lt;a href=&quot;#Unity天坑VFX&quot; class=&quot;headerlink&quot; title=&quot;Unity天坑VFX&quot;&gt;&lt;/a&gt;Unity天坑VFX&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;坑多没关系，主要是香啊&lt;/li&gt;
&lt;li&gt;可以先看看有多&lt;a h</summary>
      
    
    
    
    <category term="unity" scheme="http://iamsleepingnow.github.io/categories/unity/"/>
    
    
    <category term="受苦" scheme="http://iamsleepingnow.github.io/tags/%E5%8F%97%E8%8B%A6/"/>
    
    <category term="unity" scheme="http://iamsleepingnow.github.io/tags/unity/"/>
    
    <category term="VFX" scheme="http://iamsleepingnow.github.io/tags/VFX/"/>
    
    <category term="Visual Effect Graph" scheme="http://iamsleepingnow.github.io/tags/Visual-Effect-Graph/"/>
    
  </entry>
  
  <entry>
    <title>如何手工制作全景图片</title>
    <link href="http://iamsleepingnow.github.io/2021/02/27/Arts/%E5%A6%82%E4%BD%95%E6%89%8B%E5%B7%A5%E5%88%B6%E4%BD%9C%E5%85%A8%E6%99%AF%E5%9B%BE%E7%89%87/"/>
    <id>http://iamsleepingnow.github.io/2021/02/27/Arts/%E5%A6%82%E4%BD%95%E6%89%8B%E5%B7%A5%E5%88%B6%E4%BD%9C%E5%85%A8%E6%99%AF%E5%9B%BE%E7%89%87/</id>
    <published>2021-02-27T10:02:31.000Z</published>
    <updated>2021-02-28T06:52:12.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何手工制作全景图片"><a href="#如何手工制作全景图片" class="headerlink" title="如何手工制作全景图片"></a>如何手工制作全景图片</h1><h2 id="一：要有手"><a href="#一：要有手" class="headerlink" title="一：要有手"></a>一：要有手</h2><ul><li>你得会画图</li></ul><h2 id="二：要有工具"><a href="#二：要有工具" class="headerlink" title="二：要有工具"></a>二：要有工具</h2><ul><li>你得有画图工具PS（photoshop）</li><li>模型制作工具blender</li><li>贴图制作工具SP（substance painter）</li><li>渲染输出Unity3D</li></ul><h2 id="三：要有目标"><a href="#三：要有目标" class="headerlink" title="三：要有目标"></a>三：要有目标</h2><ul><li>最终目标是制作游戏天空盒，完成一张HDR高动态贴图</li></ul><h2 id="四：方法一：PS极坐标"><a href="#四：方法一：PS极坐标" class="headerlink" title="四：方法一：PS极坐标"></a>四：方法一：PS极坐标</h2><ul><li>原理是使用PS里的极坐标工具，将圆形拉伸成方形</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_0.png"  width="500"><ul><li>在这里我先制作两张测试图（4096 * 4096），分别为天和地</li><li>在测试图里面标明区域以及位置的标记</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_1.png"  width="300"><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_2.png"  width="300"><ul><li>在ps里面分别对这两张图做极坐标处理</li><li>选项选择 <code>极坐标到平面坐标</code> </li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_8.png"  width="300"><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_9.png"  width="300"><ul><li>处理后的图如下，圆图被拉伸成了方图</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_3.png"  width="300"><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_4.png"  width="300"><ul><li>将两张图的高度缩小为原来的四分之一，再倒着拼到一起（4096 * 2048）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_6.png"  width="500"><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_7.png"  width="500"><ul><li>这里我将图片导出，新建ps工程，将刚刚的图片导入</li><li>设置格式为RGB32位，拼合图像</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_10.png"  width="300"><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_11.png"  width="300"><ul><li>另存为HDR格式</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_16.png"  width="500"><ul><li>这时就完成了</li><li>放在Unity里测试一下</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_12.png"  width="300"><ul><li>结果还不错，没有什么离谱的拉伸，两极也很正常</li><li><a href="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/%E6%B5%8B%E8%AF%951.hdr">点此下载</a></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_13.png"  width="500"><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_14.png"  width="500"><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_15.png"  width="500"><h2 id="五：方法二：SP绘制"><a href="#五：方法二：SP绘制" class="headerlink" title="五：方法二：SP绘制"></a>五：方法二：SP绘制</h2><ul><li><p>原理是在球中绘制，在Unity中进行投射捕捉</p></li><li><p>第一步是制作“画布”，即一个分好UV的球（blender）</p></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_17.png"  width="300"><ul><li>第二步即绘制材质，天空盒材质（sp）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_18.png"  width="500"><ul><li>将球模型法线翻转，导入Unity，这里使用的是HDRP</li><li>新建无光材质Unlit，赋予贴图</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_19.png"  width="300"><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_20.png"  width="300"><ul><li>反射探针的烘焙需要所有模型设为静态，勾选Static</li><li>严格意义上来说是 <code>Reflection Probe Static</code> </li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_21.png"  width="300"><ul><li>再在创建的 <code>HDRP Asset</code> 配置文件里修改烘焙分辨率上限，缓存大小改为1，默认是64</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_22.png"  width="500"><ul><li>新建反射探针</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_23.png"  width="300"><ul><li>放在球的正中心，类型选自定义，形状选球形，开始烘焙</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_24.png"  width="700"><ul><li>然后就烘焙出了一个EXR文件，与HDR类似，也是高动态贴图</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_25.png"  width="300"><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/how2makehdr/hdr_26.png"  width="700"><ul><li>可以选择使用其他工具转换成HDR格式，但没这个需求</li></ul><h2 id="六：方法三：Unity摆场景"><a href="#六：方法三：Unity摆场景" class="headerlink" title="六：方法三：Unity摆场景"></a>六：方法三：Unity摆场景</h2><ul><li>与方法二类似，都是使用Unity烘焙反射探针</li><li>注意，需要在反射球中显示的物体都必须设置为静态</li><li>这个方法我认为是最方便的，因为只在Unity里就能完成</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何手工制作全景图片&quot;&gt;&lt;a href=&quot;#如何手工制作全景图片&quot; class=&quot;headerlink&quot; title=&quot;如何手工制作全景图片&quot;&gt;&lt;/a&gt;如何手工制作全景图片&lt;/h1&gt;&lt;h2 id=&quot;一：要有手&quot;&gt;&lt;a href=&quot;#一：要有手&quot; class=&quot;he</summary>
      
    
    
    
    <category term="技术美术" scheme="http://iamsleepingnow.github.io/categories/%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF/"/>
    
    
    <category term="技术美术" scheme="http://iamsleepingnow.github.io/tags/%E6%8A%80%E6%9C%AF%E7%BE%8E%E6%9C%AF/"/>
    
    <category term="记录" scheme="http://iamsleepingnow.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
    <category term="全景图" scheme="http://iamsleepingnow.github.io/tags/%E5%85%A8%E6%99%AF%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>透视入门</title>
    <link href="http://iamsleepingnow.github.io/2021/02/09/Arts/%E9%80%8F%E8%A7%86%E5%85%A5%E9%97%A8/"/>
    <id>http://iamsleepingnow.github.io/2021/02/09/Arts/%E9%80%8F%E8%A7%86%E5%85%A5%E9%97%A8/</id>
    <published>2021-02-09T15:21:10.000Z</published>
    <updated>2021-02-09T16:32:05.357Z</updated>
    
    <content type="html"><![CDATA[<h1 id="透视入门"><a href="#透视入门" class="headerlink" title="透视入门"></a>透视入门</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>在透视作用下，任意条具有<strong>同一角度</strong>的平行线相交于同一灭点，而且<strong>视点</strong>与该<strong>灭点</strong>之间的连线也与这些平行线平行</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/perspective/001.png"></p><ul><li>任何平行于地面的平行线相交的灭点都在视平线上</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/perspective/002.png"></p><h2 id="一点透视"><a href="#一点透视" class="headerlink" title="一点透视"></a>一点透视</h2><ul><li>当<strong>视平线</strong>与<strong>地平线</strong>重合（无俯仰），且<strong>透视平行线</strong>相交至<strong>心点</strong>时（无斜面）</li><li>一点透视里，<strong>灭点</strong>即<strong>心点</strong>，通常使用<strong>心视距</strong>确定<strong>距点</strong>，用<strong>距点</strong>测距</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/perspective/003.png"></p><h2 id="两点透视"><a href="#两点透视" class="headerlink" title="两点透视"></a>两点透视</h2><ul><li>当<strong>视平线</strong>与<strong>地平线</strong>重合（无俯仰），且<strong>透视平行线</strong>相交至<strong>余点</strong>时（无斜面）</li><li>正常情况下，两<strong>余点</strong>与<strong>视点</strong>之交线<strong>互相垂直</strong></li><li>两点透视里，<strong>灭点</strong>即<strong>余点</strong>，通常使用<strong>余视距</strong>确定<strong>测点</strong>，用<strong>测点</strong>测距</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/perspective/004.png"></p><h2 id="三点透视"><a href="#三点透视" class="headerlink" title="三点透视"></a>三点透视</h2><ul><li>当<strong>视平线</strong>与<strong>地平线</strong>重合（无俯仰），且<strong>透视平行线</strong>相交至<strong>余点</strong>时（无斜面），包括<strong>视点垂线</strong>上的<strong>余点</strong></li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/perspective/016.png"></p><h2 id="测高"><a href="#测高" class="headerlink" title="测高"></a>测高</h2><ul><li>任何由地平线而向地面作的垂线长度相等</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/perspective/005.png"></p><h2 id="测深"><a href="#测深" class="headerlink" title="测深"></a>测深</h2><h3 id="对角线测深法"><a href="#对角线测深法" class="headerlink" title="对角线测深法"></a>对角线测深法</h3><ul><li>四边形如果其对角线穿越其中线之二分之一处，就可断定该四边形为矩形。所以由此反证，确定两条等长平行线，用一条平行线的端点连接另一条平行线的中心点，可延长其深度</li><li>确定深度还有另一种方法，确定两条等长平行线，确定灭点，连接平行线其端点对角线，焦点与灭点的连线确定了其他深度的中心点</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/perspective/006.png"></p><h3 id="测量线测深法"><a href="#测量线测深法" class="headerlink" title="测量线测深法"></a>测量线测深法</h3><ul><li>对角线测深法无法分奇数倍，这时就需要测量线法</li><li>将平行线所在线投射到与视角平行的平行测量线上，测量线标明刻度，连接确定刻度点与深度点就可确定测量线灭点，通过连接测点（距点）与刻度点，与平行线所在线的交点即测量好的深度线</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/perspective/007.png"></p><h3 id="平行线平分法"><a href="#平行线平分法" class="headerlink" title="平行线平分法"></a>平行线平分法</h3><ul><li>如果要把两条深度平行线平分，在平行线上任意处做垂线，垂线即测量线，将测量线分为若干刻度，每一刻度与灭点相连，这时连接平行线对角线，与刻度灭点连线相交的点即平分点</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/perspective/008.png"></p><h3 id="对角线灭点法"><a href="#对角线灭点法" class="headerlink" title="对角线灭点法"></a>对角线灭点法</h3><ul><li>有两条深度平行线汇聚成一个灭点，连接深度平行线的对角线直到与地平线或灭点的垂线相交，称为对角线灭点。由对角线灭点向深度平行线上任意点连接，与两条平行线相交的两个点即深度对角线</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/perspective/009.png"  width="500"><h2 id="斜面"><a href="#斜面" class="headerlink" title="斜面"></a>斜面</h2><ul><li>绘制斜面时需要在<strong>灭点</strong>处（心点或余点）作<strong>垂直消失线</strong>，同时算好角度</li><li>俯视和仰视也是如此，以<strong>天地两点</strong>做水平线，用来代替<strong>地平线</strong></li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/perspective/010.png"></p><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/perspective/011.png"></p><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/perspective/012.png"></p><h2 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h2><h3 id="切圆法"><a href="#切圆法" class="headerlink" title="切圆法"></a>切圆法</h3><ul><li>近似圆的切法之一</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/perspective/013.png"  width="500"><h3 id="立体圆环注意事项"><a href="#立体圆环注意事项" class="headerlink" title="立体圆环注意事项"></a>立体圆环注意事项</h3><ul><li>因为透视关系，视点切圆于长轴，让人眼认为长轴就是直径，其实不然</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/perspective/014.png"  width="500"><h3 id="立体圆环"><a href="#立体圆环" class="headerlink" title="立体圆环"></a>立体圆环</h3><ul><li>圆环通常放在圆形包围框中，通过连接包围框对角线可得出圆心真实位置</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/perspective/015.png"></p><h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><ul><li><strong>投影边界</strong>与物体<strong>明暗交界线</strong>平行，是明暗交界线的投射</li><li>当然和斜面是一样的</li></ul><h3 id="平行光"><a href="#平行光" class="headerlink" title="平行光"></a>平行光</h3><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/perspective/017.png"></p><h3 id="点光"><a href="#点光" class="headerlink" title="点光"></a>点光</h3><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/perspective/018.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;透视入门&quot;&gt;&lt;a href=&quot;#透视入门&quot; class=&quot;headerlink&quot; title=&quot;透视入门&quot;&gt;&lt;/a&gt;透视入门&lt;/h1&gt;&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h</summary>
      
    
    
    
    <category term="艺术" scheme="http://iamsleepingnow.github.io/categories/%E8%89%BA%E6%9C%AF/"/>
    
    
    <category term="美术" scheme="http://iamsleepingnow.github.io/tags/%E7%BE%8E%E6%9C%AF/"/>
    
    <category term="基操" scheme="http://iamsleepingnow.github.io/tags/%E5%9F%BA%E6%93%8D/"/>
    
    <category term="透视" scheme="http://iamsleepingnow.github.io/tags/%E9%80%8F%E8%A7%86/"/>
    
  </entry>
  
  <entry>
    <title>梅尔休斯的《自由论》</title>
    <link href="http://iamsleepingnow.github.io/2021/02/05/Arts/%E6%A2%85%E5%B0%94%E4%BC%91%E6%96%AF%E7%9A%84%E3%80%8A%E8%87%AA%E7%94%B1%E8%AE%BA%E3%80%8B/"/>
    <id>http://iamsleepingnow.github.io/2021/02/05/Arts/%E6%A2%85%E5%B0%94%E4%BC%91%E6%96%AF%E7%9A%84%E3%80%8A%E8%87%AA%E7%94%B1%E8%AE%BA%E3%80%8B/</id>
    <published>2021-02-05T04:21:12.000Z</published>
    <updated>2021-02-05T04:48:07.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="梅尔休斯《自由论》"><a href="#梅尔休斯《自由论》" class="headerlink" title="梅尔休斯《自由论》"></a>梅尔休斯《自由论》</h1><p><a href="https://www.bilibili.com/video/BV1g4411L7yg?from=search&seid=5263003416777334157">《自由论》</a></p><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/arts/theoryoffree.png"></p><p>节选自第37届卡塞尔文献展（的机翻）</p><blockquote><p>如有侵权，立删 / Wenn ein Verstoß vorliegt， löschen Sie ihn sofort</p></blockquote><p>2018年11月15日，星期四|下午03:00</p><p>苏德弗格</p><p>节奏本身就是一种力量的工具，不接受任何阻力。</p><p>它在配乐，自由理论的编排和编排中得以展现。</p><p>由比约恩.梅尔休斯(Bjørn Melhus)拍摄的视频装置，由三张图片组成，在某些时候，是一幅同质景观的全景，上面有巨大的住宅塔楼，除了两个穿着蓝色和红色的运动装，戴着头盔的人物外，没人看见其他人。</p><p>天为他们做好一切准备：它们代表着“自由先生”和“独立小姐”的寓言。</p><p>在其他时候，三件套的图像像三联画一样出现，但兰迪(Randi)——代表基督教徒对救赎的希望，则没有摆在中间，他的立场即：穿着全套黑色的蓬松的女性服饰，她手里握着鞭子，语气严谨，设定了节奏。</p><p>象征性地夸大了，这是转世的艾恩.兰德(t1905-1982)的出现。</p><p>在俄罗斯长大，她以作家的名字而闻名，今天几乎以一种邪教般的方式受到崇拜，特别是因为她的客观主义理论。</p><p>在这种理论中，她表达了一种信念，即人可以不受命运控制地将命运掌握在自己手中。</p><p>生产性自我保护是她的最高目标，这是通过自由市场和资本主义实现的。</p><p>在梅尔休斯(Melhus)的作品中，她指挥着一群不死族，这些人被放在太平间里，然后由她招募，并进入行军模式。</p><p>因此，产生了一个怪诞且荒谬的游行，在这种游行中，“自由理论”的演练又回到了古老的宗教模式和启示性的恐惧中。</p><p>相应的短文引用是从美国主流电影中摘录的原始片段，这些原始电影摘录了观众的恐惧，然后观众又再次享受将自己屈服于未日场景的恐怖。</p><p>梅尔休斯亲自扮演所有角色，这本身就是对个人自由和独立性的特别评论。</p><p>尽管背景显示的建筑在世界各地似乎都可以互换，但值得注意的是它们是在伊斯坦布尔拍摄的，这很有趣，因为这座城市是一座现代化的大都市，因此面向自由市场的理想，但是另一方面也坚持保守宗教信仰。</p><p>梅尔休斯的《自由论》并没有采取单方面的立场，而是表明了荒谬是由于教条式的绝对主张而产生的，而且是一种恐惧与力量相互作用的心理特征。</p><p>by克里斯汀.霍尼特(Kerstin Honeit)</p><blockquote><p>总时长:00:13:00 Min.</p><p>国家:Germany</p><p>语言:English</p><p>年份:2015</p><p>导演: Bjørn Melhus</p><p>出品:Yuki Jungesblut</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;梅尔休斯《自由论》&quot;&gt;&lt;a href=&quot;#梅尔休斯《自由论》&quot; class=&quot;headerlink&quot; title=&quot;梅尔休斯《自由论》&quot;&gt;&lt;/a&gt;梅尔休斯《自由论》&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV</summary>
      
    
    
    
    <category term="艺术" scheme="http://iamsleepingnow.github.io/categories/%E8%89%BA%E6%9C%AF/"/>
    
    
    <category term="艺术" scheme="http://iamsleepingnow.github.io/tags/%E8%89%BA%E6%9C%AF/"/>
    
    <category term="文献" scheme="http://iamsleepingnow.github.io/tags/%E6%96%87%E7%8C%AE/"/>
    
    <category term="卡塞尔文献展" scheme="http://iamsleepingnow.github.io/tags/%E5%8D%A1%E5%A1%9E%E5%B0%94%E6%96%87%E7%8C%AE%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>Git操作步骤图解_Sourcetree</title>
    <link href="http://iamsleepingnow.github.io/2021/02/05/Git/Git%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%E5%9B%BE%E8%A7%A3_Sourcetree/"/>
    <id>http://iamsleepingnow.github.io/2021/02/05/Git/Git%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%E5%9B%BE%E8%A7%A3_Sourcetree/</id>
    <published>2021-02-04T16:32:40.000Z</published>
    <updated>2021-02-05T09:04:24.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git操作步骤图解-Sourcetree"><a href="#Git操作步骤图解-Sourcetree" class="headerlink" title="Git操作步骤图解_Sourcetree"></a>Git操作步骤图解_Sourcetree</h1><ul><li>自从被GitKraken的免费7天骗了之后，我突然觉得Sourcetree应该挺香的</li><li>先去下一个<a href="https://product-downloads.atlassian.com/software/sourcetree/ga/Sourcetree_4.0.2_236.zip">Sourcetree</a>，建议第三方加速，不然慢的一</li></ul><h2 id="（一）前戏"><a href="#（一）前戏" class="headerlink" title="（一）前戏"></a>（一）前戏</h2><ul><li>下载之后打开</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/97_st.png"  height="200"><ul><li>它会让你注册，你就点这个注册Bitbucket，不过上网要科学</li><li>网页上的内容就是一般的平台注册，英文阅读障碍可以用下翻译，这里不演示了</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/98_st.png"  height="300"><ul><li>就假装到这一步了</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/99_st.png"  height="300"><ul><li>会让你选插件，当然是全都要</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/100_st.png"  height="300"><ul><li>然后就是下一步下一步</li><li>应该会提醒链接你的Github账号，这时就可以链接一下</li><li>突然弹出这么一个框，因为现在还没有SSH（st专属的版本），就点否</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/101_st.png"  height="100"><ul><li>然后第一件事就是整SSH</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/102_st.png"  height="100"><ul><li>英文界面不要慌，Generate（生成）一下</li><li>然后 <code>Save public key</code> 和 <code>Save private key</code> 保存到 <code>C:/Users/user/.ssh</code> 里，格式是ppk</li><li>记得重命名不要覆盖之前已经有的密钥</li><li>如果完事后没反应可以加个载（Load）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/103_st.png"  height="400"><ul><li>然后进入选项</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/102_st.png"  height="100"><ul><li>Theme（主题）可以换成黑的（护眼）</li><li>还可以检查一下SSH有没有配置好</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/104_st.png"  height="400"><ul><li>换到Git选项卡，把底下的 <code>启用强制推送</code> 开起来</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/105_st.png"  height="400"><ul><li>芜湖，配置成功</li></ul><h2 id="（二）怎么用"><a href="#（二）怎么用" class="headerlink" title="（二）怎么用"></a>（二）怎么用</h2><h3 id="如何高效导入Unity工程"><a href="#如何高效导入Unity工程" class="headerlink" title="如何高效导入Unity工程"></a>如何高效导入Unity工程</h3><ul><li>现场来做个示范吧</li><li>比如说一个Unity工程的步骤存档</li><li>先在Github上弄一个仓库，网慢修改Host（无情）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/106_st.png"  height="450"><ul><li>这里复制仓库地址（经典操作）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/107_st.png"  height="200"><ul><li>点击标签页的加号，再点克隆（Clone）</li><li>填入仓库地址，本地文件位置，本地仓库文件夹名</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/108_st.png"  height="450"><ul><li>打开慈祥的Unity，在本地仓库里新建工程</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/109_st.png"  height="350"><ul><li>这时Sourcetree躁动不安</li><li>骚粉和紫色就是<strong>无效区</strong>和<strong>暂存区</strong>，无效区包含<strong>Git未托管的文件</strong>以及各种各样的<strong>修改了的文件</strong>，文件需要暂存了之后再来保存成版本</li><li>青色是版本提交区，可以写一些版本描述</li><li>绿色是检视面板，<code>分支</code> 是本地的分支，<code>远程</code> 是服务器的分支</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/110_st.png"  height="450"><ul><li>点击暂存所有，文件就都跑到暂存区了（报红就关一下Unity再暂存，当然也可以不关）</li><li>作为工程的起始，保存成 <code>版本初始化</code> ，好了提交</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/111_st.png"  height="450"><ul><li>本地存档了，但万一本地坏了，就应该去奢求上传服务器远程</li><li>点击上头的推送</li><li>这个意思是将本地 <code>main</code> 分支下的存档投递到服务器Github上的 <code>main</code> 分支</li><li>如果远程与本地有出入，本地想覆盖远程，可以勾选强制推送</li><li>由于Unity空工程有个50M，初始化需要投递一定的时间（1分钟）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/112_st.png"  height="250"><ul><li>切换检视面板到 <code>History</code> ，查看历史版本</li><li>发现在刚创建的初始版本之前，Git还创建了个版本，不用管它</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/113_st.png"  height="450"><ul><li>如果创建版本感觉后悔，可以选择追加修改（仅最后提交的版本）</li><li>这里我加入了DoTween插件</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/114_st.png"  height="250"><ul><li><p>切换到文件状态视图，暂存，一条龙</p></li><li><p>选择 <code>修改最后一次提交</code> ，在弹出框里选是，再提交，再推送（要强制推送）</p></li><li><p>这样就修改了刚提交的分支</p></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/115_st.png"  height="450"><ul><li>但是我突然发现Unity里文件一大堆，主要是配置文件，如果Unity版本不一致会出很多Bug，所以Unity工程需要多余的配置</li><li>所以删掉我们刚才的版本存档，我们重新来过（不要真去删文件啊）</li><li>右键原始版本 <code>Initial commit</code> 撤回分支，再强制提交</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/116_st.png"  height="250"><ul><li>回到文件状态视图，发现Git并没有删除原工程，只是将暂存退回了</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/117_st.png"  height="450"><ul><li>这里在网上（gitee）找到一个 <code>Git忽略</code> 文件，用来控制Unity忽略什么类型的文件</li></ul><p><a href="https://github.com/Iamsleepingnow/pywImage/blob/master/docs/gitignore%E6%96%87%E4%BB%B6">文件在这里复制和下载</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[Ll]ibrary/</span><br><span class="line">[Tt]emp/</span><br><span class="line">[Oo]bj/</span><br><span class="line">[Bb]uild/</span><br><span class="line">[Bb]uilds/</span><br><span class="line">[Ll]ogs/</span><br><span class="line"></span><br><span class="line"># Uncomment this line if you wish to ignore the asset store tools plugin</span><br><span class="line"># [Aa]ssets/AssetStoreTools*</span><br><span class="line"></span><br><span class="line"># Visual Studio cache directory</span><br><span class="line">.vs/</span><br><span class="line"></span><br><span class="line"># Gradle cache directory</span><br><span class="line">.gradle/</span><br><span class="line"></span><br><span class="line"># Autogenerated VS/MD/Consulo solution and project files</span><br><span class="line">ExportedObj/</span><br><span class="line">.consulo/</span><br><span class="line">*.csproj</span><br><span class="line">*.unityproj</span><br><span class="line">*.sln</span><br><span class="line">*.suo</span><br><span class="line">*.tmp</span><br><span class="line">*.user</span><br><span class="line">*.userprefs</span><br><span class="line">*.pidb</span><br><span class="line">*.booproj</span><br><span class="line">*.svd</span><br><span class="line">*.pdb</span><br><span class="line">*.mdb</span><br><span class="line">*.opendb</span><br><span class="line">*.VC.db</span><br><span class="line"></span><br><span class="line"># Unity3D generated meta files</span><br><span class="line">*.pidb.meta</span><br><span class="line">*.pdb.meta</span><br><span class="line">*.mdb.meta</span><br><span class="line"></span><br><span class="line"># Unity3D generated file on crash reports</span><br><span class="line">sysinfo.txt</span><br><span class="line"></span><br><span class="line"># Builds</span><br><span class="line">*.apk</span><br><span class="line">*.unitypackage</span><br><span class="line"></span><br><span class="line"># Crashlytics generated file</span><br><span class="line">crashlytics-build.properties</span><br></pre></td></tr></table></figure><ul><li><p>把它保存成 <code>.gitignore</code> ，删除文件拓展名，对，它就叫这个</p><ul><li>这个文件也可以自定义，比如：</li><li><code>*.psd</code> 指所有psd不予暂存</li><li><code>test.*</code> 指所有叫test的文件不予暂存</li><li><code>test.psd</code> 指这个文件不予暂存</li></ul></li><li><p>保存到仓库根目录</p></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/118_st.png"  height="250"><ul><li>选择这个忽略文件，暂存所选，单独为这个文件保存成一个版本，推送远程</li><li>再来暂存Unity工程，保存成版本，推送远程</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/119_st.png"  height="450"><ul><li>前往Github，来下载这个分支，发现这个文件贼他马小，说明它不包含Unity本地的配置信息</li><li>小到1M，压缩后300K，难以置信</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/120_st.png"  height="350"><ul><li><p>我不相信这个上传的文件是不是正常文件，事实胜于雄辩，版本需要检验</p></li><li><p>于是我重新克隆了一下服务器到本地，重新打开Unity</p></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/121_st.png"  height="250"><ul><li>草了，东西一分不少</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/114_st.png"  height="250"><ul><li>回想一下，如果没有忽略文件，上传的Unity空工程将高达50M</li></ul><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ul><li><p>回到原来的仓库，顺便把测试用的仓库删掉（无情）</p></li><li><p>随便加点东西（一直转的立方体）</p></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/122_st.png"  height="550"><ul><li>保存，暂存，版本（想必也会了）</li><li>这里多做了几个版本，不展示了</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/124_st.png"  height="250"><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/123_st.png"  height="250"><ul><li>来介绍一下这是什么意思 ↑</li><li>正如图谱所示，这个仓库的版本是直线式的，没有分支</li><li>如果做到版本5，也就是上材质这一步，开始做出不一样的变化，就需要使用分支</li><li>我们从版本4支出两个分支，一个橙色材质，一个蓝色材质</li><li><strong>因为本地Main分支呆在版本5上，如果我回退到版本4，版本5就将会被移除，就必须得用gitbush指令才能调出来，所以，在版本5创建一个分支，用来“钉固”版本5的存档</strong>（这句话很重要）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/125_st.png"  height="250"><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/126_st.png"  height="200"><ul><li>可以发现，版本5上停了两个分支（可以比作图钉）</li><li>双击左边检视面板的分支1，确保当前位置在分支1而不是main上</li><li>可以猜到，版本1上的两个origin是服务器上的分支，因为我们还没有推送上去</li><li>右键版本4，重置分支1的位置</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/128_st.png"  height="270"><ul><li>修改Unity，将材质调成蓝的</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/127_st.png"  height="250"><ul><li>暂存，保存成版本6</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/129_st.png"  height="200"><ul><li><p>这样就一目了然了</p></li><li><p>Git遵循这些定理：</p><ul><li><strong>如果存档是直线式的，必须保证最后版本上至少有一个分支</strong></li><li><strong>如果存档是叉树式的，必须保证该叉树上的最后版本上至少有一个分支</strong></li><li><strong>开辟叉树的时候一定要新建一个分支，用来保护这个叉树</strong></li></ul></li><li><p>双击左边检视面板的某个分支，Unity会自动跳转到分支下的版本的样子</p></li><li><p>问题又来了，我只想查看每个版本里的文件，不想建那么多复杂的分支怎么办</p></li><li><p>可以在想要跳转的版本那里右键，检出</p></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/130_st.png"  height="150"><ul><li>会提示一个信息，意思是：你<strong>只能停留在分支上</strong>，而检出时会创建一个叫 <code>HEAD</code> 的标签，来替代停留的分支，如果再双击左边检视面板的某个分支，你就会跳到分支上，<code>HEAD</code> 就<strong>会被移除</strong> </li><li>它的提示里有一句话很重要：“<strong>除非你后面创建一个新分支</strong>”，提示了<strong>如果检出，想要在检出上发展新版本，就必须要新建个分支来保存这个版本</strong></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/131_st.png"  height="250"><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/132_st.png"  height="200"><ul><li>因为Git控制了工程版本，Unity也会做出反映，要你重新加载（现在在版本3）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/133_st.png"  height="200"><ul><li>新建分支2来保存</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/134_st.png"  height="225"><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><ul><li>这里还有一个合并的功能，但是在这里不太顶用，但是在修改文本文件时还算可以</li><li>双击main分支，点合并，这里选择与版本7合并</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/135_st.png"  height="550"><ul><li>它一定会提示你发生冲突，没有冲突的情况特别少</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/136_st.png"  height="225"><ul><li>点击未暂存文件夹，右边就可以看见冲突代码</li><li>如果单说是脚本修改的话，那还好说，因为它用这种方法来表示冲突：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">目前所在分支的代码</span><br><span class="line">+ =======</span><br><span class="line">要与之合并的分支的代码</span><br><span class="line">+ &gt;&gt;&gt;&gt;&gt;&gt;&gt; 要合并的分支名</span><br></pre></td></tr></table></figure><ul><li>只留下需要的代码，这些等号和尖括号什么都要删掉（好他马奇怪）</li><li>（如果不想要这些合并纠错，可以点顶上的丢弃）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/137_st.png"  height="550"><ul><li>于是我把等号和尖括号都删掉了</li><li>而且事实证明，在vscode里这种东西更好修改（但是vscode没有很图形化的git表达）<ul><li>比如说要保留某一方的修改或者保留双方时，按个键就行了（这才是可视化）</li><li>所以推荐这个vscode（vscode天下第一！）</li></ul></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/138_st.png"  height="150"><ul><li>这时我们提交以下这个合并，让这个合并保存成一个新版本</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/139_st.png"  height="225"><ul><li>很明显，左边的图谱很直白了，版本3和版本7合并了</li><li>但是Unity报错了，说明这种场景文件的冲突不要乱合并，因为这种代码不是给人看的，所以<strong>要避免这种非代码的合并</strong> （但Unity里至少有些效果）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/140_st.png"  height="500"><ul><li>回退这个合并的气人版本，再丢弃合并信息</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/141_st.png"  height="250"><ul><li>最后我们再推送上去（分支要一个一个推）</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/142_st.png"  height="250"><ul><li>就是这么用的</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/143_st.png"  height="200">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git操作步骤图解-Sourcetree&quot;&gt;&lt;a href=&quot;#Git操作步骤图解-Sourcetree&quot; class=&quot;headerlink&quot; title=&quot;Git操作步骤图解_Sourcetree&quot;&gt;&lt;/a&gt;Git操作步骤图解_Sourcetree&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Github" scheme="http://iamsleepingnow.github.io/categories/Github/"/>
    
    
    <category term="Git" scheme="http://iamsleepingnow.github.io/tags/Git/"/>
    
    <category term="Github" scheme="http://iamsleepingnow.github.io/tags/Github/"/>
    
    <category term="存档神器" scheme="http://iamsleepingnow.github.io/tags/%E5%AD%98%E6%A1%A3%E7%A5%9E%E5%99%A8/"/>
    
    <category term="硬核" scheme="http://iamsleepingnow.github.io/tags/%E7%A1%AC%E6%A0%B8/"/>
    
    <category term="多图预警" scheme="http://iamsleepingnow.github.io/tags/%E5%A4%9A%E5%9B%BE%E9%A2%84%E8%AD%A6/"/>
    
    <category term="Sourcetree" scheme="http://iamsleepingnow.github.io/tags/Sourcetree/"/>
    
  </entry>
  
  <entry>
    <title>Git操作步骤图解_GitKraken</title>
    <link href="http://iamsleepingnow.github.io/2021/02/04/Git/Git%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%E5%9B%BE%E8%A7%A3_GitKraken/"/>
    <id>http://iamsleepingnow.github.io/2021/02/04/Git/Git%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%E5%9B%BE%E8%A7%A3_GitKraken/</id>
    <published>2021-02-04T04:11:20.000Z</published>
    <updated>2021-02-04T11:31:03.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git操作步骤图解-GitKraken"><a href="#Git操作步骤图解-GitKraken" class="headerlink" title="Git操作步骤图解_GitKraken"></a>Git操作步骤图解_GitKraken</h1><h2 id="GitKraken基础"><a href="#GitKraken基础" class="headerlink" title="GitKraken基础"></a>GitKraken基础</h2><ul><li>下载 <code>GitKraken</code> 软件，版本是6.5.0</li><li>这个软件在6.5.0之后要收费，所以要下6.5.0，<a href="https://release.axocdn.com/win64/GitKrakenSetup-6.5.0.exe">复制链接去迅雷</a></li><li>安装好之后不打开</li><li>防火墙配置：（只是为了防止它更新）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">控制面板\系统和安全\Windows Defender 防火墙:</span><br><span class="line">左边高级设置</span><br><span class="line">左边：出站规则</span><br><span class="line">右边：新建规则</span><br><span class="line">左边：程序</span><br><span class="line">找到GitKraken的程序目录，一般是：</span><br><span class="line">C:\Users\user\AppData\Local\gitkraken\Update.exe</span><br><span class="line">接着全是下一步</span><br></pre></td></tr></table></figure><ul><li>Hosts配置：（还是为了防止它更新）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一般在：C:\Windows\System32\drivers\etc\hosts 这里</span><br><span class="line">最底下加入：</span><br><span class="line"># gitKraken 更新屏蔽</span><br><span class="line">127.0.0.1 release.gitkraken.com api.gitkraken</span><br><span class="line">127.0.0.1 release.gitkraken.com</span><br><span class="line">就行了</span><br></pre></td></tr></table></figure><ul><li>然后打开kraken，注册，可以拿github的号来绑定</li></ul><hr><ul><li>好，我们开始：</li><li>这次拿gitee举例（之后都用Github），首先注册</li><li>先在gitee上创建一个仓库</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/68_kraken.png"></p><ul><li>可以发现它和github如出一辙</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/69_kraken.png"></p><ul><li>自动有一个master分支，八错</li><li>如果要进行合作使用的时候，这里推荐克隆服务器仓库，这样就不用自己设置了</li></ul><h2 id="GitKraken进阶-克隆新仓库"><a href="#GitKraken进阶-克隆新仓库" class="headerlink" title="GitKraken进阶_克隆新仓库"></a>GitKraken进阶_克隆新仓库</h2><ul><li>打开一个空文件夹，假设说这是仓库</li><li>右键会发现多了个 <code>Open with gitkraken</code> ，进入</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/70_kraken.png"  height="300"><ul><li><code>Clone a repo</code> 来克隆仓库</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/71_kraken.png"></p><ul><li>把gitee上的地址拷进去</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/72_kraken.png"></p><ul><li>输入密码（应该是Kraken的密码，也有可能不是，可以一个一个试）</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/73_kraken.png"></p><ul><li>就是这个界面了</li><li>左边 <code>LOCAL</code> 底下有 <code>master</code> 分支，表示你本地的分支</li><li>左边 <code>REMOTE</code> 底下有 <code>origin</code> ，表示服务器的名字，<code>master</code> 表示服务器上的分支</li><li>中间的 <code>Initial Commit</code> 就是gitee自动创建好的默认版本，不用管它</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/74_kraken.png"></p><ul><li>我在本地地址底下创建一个Unity工程，导入素材文件</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/75_kraken.png"></p><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/76_kraken.png"></p><ul><li>然后关闭</li><li>在kraken里就有了提示：（说我增加了3859个文件）</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/77_kraken.png"></p><ul><li>点击那个3859，发现右边变了</li><li>Unstaged Files窗口表示无效文件</li><li><code>Stage all changes</code> 就是 <code>git add .</code> 的意思</li><li>Staged Files窗口表示暂存文件</li><li>Commit Message里可以输入要保存的版本名以及描述信息</li><li>如果是修改最后保存的版本，可以启用Amend</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/78_kraken.png"  height="500"><ul><li>我们保存成一个版本，它就用树状图的形式显示出来</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/79_kraken.png"></p><ul><li>刷新网页，发现工程上传了</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/80_kraken.png"></p><h2 id="GitKraken进阶-下载新仓库"><a href="#GitKraken进阶-下载新仓库" class="headerlink" title="GitKraken进阶_下载新仓库"></a>GitKraken进阶_下载新仓库</h2><ul><li>这里模拟一个新人，也想修改并上传该工程</li><li>先随便新建文件夹，右键进入kraken，点击最上面的加号，添加仓库</li><li>这里不使用克隆，使用 <code>Start a local repo</code> 即新建，模拟本地与服务器不一致的情况</li><li>鼠标放 <code>REMOTE</code> 上有个加号，添加远程服务器，这里填服务器地址，名字自定义</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/81_kraken.png"></p><ul><li>然后就是这样的</li><li>青色分支表示本地版本，蓝色分支表示远程版本，一目了然</li><li>青色分支上的符号表示该分支拥有本地版本，蓝色分支上的符号表示该分支拥有远程版本</li><li>也有一个分支同时拥有两个符号的情况</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/82_kraken.png"></p><ul><li>双击左边 <code>REMOTE</code> 底下的 <code>master</code> ，切换当前分支到 <code>origin/master</code> ，相当于 <code>git fetch</code> + <code>git merge</code> ，会提示你应当创建一个新的分支来保存这个版本</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/83_kraken.png"></p><ul><li>然后你的文件夹就变出了Unity工程</li><li>双击 <code>REMOTE</code> 和 <code>LOCAL</code> 底下的分支，工作区的文件夹也会来回切换，相当于 <code>git checkout</code> </li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/84_kraken.png"></p><h2 id="GitKraken进阶-修改仓库"><a href="#GitKraken进阶-修改仓库" class="headerlink" title="GitKraken进阶_修改仓库"></a>GitKraken进阶_修改仓库</h2><ul><li>使用 <code>another_local_repo</code> 也就是刚刚新创建的第二个仓库，打开Unity工程</li><li>做亿点点修改</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/85_kraken.png"></p><ul><li>这里显示也有亿点点变化（1008个修改文件，1291个新增文件，应该是配置文件）</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/86_kraken.png"></p><ul><li>加入暂存，设置版本</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/87_kraken.png"  height="500"><ul><li>观察一下如果勾选了 <code>Amend</code> 的情况↓</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/88_kraken.png"  height="173"><ul><li>这里是树状图的变化：</li><li>意思是：继远程图标 <code>master</code> 的 <code>Unity测试版本_1</code> 之后，在本地的 <code>分支1</code> 新建了 <code>Unity测试版本_2</code></li><li>但它是本地的，还没有上传</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/89_kraken.png"></p><ul><li>上传点 <code>Push</code> </li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/90_kraken.png"></p><ul><li>等了一段时间之后（gitee比github快多了，但还是很慢，这次有个15分钟左右）</li><li>你会发现，服务器上的文件被替代了，这不是我们想要的，我们需要一次次的迭代</li><li>所以就需要先在本地里新建分支，再push到分支上，这样才有迭代的感觉</li><li>就像之前提到的 <code>git push 远程主机名 本地分支名:远程分支名</code> 差不多</li><li>所以我们在 <code>LOCAL/master</code> 这里右键，新建一个分支，姑且叫它 <code>modify_1</code></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/91_kraken.png"  height="300"><ul><li>这里就提示我们要push到服务器的哪个分支，这里填一个服务器里没有的分支（modify_1）</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/92_kraken.png"></p><ul><li>发现创建了服务器的 <code>modify_1</code>，合着我们刚才是在替换服务器源文件吗</li><li>所以，提交前要先新建分支</li></ul><h2 id="GitKraken进阶-更新本地文件"><a href="#GitKraken进阶-更新本地文件" class="headerlink" title="GitKraken进阶_更新本地文件"></a>GitKraken进阶_更新本地文件</h2><ul><li>回到之前创建的第一个本地仓库，发现里面的东西还是老版本的，所以这时我们要更新</li><li>但这个软件很优秀，它能实时更新数据，已经检测到服务器的新版本了</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/93_kraken.png"></p><ul><li>如果村里刚通网，可以使用上面的 <code>fetch</code> 按钮来将服务器文件拉回来</li><li>这时，如果双击 <code>REMOTE</code> 底下的 <code>modify_1</code> 分支，就能进入这个新分支，本地工程也随之更新了</li><li>然后会发现一个规律：<ul><li>双击远程分支后，git 将远程分支拉到了本地，这是因为本地只能修改本地的东西</li><li>树形图上，<code>modify_1</code> 的右边两个图标同时存在，这是因为本分支本地与远程同步</li></ul></li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/94_kraken.png"></p><ul><li>然后就是按照这个流程进行迭代，记住，多建分支</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/95_kraken.png"  height="250"><ul><li>多提一嘴：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">分支使用要求：</span><br><span class="line"></span><br><span class="line">①：如果存档是直线式的，</span><br><span class="line">必须保证最后版本上至少有一个分支，</span><br><span class="line">创建活动分支可以用来跳转版本</span><br><span class="line"></span><br><span class="line">②：如果存档是叉树式的，</span><br><span class="line">必须保证该叉树上的最后版本上至少有一个分支，</span><br><span class="line">开辟叉树的时候一定要新建一个分支，用来保护这个叉树</span><br><span class="line">创建活动分支可以用来跳转版本</span><br><span class="line"></span><br><span class="line">③：合并分支时，Git能够处理非二进制文件的合并，但二进制文件只能选择性保留</span><br></pre></td></tr></table></figure><ul><li>以及：</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/97_kraken.png" alt="pics/git_pics/97_kraken.png"></p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/96_all.png"  height="350">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git操作步骤图解-GitKraken&quot;&gt;&lt;a href=&quot;#Git操作步骤图解-GitKraken&quot; class=&quot;headerlink&quot; title=&quot;Git操作步骤图解_GitKraken&quot;&gt;&lt;/a&gt;Git操作步骤图解_GitKraken&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="Github" scheme="http://iamsleepingnow.github.io/categories/Github/"/>
    
    
    <category term="Git" scheme="http://iamsleepingnow.github.io/tags/Git/"/>
    
    <category term="Github" scheme="http://iamsleepingnow.github.io/tags/Github/"/>
    
    <category term="Git_workflow" scheme="http://iamsleepingnow.github.io/tags/Git-workflow/"/>
    
    <category term="GitKraken" scheme="http://iamsleepingnow.github.io/tags/GitKraken/"/>
    
    <category term="存档神器" scheme="http://iamsleepingnow.github.io/tags/%E5%AD%98%E6%A1%A3%E7%A5%9E%E5%99%A8/"/>
    
    <category term="硬核" scheme="http://iamsleepingnow.github.io/tags/%E7%A1%AC%E6%A0%B8/"/>
    
    <category term="多图预警" scheme="http://iamsleepingnow.github.io/tags/%E5%A4%9A%E5%9B%BE%E9%A2%84%E8%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Git操作步骤图解_GitBash</title>
    <link href="http://iamsleepingnow.github.io/2021/02/04/Git/Git%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%E5%9B%BE%E8%A7%A3_GitBash/"/>
    <id>http://iamsleepingnow.github.io/2021/02/04/Git/Git%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4%E5%9B%BE%E8%A7%A3_GitBash/</id>
    <published>2021-02-04T03:38:20.000Z</published>
    <updated>2021-02-09T16:33:09.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git操作步骤图解-GitBash"><a href="#Git操作步骤图解-GitBash" class="headerlink" title="Git操作步骤图解_GitBash"></a>Git操作步骤图解_GitBash</h1><h2 id="（〇）前戏"><a href="#（〇）前戏" class="headerlink" title="（〇）前戏"></a>（〇）前戏</h2><h3 id="比较重要的内容"><a href="#比较重要的内容" class="headerlink" title="比较重要的内容"></a>比较重要的内容</h3><ul><li><p><a href="https://git-scm.com/downloads">Git下载链接</a>     <a href="https://mirrors.tuna.tsinghua.edu.cn/github-release/git-for-windows/git/Git%20for%20Windows%202.30.0%282%29/Git-2.30.0.2-64-bit.exe">清华镜像Git下载链接</a></p></li><li><p>记得要在github上注册账户，或者gitee（国内的比较快）</p></li><li><p>Bash窗口里只要是没有输入符 <code>$</code> 就不能输入</p></li><li><p>Bash窗口里用鼠标右键复制粘贴<strong>千万不要按ctrl  + C/ctrl + V</strong>，特此提醒</p></li><li><p>Bash窗口中文乱码：右键-&gt;Options-&gt;左边Text-&gt;</p><ul><li>Local-&gt;zh_CN</li><li>Character set-&gt;UTF-8</li><li>Save</li><li><code>git config --global i18n.commitencoding utf-8</code> </li><li><code>git config --global i18n.logoutputencoding utf-8</code> </li></ul></li></ul><h3 id="SSH钥匙"><a href="#SSH钥匙" class="headerlink" title="SSH钥匙"></a>SSH钥匙</h3><ul><li>本则步骤出自于<a href="https://www.jianshu.com/p/73018a8d168b">简书</a>， 如果没有SSH，就无法与远程数据通信</li><li>在桌面上右键——&gt; <code>Git Bash Here</code> </li><li><code>cd ~/.ssh</code> 查看有没有密钥，如果右边黄字变化，说明有密钥</li><li><code>git config --global user.name &quot;用户名&quot;</code> （注意是英文引号）</li><li><code>git config --global user.email &quot;邮箱&quot;</code> （注意是英文引号）</li><li><code>ssh-keygen -t rsa</code> 生成公钥和私钥，写入github里的用户名密码</li><li><code>git config -l</code> 查看状态</li><li><code>cat ~/.ssh/id_rsa.pub</code> 查看公钥</li><li><code>cat ~/.ssh/id_rsa</code> 查看私钥</li></ul><h3 id="浏览器登不上GitHub怎么办"><a href="#浏览器登不上GitHub怎么办" class="headerlink" title="浏览器登不上GitHub怎么办"></a>浏览器登不上GitHub怎么办</h3><ul><li>进入<a href="http://tool.chinaz.com/dns/">站长工具</a></li><li>域名搜索： <code>github.com</code> ，找到TTL值最低的数字IP，一般是XXX.XXX.XXX.XXX，填入Host</li><li>域名搜索： <code>github.global.ssl.fastly.net</code> ，填入Host同上</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类似：</span><br><span class="line">XXX.XXX.XXX.XXX github.com</span><br><span class="line">XXX.XXX.XXX.XXX github.global.ssl.fastly.net</span><br><span class="line">还要加上：</span><br><span class="line">199.232.4.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure><h3 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">git init 【初始化仓库】</span><br><span class="line">git clone &lt;仓库地址&gt; 【窃取仓库】</span><br><span class="line">git status 【工作区文件状态】</span><br><span class="line">git add &lt;文件名&gt; 【将无效文件或修改文件变为暂存文件】</span><br><span class="line">git add . 【将所有无效文件或修改文件变为暂存文件】</span><br><span class="line">git commit -m &lt;版本名&gt; 【将暂存文件和有效文件保存为版本】</span><br><span class="line">git commit --amend 【修改追加最后一个保存版本】</span><br><span class="line">git log 【查看版本状态】</span><br><span class="line">git log --all --oneline 【查看所有分支下版本状态的精简版】</span><br><span class="line">git reflog 【查看日志历史】</span><br><span class="line">git branch &lt;分支名&gt; 【新建分支】</span><br><span class="line">git checkout -b &lt;分支名&gt; 【新建分支并进入】</span><br><span class="line">git checkout &lt;分支名&gt; 【进入分支】</span><br><span class="line">git checkout -d &lt;分支名&gt; 【删除分支】</span><br><span class="line">git branch 【查看分支列表】</span><br><span class="line">git reset &lt;版本哈希或前7位&gt; --soft/hard/mixed 【回溯版本】</span><br><span class="line">git rebase -i &lt;开始版本哈希值&gt; &lt;结束版本哈希值&gt; 【版本修改】</span><br><span class="line">git merge &lt;分支名&gt; 【合并分支】</span><br><span class="line">git remote add &lt;自定义远程主机名&gt; &lt;github上的仓库地址，以.git结尾&gt; 【建立远程链接】</span><br><span class="line">git push 远程主机名 &lt;本地分支名&gt;:&lt;远程分支名&gt; 【上传到服务器】</span><br><span class="line">git push -u origin &lt;本地分支名&gt;:&lt;远程分支名&gt; -f 【覆盖上传到服务器】</span><br><span class="line">git fetch &lt;远程主机名&gt; 【抓取服务器文件】</span><br><span class="line">git merge &lt;远程主机名&gt;/&lt;远程分支名&gt; 【同步分支到服务器上】</span><br><span class="line">git push origin --delete &lt;该删除的分支名&gt; 【删除服务器分支】</span><br></pre></td></tr></table></figure><h2 id="（一）初始化"><a href="#（一）初始化" class="headerlink" title="（一）初始化"></a>（一）初始化</h2><ul><li>在想要作为仓库的电脑目录里右键打开git小黑窗口——&gt; <code>Git Bash Here</code></li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/1_rightclick.png"></p><hr><ul><li>初始化仓库——&gt; <code>git init</code></li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/2_init.png"></p><ul><li>确保目录里除了想要作为版本迭代的文件还有一个仓库隐藏文件 <code>.git</code></li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/3_initcheck.png"></p><ul><li>如果显示了这一行， 表示你没有登录，git未设置用户信息</li><li>输入 <code>Run</code> 下面的两行就行</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/0_author.png"></p><hr><ul><li>接着查看仓库状态——&gt; <code>git status</code></li><li><code>On branch master</code> 表示当前分支叫 <code>master</code> (主分支)，跟右上角一致</li><li><code>No commits yet</code> 表示仓库里还没有声明版本</li><li><code>Untracked files</code> 表示拥有无效文件，无效文件用红色表示</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/4_initstatus.png"></p><ul><li><code>git status</code> 里文件四大状态<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">无效文件 untracked【红色】【新文件】</span><br><span class="line">暂存文件 staged【绿色】【进入暂存区的无效文件或修改文件】</span><br><span class="line">有效文件 tracked【不显示】【进入版本的暂存文件】</span><br><span class="line">修改文件 modified【红/绿】【改动的有效文件】</span><br></pre></td></tr></table></figure></li><li><code>git add 文件名</code> 能够将某一红色文件变成绿色</li><li><code>git add .</code> 能够将所有红色文件变成绿色</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/5_gitadd.png"></p><h2 id="（二）创建"><a href="#（二）创建" class="headerlink" title="（二）创建"></a>（二）创建</h2><ul><li><code>git commit -m 版本名</code> 用于创建一个版本</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/6_gitcommit-m.png"></p><hr><ul><li><code>git log</code> 用于查看所有版本及其状态<ul><li>使用 <code>--oneline</code> 可以看简要日志</li><li>使用 <code>--graph</code> 可以看日志图表</li><li>使用 <code>--reverse</code> 可以看倒序日志</li><li>使用 <code>--all</code> 可以看全部分支的版本</li><li>使用 <code>--n数字</code> 可以查看最近几次版本</li><li>使用 <code>--author 作者名</code> 可以依作者筛选</li><li>使用 <code>--since&#123;2020-12-21&#125;</code> 和 <code>--before&#123;2020-12-21&#125;</code> 可以依时间筛选</li><li>使用 <code>--decorate</code> 可以查看标签</li></ul></li><li>黄色乱码是指针地址，一般使用前7位用于定位该地址：<code>058544f</code></li><li><code>(HEAD -&gt; master)</code> 代表当前用户位于 <code>master</code> 分支下</li><li><code>Author</code> 版本创建作者，<code>Date</code> 版本创建日期</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/7_gitlog.png"></p><h2 id="（三）更新"><a href="#（三）更新" class="headerlink" title="（三）更新"></a>（三）更新</h2><ul><li>打开文件 <code>document.docx</code> ，在保存版本 <code>version_1</code> 时里面没有写任何东西：</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/8_document.png"></p><ul><li>对文件做修改，并保存</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/9_document.png"></p><hr><ul><li>然后 <code>git status</code> 检查文件状态</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/10_gitstatus.png"></p><ul><li><code>Changes not staged for commit</code> 表示非有效文件</li><li>红色 <code>modified</code> 表示修改文件</li><li>这时 <code>git add .</code> 就可以将修改文件加入暂存文件</li><li>当然，无论是红是绿都不是有效文件，因为有效文件不显示</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/11_modified.png"></p><ul><li>将暂存文件保存成版本 <code>version_2</code><ul><li>如果修改了文件，不想保存成新的版本，可以选择 <code>git commit --amend</code></li><li><code>--amend</code> 用于修复最近一次保存的版本</li><li><code>-i</code> </li></ul></li><li>查看版本状态</li><li><code>(HEAD -&gt; master)</code> 指向的是当前所处版本以及分支</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/12_version.png"></p><h2 id="（四）回溯"><a href="#（四）回溯" class="headerlink" title="（四）回溯"></a>（四）回溯</h2><h3 id="回溯基础"><a href="#回溯基础" class="headerlink" title="回溯基础"></a>回溯基础</h3><ul><li>突然就想让文件回到 <code>version_1</code> 的状态了</li><li><code>git reset 版本哈希或前7位 --soft/hard/mixed</code> 用于回溯版本</li><li><ul><li>如果使用 <code>--soft</code> ，表示更改当前用户位置 <code>HEAD</code> ，不会修改源文件，将【回溯前版本与回溯版本的差异】视为已暂存修改文件，<code>git status</code> 显示绿色修改文件</li><li>如果使用 <code>--hard</code> ，表示更改当前用户位置 <code>HEAD</code> ，会修改源文件</li><li>如果使用 <code>--mixed</code> ，表示更改当前用户位置 <code>HEAD</code> ，不会修改源文件，将【回溯前版本与回溯版本的差异】视为未暂存修改文件， <code>git status</code> 显示红色修改文件</li><li><code>git reset 版本哈希或前7位</code> 不一定要去找到那些哈希值，可以用以下方法来定位：↓<ul><li><code>HEAD</code> 指代当前的版本</li><li><code>HEAD^^^</code> 指代倒数第四个版本</li><li><code>HEAD~3</code> 指代倒数第四个版本</li></ul></li></ul></li><li><code>HEAD is now at 058544f version_1</code> 表示当前位于 <code>version_1</code> 版本</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/13_reset.png"></p><ul><li>但是查看版本列表时，之后的版本消失了</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/14_gitlog.png"></p><ul><li>打开文件 <code>document.docx</code> ，发现文件回到了 <code>version_1</code> 的状态：</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/8_document.png"></p><ul><li>这说明回溯有效</li></ul><hr><ul><li>但如何返回到 <code>version_2</code> 呢</li><li>使用 <code>git reflog</code> 查看历史</li><li>可以看到 <code>version_2</code> 的哈希值前7位为 <code>2920056</code></li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/15_gitreflog.png"></p><ul><li><code>git reset 版本哈希或前7位 --soft/hard/mixed</code> 回到目标版本</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/16_rereset.png"></p><h3 id="回溯进阶"><a href="#回溯进阶" class="headerlink" title="回溯进阶"></a>回溯进阶</h3><ul><li>这一节主要讲 <code>git rebase -i 开始版本哈希值 结束版本哈希值</code> 命令</li><li>这个命令会生成一个交互式文本编辑窗口，可以是任何文本编辑器</li><li>这里它自动给我打开了vscode</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/67_rebase.png"></p><ul><li>它的流程是：修改里面的前几行指令，保存关闭，vscode会重新弹出新的窗口，以此类推</li><li>下面几行是里面的指令提示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># p, pick &lt;commit&gt; = use commit</span><br><span class="line">版本重命名 r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="line"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="line">版本合并 s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="line"># f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&#x27;s log message</span><br><span class="line"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span><br><span class="line"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span><br><span class="line"># d, drop &lt;commit&gt; = remove commit</span><br><span class="line"># l, label &lt;label&gt; = label current HEAD with a name</span><br><span class="line"># t, reset &lt;label&gt; = reset HEAD to a label</span><br><span class="line"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span><br><span class="line"># .       create a merge commit using the original merge commit&#x27;s</span><br><span class="line"># .       message (or the oneline, if no original merge commit was</span><br><span class="line"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span><br></pre></td></tr></table></figure><ul><li>当 <code>rebase</code> 执行完之后，如果指针出于游离状态 <code>detached</code> ，就使用：<ul><li><code>git rebase --abort</code> 来退出 <code>rebase</code> </li></ul></li></ul><h2 id="（五）分支"><a href="#（五）分支" class="headerlink" title="（五）分支"></a>（五）分支</h2><ul><li>如果说上面的回溯很搞人心态，那么就需要使用分支系统</li><li>在例子里，假设希望在 <code>version_2</code> 的基础上继续增加版本，但希望版本与版本之间的切换更加的自如</li><li>那么就在 <code>version_2</code> 这里新建分支</li><li><code>git checkout -b 分支名</code> 新建一个分支并进入分支，或者使用 <code>git branch 分支名</code> 创建分支</li><li>然后就发现：右边蓝字修改了</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/17_branchcheck.png"></p><ul><li>再回到 <code>master</code> 主分支</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/18_branchcheck.png"></p><ul><li>再新建一个分支，再回到主分支</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/19_branchcheck.png" alt="pics/git_pics/19_branchcheck.png"></p><hr><ul><li><code>git branch</code> 用于查看所有分支</li><li>带 <code>*</code> 号的分支是当前所处分支</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/20_branch.png" alt="pics/git_pics/20_branch.png"></p><ul><li>现在进入 <code>branch_1</code> ，修改 <code>document.docx</code> 文件</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/21_branchmod.png" alt="pics/git_pics/21_branchmod.png"></p><ul><li>保存，进入暂存，一条龙</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/22_save.png" alt="pics/git_pics/22_save.png"></p><ul><li>在 <code>branch_1</code> 保存成一个版本</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/23_commit.png" alt="pics/git_pics/23_commit.png"></p><hr><ul><li>现在在 <code>branch_1</code> 和 <code>master</code> 里查看现在的版本状态</li><li>可以发现，分支里创建的版本在 <code>master</code> 里不显示，因为是子分支版本</li><li><code>(master, branch_2)</code> 表示 <code>version_2</code> 版本在两个分支里都能访问</li></ul><p style="text-align:center;color:rgb(150,150,150);font:bold 15px 华文中宋;">branch_1</p> ![pics/git_pics/24_gitstatus.png](https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/24_gitstatus.png)<p style="text-align:center;color:rgb(150,150,150);font:bold 15px 华文中宋;">master</p> ![pics/git_pics/25_gitstatus.png](https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/25_gitstatus.png)<ul><li>使用 <code>git checkout 分支名</code> 来跳转当前分支，会发现文件夹里的文件也在实时地变换</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/26_check.png" alt="pics/git_pics/26_check.png"></p><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/27_check.png" alt="pics/git_pics/27_check.png"></p><ul><li>所以，现在的关系是这样的：</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/28_versions.png"  height="200"><hr><ul><li>使用 <code>git branch -d 分支名</code> 来删除 <code>branch_2</code></li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/29_delbranch.png"></p><ul><li>现在重新创建这个 <code>branch_2</code> </li><li>喔嚯不小心打成了 <code>branch_3</code> ，使用 <code>git branch -m 分支名</code> 来重命名当前分支</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/30_branchrename.png"></p><ul><li>修改文件并保存版本</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/31_save.png"></p><ul><li>删除该分支</li><li>首先报了个 <code>... is not fully merged</code> 表示该分支还没有被合并，系统取消了这次删除指令</li><li>于是使用 <code>git branch -D 分支名</code> 来强制删除该分支</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/32_delbranch.png"></p><h2 id="（六）分支合并"><a href="#（六）分支合并" class="headerlink" title="（六）分支合并"></a>（六）分支合并</h2><ul><li>什么是分支合并</li><li>就是从 <code>master/version_2</code> 里分了 <code>branch_1/version_3</code> 和 <code>branch_2/version_4</code> ，将 <code>version_3</code> 和 <code>version_4</code> 合并到 <code>master/version_2</code> 里</li><li>于是我们先恢复 <code>branch_2</code></li><li>查看历史，找到哈希码 <code>1056d61</code> ，虽然不是显示 <code>branch_2</code> ，但从 <code>version_4</code> 可以推断出应该就是它</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/33_reflog.png"></p><ul><li>使用 <code>git checkout -b 分支名 哈希值</code> 这样就恢复了 <code>branch_2</code></li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/34_rebranch.png"></p><ul><li>回到 <code>master</code> ，使用 <code>git merge 分支名</code> 来合并分支</li><li>合并 <code>branch_1</code> 时显示正常</li><li>合并 <code>branch_2</code> 时发生了冲突，因为 <code>document.docx</code> 文件在两个分支版本中内容不同</li><li>发生冲突后，git会进行自动合并处理，但是word的编码出现了问题</li><li>这说明了两个问题：<ul><li>如果修改了 <code>branch_2</code> 的问题，就能正常合并</li><li>word格式无法正常自动合并，可以尝试其他文件格式</li></ul></li><li>出现了git 二进制文件冲突问题 <code>warning:Cannot merge binary files</code> ，超纲了</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/35_merge.png"></p><ul><li>当你修改好了冲突之后，回来一看：地址位于 <code>(master|MERGING)</code></li><li>这时就需要回退到当前版本：<code>git reset HEAD --hard</code> ，因为<code>HEAD</code> 指的是当前环境</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/43_back.png"></p><hr><ul><li>将 <code>.git</code> 和 <code>document.docx</code> 删除，我们重来，嘿嘿（没有翻车）</li><li>这次我使用 <code>.txt</code> 文件，里面啥都没写</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/38_newone.png"  height="200"><ul><li>标准一条龙</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/39_init.png"></p><ul><li>再打一套军体拳（应该知道写的是啥）</li><li>在两个不同版本里，也对txt文件做了版本修改</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/40_branch.png"></p><ul><li>接着合并</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/41_merge.png"></p><ul><li>因为txt文件编码符合要求，所以合并正常，没有warning</li><li>git贴心地将txt改成了这样：</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/42_merge.png"></p><ul><li>用这种方式来提示你这里有冲突（有点傻）</li><li>你就把txt改成你想要的样子</li><li>然后就新建一个分支，在新的分支底下保存新的版本（保证更新在平行版本下）</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/44_add.png"></p><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/45_commit.png"></p><ul><li>平行分支下版本也是平行的，分支与分支之间跳跃也非常的方便</li><li>可以想象：版本是横向的，分支是纵向的</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/46_commit.png"  height="300"><h2 id="（七）多人运动"><a href="#（七）多人运动" class="headerlink" title="（七）多人运动"></a>（七）多人运动</h2><h3 id="多人运动基础"><a href="#多人运动基础" class="headerlink" title="多人运动基础"></a>多人运动基础</h3><ul><li>在git上创建账户</li><li>Repositories就是仓库，去New一个</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/47_git.png"></p><ul><li>这就是新创建的仓库，可以等同于一个服务器端的仓库，用来和本地仓库沟通</li><li>左上角的 <code>main▲</code> 可以用来切换主分支，它默认是main</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/48_git.png"></p><ul><li>点开 <code>Code▲</code> 下拉菜单，在HTTPS底下可以找到该仓库的地址</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/49_git.jpg"></p><hr><ul><li>我们的带 <code>.git</code> 隐藏文件的文件夹就是一个本地目录</li><li>使用 <code>git remote add 自定义远程主机名 &lt;github上的仓库地址，以.git结尾&gt;</code> 建立远程链接</li><li>你如果修改好了本地文件，最好新建一个分支来保存版本，当然，不这么做也不会出问题</li><li>使用 <code>git push 远程主机名 本地分支名:远程分支名</code> 来将本地分支推送到远程主机的远程分支 ↓</li><li>举个例子，比如说：<ul><li> <code>git push origin master</code> 就是 <code>git push origin master:master</code> </li><li><code>git push origin master:master</code> 才是完整表达</li><li>如果出现红色 <code>[rejected]</code> 错误，说明服务器版本与本地版本不一致，则：</li><li>使用 <code>git push -u origin 本地分支名:远程分支名 -f</code> 来解决</li></ul></li><li>这里不该写 <code>master</code> 的，因为服务器上的默认分支是 <code>main</code></li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/50_push.jpg"></p><ul><li>Git就会弹出一个Github登录窗口</li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/51_git.png"  height="300"><ul><li><p>登录就完事儿了，毕竟是在github上有号的人</p></li><li><p>没完呢，还会弹出OpenSSH的准入窗口，就把Github用户名和密码填上去就行</p></li></ul><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/52_git.png"  height="150"><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/53_git.png"  height="150"><ul><li>就会显示这些内容：</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/54_git.png"></p><ul><li>将服务器的分支跳到 <code>master</code></li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/55_git.png"></p><ul><li>就能看到本地上传成功的消息</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/56_git.png"></p><ul><li>但是我们的  <code>test.txt</code> 文件的版本还处于 <code>version_2</code> ，是因为：</li><li>这行指令： <code>git push 远程主机名 本地分支名:远程分支名</code>  写错了</li><li>应该改为：<code>git push origin branch_3:master</code></li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/58_git.png"></p><ul><li>刷新网页，实时更新</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/57_git.png"></p><ul><li>好耶，可以把任何东西传到服务器上！</li></ul><hr><ul><li>那别人怎么下载呢</li><li>举个例子，<a href="https://github.com/menzi11/BullshitGenerator">狗屁不通文章生成器</a>这个仓库</li><li>点击 <code>Code▲</code> 复制仓库链接</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/59_git.png"></p><ul><li>随便在哪新建一个文件夹：</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/60_windows.png"></p><ul><li>右键——&gt; <code>Git Bash Here</code></li><li>下载：<code>git clone &lt;仓库链接，以.git结尾&gt; </code></li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/61_windows.png"></p><ul><li>你就下载了源码</li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/62_windows.png"></p><ul><li>使用 <code>git clone</code> 你就可以下载github服务器上的所有文件</li><li>注意，在 <code>BullshitGenerator</code> 目录里，同样有一个 <code>.git</code> 的隐藏文件</li><li>这说明 <code>BullshitGenerator</code> 目录也是一个本地仓库</li></ul><h3 id="多人运动进阶"><a href="#多人运动进阶" class="headerlink" title="多人运动进阶"></a>多人运动进阶</h3><ul><li><p>回到我们的 <code>git_test</code> 目录</p></li><li><p>假设说有人更新了github上的文件，你也必须更新本地文件</p><ul><li>可以直接在文件夹 <code>git clone</code> ，但是有风险，我们不用</li><li>也可以使用如下方法：↓</li></ul></li><li><p>第一步也是最重要的一步：<strong>新建一个分支并进入</strong>，记住，这是个坑，我检查了好几个小时</p></li><li><p><code>git merge</code> 用于合并本地已修改代码</p></li><li><p><code>git fetch 远程主机名</code> 用于抓取服务器文件</p></li><li><p><code>git merge 远程主机名/远程分支名</code> 用于将本地文件与服务器同步，并在刚才创建的分支本地创建一个新的版本，版本无法重命名，只能 <code>commit</code> 一个新的来命名</p></li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/63_fetch.png"></p><hr><ul><li>我如何删除服务器上的某个分支？</li><li>先使用 <code>git branch -a</code> 查看所有分支列表 <ul><li>白色 <code>main</code> 是本地分支</li><li>绿色 <code>master</code> 是当前分支</li><li>红色是服务器分支，都有 <code>remote</code> 标识</li></ul></li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/64_branch.png"></p><ul><li>先将当前分支转到本地最大分支，比如说是 <code>master</code></li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/65_branch.png"></p><ul><li>假设说要删掉 <code>remotes/origin/master</code> 的话，</li><li>使用 <code>git push origin --delete 该删除的分支名</code></li></ul><p><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/66_branch.png"></p><h3 id="多人运动流程简略"><a href="#多人运动流程简略" class="headerlink" title="多人运动流程简略"></a>多人运动流程简略</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">链接服务器：（只用执行一次，git会记住服务器地址的）</span><br><span class="line">git remote add 自定义远程主机名 &lt;github上的仓库地址，以.git结尾&gt;</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">上传：</span><br><span class="line">先保存修改为版本</span><br><span class="line">新建分支并进入（可选）</span><br><span class="line">git push 远程主机名 本地分支名:远程分支名 （最好输入一个新的远程分支）</span><br><span class="line">如果报错：</span><br><span class="line">就：git push -u origin 本地分支名:远程分支名 -f （最好输入一个新的远程分支）</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">下载：</span><br><span class="line">如果没有本地目录：</span><br><span class="line">就使用克隆：git clone &lt;仓库链接，以.git结尾&gt;</span><br><span class="line">克隆之后别忘了使用 git checkout ... 来进入某个分支</span><br><span class="line">如果有本地目录：</span><br><span class="line">新建分支并进入（必选）</span><br><span class="line">git merge</span><br><span class="line">git fetch 远程主机名</span><br><span class="line">git merge 远程主机名/远程分支名</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">删除：</span><br><span class="line">当前分支转到本地最大分支，类似 master</span><br><span class="line">git push origin --delete 该删除的分支名</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">速度太慢：</span><br><span class="line">C:\Windows\System32\drivers\etc\hosts: 在结尾加上：</span><br><span class="line">151.101.113.194 github.global.ssl.fastly.net</span><br><span class="line">192.30.253.112 github.com</span><br></pre></td></tr></table></figure><img src="https://iamsleepinggroup.coding.net/p/coding-devops-guide/d/link-pool/git/raw/master/pics/git_pics/96_all.png"  height="350">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git操作步骤图解-GitBash&quot;&gt;&lt;a href=&quot;#Git操作步骤图解-GitBash&quot; class=&quot;headerlink&quot; title=&quot;Git操作步骤图解_GitBash&quot;&gt;&lt;/a&gt;Git操作步骤图解_GitBash&lt;/h1&gt;&lt;h2 id=&quot;（〇）前戏</summary>
      
    
    
    
    <category term="Github" scheme="http://iamsleepingnow.github.io/categories/Github/"/>
    
    
    <category term="Git" scheme="http://iamsleepingnow.github.io/tags/Git/"/>
    
    <category term="Github" scheme="http://iamsleepingnow.github.io/tags/Github/"/>
    
    <category term="Git_workflow" scheme="http://iamsleepingnow.github.io/tags/Git-workflow/"/>
    
    <category term="存档神器" scheme="http://iamsleepingnow.github.io/tags/%E5%AD%98%E6%A1%A3%E7%A5%9E%E5%99%A8/"/>
    
    <category term="硬核" scheme="http://iamsleepingnow.github.io/tags/%E7%A1%AC%E6%A0%B8/"/>
    
    <category term="多图预警" scheme="http://iamsleepingnow.github.io/tags/%E5%A4%9A%E5%9B%BE%E9%A2%84%E8%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX入门</title>
    <link href="http://iamsleepingnow.github.io/2021/02/04/LaTeX/LaTeX%E5%85%A5%E9%97%A8/"/>
    <id>http://iamsleepingnow.github.io/2021/02/04/LaTeX/LaTeX%E5%85%A5%E9%97%A8/</id>
    <published>2021-02-03T16:00:50.000Z</published>
    <updated>2021-02-09T16:27:16.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LaTeX入门"><a href="#LaTeX入门" class="headerlink" title="LaTeX入门"></a>LaTeX入门</h1><h2 id="（〇）安装"><a href="#（〇）安装" class="headerlink" title="（〇）安装"></a>（〇）安装</h2><ul><li>使用迅雷</li></ul><ol><li><a href="https://mirrors.bfsu.edu.cn/CTAN/systems/texlive/Images/texlive2020.iso">https://mirrors.bfsu.edu.cn/CTAN/systems/texlive/Images/texlive2020.iso</a></li><li><a href="https://github.com/texstudio-org/texstudio/releases/download/3.0.4/texstudio-3.0.4-win-qt5.exe">https://github.com/texstudio-org/texstudio/releases/download/3.0.4/texstudio-3.0.4-win-qt5.exe</a></li></ol><h3 id="快速模板"><a href="#快速模板" class="headerlink" title="快速模板"></a>快速模板</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8,11pt]&#123;article&#125; <span class="comment">% 文章类型</span></span><br><span class="line"><span class="comment">% -------------------------------------</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125; <span class="comment">% 引入中文宏包</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125; <span class="comment">% 引用绘制宏包</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;xcolor&#125; <span class="comment">% 使用颜色宏包</span></span><br><span class="line"><span class="comment">% -------------------------------------</span></span><br><span class="line"><span class="keyword">\title</span>&#123;文档的标题&#125; <span class="comment">% 标题</span></span><br><span class="line"><span class="keyword">\author</span>&#123;作者名&#125; <span class="comment">% 作者</span></span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125; <span class="comment">% 日期</span></span><br><span class="line"><span class="comment">% -------------------------------------</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\maketitle</span> <span class="comment">% 显示文档信息</span></span><br><span class="line"><span class="comment">% -------------------------------------</span></span><br><span class="line"><span class="comment">% 正文</span></span><br><span class="line"><span class="comment">% -------------------------------------</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><h2 id="（一）文档"><a href="#（一）文档" class="headerlink" title="（一）文档"></a>（一）文档</h2><p>\documentclass{}</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[UTF8,11pt]&#123;ctexart&#125; <span class="comment">% 文章类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% article 文章</span></span><br><span class="line"><span class="comment">% proc 文集</span></span><br><span class="line"><span class="comment">% minimal 小型文档</span></span><br><span class="line"><span class="comment">% report 报导</span></span><br><span class="line"><span class="comment">% book 书籍</span></span><br><span class="line"><span class="comment">% slides 幻灯片</span></span><br><span class="line"><span class="comment">% beamer 幻灯片</span></span><br><span class="line"><span class="comment">% ctexart 中文文章</span></span><br><span class="line"><span class="comment">% ctexrep 中文报导</span></span><br><span class="line"><span class="comment">% ctexbook 中文书籍</span></span><br><span class="line"><span class="comment">% ctexbeamer 中文幻灯片</span></span><br></pre></td></tr></table></figure><h2 id="（二）引入"><a href="#（二）引入" class="headerlink" title="（二）引入"></a>（二）引入</h2><p>\usepackage{}</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;ctex&#125; <span class="comment">% 引入中文宏包</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125; <span class="comment">% 引用绘制宏包</span></span><br></pre></td></tr></table></figure><h2 id="（三）信息"><a href="#（三）信息" class="headerlink" title="（三）信息"></a>（三）信息</h2><p>\title{}</p><p>\author{}</p><p>\date{}</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\title</span>&#123;文档的标题&#125; <span class="comment">% 标题</span></span><br><span class="line"><span class="keyword">\author</span>&#123;作者名&#125; <span class="comment">% 作者</span></span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125; <span class="comment">% 日期</span></span><br></pre></td></tr></table></figure><h2 id="（四）环境"><a href="#（四）环境" class="headerlink" title="（四）环境"></a>（四）环境</h2><p>\begin{}</p><p>\end{}</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;环境类型&#125;</span><br><span class="line">...</span><br><span class="line">作用域</span><br><span class="line">...</span><br><span class="line"><span class="keyword">\end</span>&#123;环境类型&#125;</span><br></pre></td></tr></table></figure><h2 id="（五）执行与命令"><a href="#（五）执行与命令" class="headerlink" title="（五）执行与命令"></a>（五）执行与命令</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 宏执行：可传参的宏方法</span></span><br><span class="line"><span class="keyword">\section</span>&#123;宏执行&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 宏命令：需要手动定义作用域</span></span><br><span class="line">&#123;<span class="keyword">\textbf</span> 宏命令局部&#125;</span><br><span class="line"><span class="keyword">\textbf</span> 宏命令全局</span><br></pre></td></tr></table></figure><h2 id="（六）正文"><a href="#（六）正文" class="headerlink" title="（六）正文"></a>（六）正文</h2><p>{document}</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% \begin&#123;...&#125;和\end&#123;...&#125;构成一个环境</span></span><br><span class="line"><span class="comment">% 一个tex文档有且仅有一个document环境，表示正文</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="comment">% 正文夹在\begin&#123;document&#125;和\end&#123;document&#125;之间</span></span><br><span class="line">你好世界!</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><h2 id="（七）结构"><a href="#（七）结构" class="headerlink" title="（七）结构"></a>（七）结构</h2><p>\part{}</p><p>\chapter{}</p><p>\section{}</p><p>\subsection{}</p><p>\subsubsection{}</p><p>\tableofcontents</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\part</span>&#123;部分&#125; <span class="comment">% 部分</span></span><br><span class="line"><span class="keyword">\chapter</span>&#123;章节&#125; <span class="comment">% 章节，书籍排版book/ctexbook有效</span></span><br><span class="line"><span class="keyword">\section</span>&#123;一级标题&#125; <span class="comment">% 一级标题</span></span><br><span class="line"><span class="keyword">\subsection</span>&#123;二级标题&#125; <span class="comment">% 二级标题</span></span><br><span class="line"><span class="keyword">\subsubsection</span>&#123;三级标题&#125; <span class="comment">% 三级标题，book/ctexbook无效</span></span><br><span class="line"><span class="keyword">\tableofcontents</span> <span class="comment">% 目录显示</span></span><br></pre></td></tr></table></figure><h2 id="（八）段落"><a href="#（八）段落" class="headerlink" title="（八）段落"></a>（八）段落</h2><p>\newline</p><p>\\</p><p>\par</p><p>\indent</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 反斜杠是\newline的缩写，不会产生段落缩进，而\par可以，插入空行也可以，\indent是缩进字符</span></span><br><span class="line"><span class="keyword">\par</span></span><br><span class="line">文本内容文本内容文本内容文本内容</span><br><span class="line"><span class="keyword">\par</span></span><br><span class="line">文本内容文本内容文本内容文本内容</span><br><span class="line"><span class="keyword">\\</span>[1ex]</span><br><span class="line">文本内容文本内容文本内容文本内容</span><br><span class="line"></span><br><span class="line">文本内容文本内容文本内容文本内容</span><br><span class="line"><span class="keyword">\\</span> <span class="keyword">\indent</span></span><br><span class="line">文本内容文本内容文本内容文本内容 <span class="comment">% 取消缩进</span></span><br><span class="line">&#123;<span class="keyword">\setlength</span>&#123;<span class="keyword">\parindent</span>&#125;&#123;0pt&#125; 文本内容文本内容文本内容文本内容&#125;</span><br></pre></td></tr></table></figure><h2 id="（九）字体"><a href="#（九）字体" class="headerlink" title="（九）字体"></a>（九）字体</h2><p>\bfseries</p><p>\textbf{}</p><p>\itshape</p><p>\textit{}</p><p>\zihao{}</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% ----------------------------------------------</span></span><br><span class="line"><span class="comment">% \songti \heiti \kaishu \youyuan \lishu \yahei \fangsong</span></span><br><span class="line">&#123;<span class="keyword">\songti</span> 宋体&#125;</span><br><span class="line">&#123;<span class="keyword">\heiti</span> 黑体&#125;</span><br><span class="line">&#123;<span class="keyword">\kaishu</span> 楷书&#125;</span><br><span class="line">&#123;<span class="keyword">\youyuan</span> 幼圆&#125;</span><br><span class="line">&#123;<span class="keyword">\lishu</span> 隶书&#125;</span><br><span class="line">&#123;<span class="keyword">\yahei</span> 雅黑&#125;</span><br><span class="line">&#123;<span class="keyword">\fangsong</span> 仿宋&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 字体族</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\textrm</span> &#123;Hello&#125; <span class="comment">% 衬线</span></span><br><span class="line"><span class="keyword">\textsf</span> &#123;Hello&#125; <span class="comment">% 无衬线</span></span><br><span class="line"><span class="keyword">\textrm</span> &#123;Hello&#125; <span class="comment">% 等宽</span></span><br><span class="line">&#123;<span class="keyword">\rmfamily</span> Hello&#125; <span class="comment">% 衬线</span></span><br><span class="line">&#123;<span class="keyword">\sffamily</span> Hello&#125; <span class="comment">% 无衬线</span></span><br><span class="line">&#123;<span class="keyword">\ttfamily</span> Hello&#125; <span class="comment">% 等宽</span></span><br><span class="line"><span class="comment">% ----------------------------------------------</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\textmd</span> &#123;Hello&#125; <span class="comment">% 非粗体</span></span><br><span class="line"><span class="keyword">\textbf</span> &#123;Hello&#125; <span class="comment">% 粗体</span></span><br><span class="line">&#123;<span class="keyword">\mdseries</span> Hello&#125; <span class="comment">% 非粗体</span></span><br><span class="line">&#123;<span class="keyword">\bfseries</span> Hello&#125; <span class="comment">% 粗体</span></span><br><span class="line"><span class="keyword">\underline</span> &#123;Hello&#125; <span class="comment">% 下划线</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\textup</span> &#123;Hello&#125; <span class="comment">% 直立</span></span><br><span class="line"><span class="keyword">\textit</span> &#123;Hello&#125; <span class="comment">% 斜体</span></span><br><span class="line"><span class="keyword">\textsl</span> &#123;Hello&#125; <span class="comment">% 伪斜体</span></span><br><span class="line"><span class="keyword">\textsc</span> &#123;Hello&#125; <span class="comment">% 小大写</span></span><br><span class="line">&#123;<span class="keyword">\upshape</span> Hello&#125; <span class="comment">% 直立</span></span><br><span class="line">&#123;<span class="keyword">\itshape</span> Hello&#125; <span class="comment">% 斜体</span></span><br><span class="line">&#123;<span class="keyword">\slshape</span> Hello&#125; <span class="comment">% 伪斜体</span></span><br><span class="line">&#123;<span class="keyword">\scshape</span> Hello&#125; <span class="comment">% 小大写</span></span><br><span class="line"><span class="comment">% ----------------------------------------------</span></span><br><span class="line"><span class="keyword">\\</span> <span class="comment">% 字体大小</span></span><br><span class="line">&#123;<span class="keyword">\tiny</span> Hello&#125;</span><br><span class="line">&#123;<span class="keyword">\scriptsize</span> Hello&#125;</span><br><span class="line">&#123;<span class="keyword">\footnotesize</span> Hello&#125;</span><br><span class="line">&#123;<span class="keyword">\small</span> Hello&#125;</span><br><span class="line">&#123;<span class="keyword">\normalsize</span> Hello&#125;</span><br><span class="line">&#123;<span class="keyword">\large</span> Hello&#125;</span><br><span class="line">&#123;<span class="keyword">\Large</span> Hello&#125;</span><br><span class="line">&#123;<span class="keyword">\LARGE</span> Hello&#125;</span><br><span class="line">&#123;<span class="keyword">\huge</span> Hello&#125;</span><br><span class="line">&#123;<span class="keyword">\Huge</span> Hello&#125;</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\zihao</span>&#123;0&#125; 字体 <span class="comment">% 最大字体</span></span><br><span class="line"><span class="keyword">\zihao</span>&#123;-0&#125; 字体</span><br><span class="line"><span class="keyword">\zihao</span>&#123;1&#125; 字体</span><br><span class="line"><span class="keyword">\zihao</span>&#123;-1&#125; 字体</span><br><span class="line"><span class="keyword">\zihao</span>&#123;2&#125; 字体</span><br><span class="line"><span class="keyword">\zihao</span>&#123;-2&#125; 字体</span><br><span class="line"><span class="keyword">\zihao</span>&#123;3&#125; 字体</span><br><span class="line"><span class="keyword">\zihao</span>&#123;-3&#125; 字体</span><br><span class="line"><span class="keyword">\zihao</span>&#123;4&#125; 字体</span><br><span class="line"><span class="keyword">\zihao</span>&#123;-4&#125; 字体</span><br><span class="line"><span class="keyword">\zihao</span>&#123;5&#125; 字体</span><br><span class="line"><span class="keyword">\zihao</span>&#123;-5&#125; 字体</span><br><span class="line"><span class="keyword">\zihao</span>&#123;6&#125; 字体</span><br><span class="line"><span class="keyword">\zihao</span>&#123;-6&#125; 字体</span><br><span class="line"><span class="keyword">\zihao</span>&#123;7&#125; 字体</span><br><span class="line"><span class="keyword">\zihao</span>&#123;8&#125; 字体 <span class="comment">% 最小字体</span></span><br><span class="line"><span class="comment">% ----------------------------------------------</span></span><br><span class="line"><span class="comment">% 单位：pt</span></span><br><span class="line"><span class="keyword">\\</span>[1pt] <span class="comment">% 磅</span></span><br><span class="line"><span class="comment">% 单位：em</span></span><br><span class="line"><span class="keyword">\\</span>[1em] <span class="comment">% 当前对象内文本的字体尺寸</span></span><br></pre></td></tr></table></figure><h2 id="（十）特殊符号"><a href="#（十）特殊符号" class="headerlink" title="（十）特殊符号"></a>（十）特殊符号</h2><p>\quad</p><p>\qquad</p><p>\kern</p><p>\textbackslash</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 空格</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line">空 <span class="keyword">\quad</span> 格 <span class="keyword">\\</span> <span class="comment">% 1em</span></span><br><span class="line">空 <span class="keyword">\qquad</span> 格 <span class="keyword">\\</span> <span class="comment">% 2em</span></span><br><span class="line">空 <span class="keyword">\thinspace</span> 格 <span class="keyword">\\</span> <span class="comment">% 1/6em</span></span><br><span class="line">空 <span class="keyword">\enspace</span> 格 <span class="keyword">\\</span> <span class="comment">% 1/2em</span></span><br><span class="line">空<span class="keyword">\ </span>格 <span class="keyword">\\</span> <span class="comment">% 空格</span></span><br><span class="line">空~格 <span class="keyword">\\</span> <span class="comment">% 空格</span></span><br><span class="line">空<span class="keyword">\kern</span> -0.5pc 格 <span class="keyword">\\</span> <span class="comment">% 空格</span></span><br><span class="line">空<span class="keyword">\hskip</span> 1em 格 <span class="keyword">\\</span> <span class="comment">% 空格</span></span><br><span class="line"><span class="comment">% 反斜杠</span></span><br><span class="line"><span class="keyword">\textbackslash</span> <span class="keyword">\\</span></span><br><span class="line"><span class="comment">% LaTeX标志</span></span><br><span class="line"><span class="keyword">\TeX</span></span><br><span class="line"><span class="keyword">\LaTeX</span></span><br><span class="line"><span class="keyword">\LaTeXe</span></span><br><span class="line"><span class="comment">% 引号</span></span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line">`单引号&#x27; <span class="keyword">\\</span></span><br><span class="line">``双引号&#x27;&#x27; <span class="keyword">\\</span></span><br><span class="line"><span class="comment">% 希腊字母</span></span><br><span class="line">α <span class="keyword">\alpha</span> θ <span class="keyword">\theta</span> o o υ <span class="keyword">\upsilon</span></span><br><span class="line">β <span class="keyword">\beta</span> ϑ <span class="keyword">\vartheta</span> π <span class="keyword">\pi</span> ϕ <span class="keyword">\phi</span></span><br><span class="line">γ <span class="keyword">\gamma</span> ι <span class="keyword">\iota</span> ϖ <span class="keyword">\varpi</span> φ <span class="keyword">\varphi</span></span><br><span class="line">δ <span class="keyword">\delta</span> κ <span class="keyword">\kappa</span> ρ <span class="keyword">\rho</span> χ <span class="keyword">\chi</span></span><br><span class="line">ϵ <span class="keyword">\epsilon</span> λ <span class="keyword">\lambda</span> ϱ <span class="keyword">\varrho</span> ψ <span class="keyword">\psi</span></span><br><span class="line">ε <span class="keyword">\varepsilon</span> µ <span class="keyword">\mu</span> σ <span class="keyword">\sigma</span> ω <span class="keyword">\omega</span></span><br><span class="line">ζ <span class="keyword">\zeta</span> ν <span class="keyword">\nu</span> ς <span class="keyword">\varsigma</span></span><br><span class="line">η <span class="keyword">\eta</span> ξ <span class="keyword">\xi</span> τ <span class="keyword">\tau</span></span><br><span class="line">Γ <span class="keyword">\Gamma</span> Λ <span class="keyword">\Lambda</span> Σ <span class="keyword">\Sigma</span> Ψ <span class="keyword">\Psi</span></span><br><span class="line">∆ <span class="keyword">\Delta</span> Ξ <span class="keyword">\Xi</span> Υ <span class="keyword">\Upsilon</span> Ω <span class="keyword">\Omega</span></span><br><span class="line">Θ <span class="keyword">\Theta</span> Π <span class="keyword">\Pi</span> Φ <span class="keyword">\Phi</span></span><br></pre></td></tr></table></figure><h2 id="（十一）表格"><a href="#（十一）表格" class="headerlink" title="（十一）表格"></a>（十一）表格</h2><p>{tabular}{lcrp}</p><p>\hline</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 表格</span></span><br><span class="line"><span class="comment">% https://www.tablesgenerator.com/</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|l|c|c|c|p&#123;2cm&#125;|&#125;</span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">单元格A <span class="built_in">&amp;</span> 单元格B <span class="built_in">&amp;</span> 单元格C <span class="built_in">&amp;</span> 单元格D <span class="built_in">&amp;</span> 单元格E <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">单元格A <span class="built_in">&amp;</span> 单元格B <span class="built_in">&amp;</span> 单元格C <span class="built_in">&amp;</span> 单元格D <span class="built_in">&amp;</span> 单元格E <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">单元格A <span class="built_in">&amp;</span> 单元格B <span class="built_in">&amp;</span> 单元格C <span class="built_in">&amp;</span>  <span class="built_in">&amp;</span>  <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure><h2 id="（十二）图片"><a href="#（十二）图片" class="headerlink" title="（十二）图片"></a>（十二）图片</h2><p>\includegraphics{}</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 插入图片</span></span><br><span class="line"><span class="keyword">\includegraphics</span>&#123;./Assets/img<span class="built_in">_</span>1&#125;</span><br><span class="line"><span class="keyword">\includegraphics</span>[scale=3]&#123;./Assets/img<span class="built_in">_</span>1&#125;</span><br><span class="line"><span class="keyword">\includegraphics</span>[width=2cm]&#123;./Assets/img<span class="built_in">_</span>1&#125;</span><br><span class="line"><span class="keyword">\includegraphics</span>[scale=3, width=2cm, height=5cm]&#123;./Assets/img<span class="built_in">_</span>1&#125;</span><br><span class="line"><span class="keyword">\includegraphics</span>[angle=45]&#123;./Assets/img<span class="built_in">_</span>1&#125;</span><br><span class="line"><span class="keyword">\includegraphics</span>[width=0.5<span class="keyword">\textwidth</span>, height=0.4<span class="keyword">\textheight</span>]&#123;./Assets/img<span class="built_in">_</span>1&#125;</span><br></pre></td></tr></table></figure><h2 id="（十三）列表"><a href="#（十三）列表" class="headerlink" title="（十三）列表"></a>（十三）列表</h2><p>{itemize}</p><p>{enumerate}</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125; <span class="comment">% 无序列表</span></span><br><span class="line"><span class="keyword">\item</span> 无序</span><br><span class="line"><span class="keyword">\item</span> 列表</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125; <span class="comment">% 有序列表</span></span><br><span class="line"><span class="keyword">\item</span> 有序</span><br><span class="line"><span class="keyword">\item</span> 列表</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br></pre></td></tr></table></figure><h2 id="（十四）公式"><a href="#（十四）公式" class="headerlink" title="（十四）公式"></a>（十四）公式</h2><p>{equation}</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> E=mc<span class="built_in">^</span>2 <span class="built_in">$</span> <span class="comment">% 公式$$</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span> E=mc<span class="built_in">^</span>2 <span class="built_in">$</span><span class="built_in">$</span> <span class="comment">% 公式$$</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;equation&#125; <span class="comment">% 公式$$</span></span><br><span class="line">E=mc<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\[</span> E=mc<span class="built_in">^</span>2 <span class="keyword">\]</span> <span class="comment">% 公式$$</span></span><br></pre></td></tr></table></figure><h2 id="（十五）对齐"><a href="#（十五）对齐" class="headerlink" title="（十五）对齐"></a>（十五）对齐</h2><p>{flushleft}</p><p>{center}</p><p>{flushright}</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;flushleft&#125;</span><br><span class="line">居左对齐</span><br><span class="line"><span class="keyword">\end</span>&#123;flushleft&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;center&#125;</span><br><span class="line">居中对齐</span><br><span class="line"><span class="keyword">\end</span>&#123;center&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;flushright&#125;</span><br><span class="line">居右对齐</span><br><span class="line"><span class="keyword">\end</span>&#123;flushright&#125;</span><br></pre></td></tr></table></figure><h2 id="（十六）脚注"><a href="#（十六）脚注" class="headerlink" title="（十六）脚注"></a>（十六）脚注</h2><p>\footnote{}</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\footnote</span>&#123;脚注1&#125;</span><br><span class="line"><span class="keyword">\footnote</span>&#123;脚注2&#125;</span><br></pre></td></tr></table></figure><h2 id="（十七）参考文献"><a href="#（十七）参考文献" class="headerlink" title="（十七）参考文献"></a>（十七）参考文献</h2><p>{thebibliography}</p><p>\bibitem{}</p><p>\cite{}</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;thebibliography&#125;&#123;99&#125;</span><br><span class="line"><span class="keyword">\bibitem</span> &#123;article1&#125; 参考文献...</span><br><span class="line"><span class="keyword">\end</span>&#123;thebibliography&#125;</span><br><span class="line"><span class="comment">% 引用</span></span><br><span class="line">引用自<span class="keyword">\cite</span> &#123;article1&#125;</span><br></pre></td></tr></table></figure><h2 id="（十八）浮动体"><a href="#（十八）浮动体" class="headerlink" title="（十八）浮动体"></a>（十八）浮动体</h2><p>{figure}</p><p>{table}</p><p>\centering</p><p>\caption{}</p><p>\label{}</p><p>\ref{}</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 浮动体</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[htbp]</span><br><span class="line"><span class="keyword">\centering</span> <span class="comment">% 居中</span></span><br><span class="line"><span class="keyword">\includegraphics</span>[scale=2]&#123;./Assets/img<span class="built_in">_</span>1&#125;</span><br><span class="line"><span class="keyword">\caption</span>&#123;标题&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br><span class="line"><span class="comment">%</span></span><br><span class="line">详情见表<span class="keyword">\ref</span>&#123;表格1&#125;： <span class="comment">% 引用标签</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;table&#125;[htbp] <span class="comment">% [h=here,t=top,b=bottom,p=page,!=not]</span></span><br><span class="line"><span class="keyword">\centering</span> <span class="comment">% 居中</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;|l|c|c|c|p&#123;2cm&#125;|&#125;</span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">单元格A <span class="built_in">&amp;</span> 单元格B <span class="built_in">&amp;</span> 单元格C <span class="built_in">&amp;</span> 单元格D <span class="built_in">&amp;</span> 单元格E <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">单元格A <span class="built_in">&amp;</span> 单元格B <span class="built_in">&amp;</span> 单元格C <span class="built_in">&amp;</span> 单元格D <span class="built_in">&amp;</span> 单元格E <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line">单元格A <span class="built_in">&amp;</span> 单元格B <span class="built_in">&amp;</span> 单元格C <span class="built_in">&amp;</span> 单元格D <span class="built_in">&amp;</span>  <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\hline</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line"><span class="keyword">\caption</span>&#123;标题&#125; <span class="keyword">\label</span>&#123;表格1&#125; <span class="comment">% 标签</span></span><br><span class="line"><span class="keyword">\end</span>&#123;table&#125;</span><br></pre></td></tr></table></figure><h2 id="（十九）盒子"><a href="#（十九）盒子" class="headerlink" title="（十九）盒子"></a>（十九）盒子</h2><p>\mbox{}</p><p>\makebox{}</p><p>fbox{}</p><p>\framebox{}</p><p>\setlength{}</p><p>\parbox{}</p><p>{minipage}</p><p>\rule{}</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 盒子</span></span><br><span class="line">|<span class="keyword">\mbox</span>&#123;盒子文本&#125;|<span class="keyword">\\</span> <span class="comment">% 单行盒子，不会换行</span></span><br><span class="line"><span class="comment">% c=center,l=left,r=right</span></span><br><span class="line">|<span class="keyword">\makebox</span>[10em][c]&#123;盒子文本&#125;|<span class="keyword">\\</span> <span class="comment">% 单行盒子，可设置宽度和对齐，不会换行</span></span><br><span class="line">|<span class="keyword">\makebox</span>[10em][l]&#123;盒子文本&#125;|<span class="keyword">\\</span></span><br><span class="line">|<span class="keyword">\makebox</span>[10em][r]&#123;盒子文本&#125;|<span class="keyword">\\</span></span><br><span class="line">|<span class="keyword">\makebox</span>[10em][s]&#123;盒子文本&#125;|<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\fbox</span>&#123;盒子文本&#125;<span class="keyword">\\</span> <span class="comment">% 单行方框盒子</span></span><br><span class="line"><span class="keyword">\framebox</span>[10em][r]&#123;盒子文本&#125;</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">\setlength</span>&#123;<span class="keyword">\fboxrule</span>&#125;&#123;1.6pt&#125; <span class="comment">% 宽度</span></span><br><span class="line"><span class="keyword">\framebox</span>[10em][r]&#123;盒子文本&#125;</span><br><span class="line">&#125;<span class="keyword">\\</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">\setlength</span>&#123;<span class="keyword">\fboxsep</span>&#125;&#123;1em&#125; <span class="comment">% 内边距</span></span><br><span class="line"><span class="keyword">\framebox</span>[10em][r]&#123;盒子文本&#125;</span><br><span class="line">&#125;<span class="keyword">\\</span></span><br><span class="line"><span class="comment">% t=top,b=bottom,c=center</span></span><br><span class="line">三字经：<span class="keyword">\parbox</span>[t]&#123;3em&#125; <span class="comment">% 垂直盒子（多行）&#123;3个字符一排&#125;</span></span><br><span class="line">&#123;人之初性本善性相近习相远&#125; <span class="keyword">\\</span></span><br><span class="line">千字文：</span><br><span class="line"><span class="keyword">\begin</span>&#123;minipage&#125;[b][8ex][t]&#123;4em&#125;</span><br><span class="line">天地玄黄 宇宙洪荒</span><br><span class="line"><span class="keyword">\footnote</span>&#123;脚注&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;minipage&#125;</span><br><span class="line"><span class="keyword">\\</span>[2em]</span><br><span class="line"><span class="comment">% 脚注</span></span><br><span class="line"><span class="keyword">\fbox</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">\begin</span>&#123;minipage&#125;&#123;15em&#125;</span><br><span class="line">这是一个垂直盒子的测试。</span><br><span class="line"><span class="keyword">\footnote</span>&#123;脚注来自 minipage。&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;minipage&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\rule</span>&#123;120pt&#125;&#123;40pt&#125; <span class="comment">% 标尺盒子</span></span><br><span class="line">A <span class="keyword">\rule</span>[-.4pt]&#123;3em&#125;&#123;.4pt&#125; line.</span><br></pre></td></tr></table></figure><h2 id="（二十）颜色"><a href="#（二十）颜色" class="headerlink" title="（二十）颜色"></a>（二十）颜色</h2><p>\color[rgb]{}</p><p>\textcolor[rgb]{}</p><p>\colorbox[rgb]{}</p><p>\fcolorbox[rgb]{}</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;xcolor&#125; <span class="comment">% 使用颜色宏包</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line">&#123;<span class="keyword">\color</span>[rgb]&#123;1,0,0&#125; 红色&#125; <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\textcolor</span>[rgb]&#123;1,0,0&#125;&#123;红色&#125; <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\colorbox</span>[rgb]&#123;1,0,0&#125;&#123;红色背景&#125; <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\fcolorbox</span>[rgb]&#123;1,0,0&#125;[rgb]&#123;1,1,0&#125;&#123;</span><br><span class="line"><span class="keyword">\textcolor</span>[rgb]&#123;1,0,0&#125;&#123;红色边框文字，黄色背景&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（二十一）宏"><a href="#（二十一）宏" class="headerlink" title="（二十一）宏"></a>（二十一）宏</h2><p>\newcommend … [][]{}</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 宏的定义必须在&#123;document&#125;外</span></span><br><span class="line"><span class="comment">% \newcommand&#123;\宏命名&#125;[参数个数][参数默认值]&#123;宏内容&#125;</span></span><br><span class="line"><span class="comment">% 宏命名只能使用英文大小写</span></span><br><span class="line"><span class="comment">% 参数上限是9个</span></span><br><span class="line"><span class="comment">% 参数用#1#2#3#4#5#6#7#8#9代替</span></span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\authorname</span>&#125;&#123;&#123;<span class="keyword">\zihao</span>&#123;0&#125; PYW&#125;&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\datetime</span>&#125;[3]&#123;&#123;<span class="keyword">\zihao</span>&#123;5&#125; <span class="params">#1</span> 年 <span class="params">#2</span> 月 <span class="params">#3</span> 日&#125;&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\citepage</span>&#125;[2][PYW]&#123;引用自 <span class="params">#1</span>，作者 <span class="params">#2</span>&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\fontlikeI</span>&#125;[1]</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">\begin</span>&#123;flushright&#125;</span><br><span class="line">&#123;<span class="keyword">\zihao</span>&#123;3&#125; <span class="keyword">\textit</span>&#123;<span class="params">#1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;flushright&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">% 使用宏</span></span><br><span class="line"><span class="keyword">\authorname</span></span><br><span class="line"><span class="keyword">\datetime</span>&#123;2020&#125;&#123;12&#125;&#123;21&#125;</span><br><span class="line"><span class="keyword">\citepage</span>&#123;pyw&#125;</span><br><span class="line"><span class="keyword">\fontlikeI</span>&#123;样式字符1&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LaTeX入门&quot;&gt;&lt;a href=&quot;#LaTeX入门&quot; class=&quot;headerlink&quot; title=&quot;LaTeX入门&quot;&gt;&lt;/a&gt;LaTeX入门&lt;/h1&gt;&lt;h2 id=&quot;（〇）安装&quot;&gt;&lt;a href=&quot;#（〇）安装&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="文档" scheme="http://iamsleepingnow.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="超纲" scheme="http://iamsleepingnow.github.io/tags/%E8%B6%85%E7%BA%B2/"/>
    
    <category term="论文" scheme="http://iamsleepingnow.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
    <category term="文档" scheme="http://iamsleepingnow.github.io/tags/%E6%96%87%E6%A1%A3/"/>
    
    <category term="LaTeX" scheme="http://iamsleepingnow.github.io/tags/LaTeX/"/>
    
  </entry>
  
</feed>
